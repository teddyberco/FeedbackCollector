<!DOCTYPE html>
<html>
<head>
    <title>Feedback Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            margin: 0; 
            background-color: #f8f9fa; /* Light gray background for the page */
        }
        .container-custom { /* Renamed from container-fluid to allow custom padding */
            padding: 20px;
        }
        /* Card specific styles */
        .card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 1px solid rgba(0,0,0,.125); /* Default Bootstrap card border */
        }
        .card:hover:not(.dropdown-open) {
            transform: translateY(-5px);
            box-shadow: 0 .5rem 1rem rgba(0,0,0,.15)!important; /* Enhanced shadow on hover */
        }
        
        .card.dropdown-open {
            z-index: 1000;
            transform: none !important;
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 500;
        }
        .card-subtitle {
            font-size: 0.85rem;
        }
        .feedback-content {
            font-size: 0.9rem;
            line-height: 1.5;
            max-height: 100px; /* Limit height and show overflow */
            overflow-y: auto;  /* Allow scrolling for longer feedback */
            margin-bottom: 1rem; /* Ensure space before buttons if content is short */
        }
        .card .badge { /* Style badges a bit */
            font-size: 0.75em;
        }
        /* Fluent-inspired clickable effect (optional, can be enhanced) */
        .card a.btn { /* Make button stand out a bit */
            font-weight: 500;
        }
        /* Sentiment badge styles */
        .sentiment-positive {
            background-color: #28a745 !important;
            animation: pulse-green 2s infinite;
        }
        .sentiment-negative {
            background-color: #dc3545 !important;
            animation: pulse-red 2s infinite;
        }
        .sentiment-neutral {
            background-color: #6c757d !important;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        
        /* Enhanced categorization styles */
        .audience-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 12px;
            padding: 4px 8px;
            margin-right: 4px;
        }
        .audience-developer { background-color: #007bff; color: white; }
        .audience-customer { background-color: #28a745; color: white; }
        .audience-isv { background-color: #6f42c1; color: white; }
        .audience-platform { background-color: #fd7e14; color: white; }
        .audience-unknown { background-color: #6c757d; color: white; }
        
        .priority-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 8px;
            padding: 3px 6px;
            margin-left: 4px;
        }
        .priority-critical {
            background-color: #dc3545;
            color: white;
            animation: pulse-red 2s infinite;
        }
        .priority-high { background-color: #fd7e14; color: white; }
        .priority-medium { background-color: #ffc107; color: #212529; }
        .priority-low { background-color: #6c757d; color: white; }
        
        .category-info {
            font-size: 0.75rem;
            color: #6c757d;
            margin-bottom: 8px;
        }
        
        .filter-section {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .filter-group {
            margin-bottom: 15px;
        }
        
        .filter-group:last-child {
            margin-bottom: 0;
        }
        
        .filter-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            display: block;
        }
        
        .domain-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 8px;
            padding: 3px 6px;
            margin-right: 4px;
            color: white;
        }
        
        .repeating-analysis {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .similarity-indicator {
            font-size: 0.75rem;
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }
        
        /* State Management Styles */
        .state-badge {
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            padding: 4px 10px;
            margin-right: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .state-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .state-new { background-color: #6c757d; color: white; }
        .state-triaged { background-color: #007bff; color: white; }
        .state-closed { background-color: #28a745; color: white; }
        .state-irrelevant { background-color: #dc3545; color: white; }
        
        .card-actions {
            position: relative;
            display: inline-block;
        }
        .actions-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }
        .actions-menu.show {
            display: block;
        }
        .actions-menu a {
            display: block;
            padding: 8px 12px;
            text-decoration: none;
            color: #333;
            border-bottom: 1px solid #eee;
        }
        .actions-menu a:hover {
            background-color: #f8f9fa;
        }
        .actions-menu a:last-child {
            border-bottom: none;
        }
        
        .state-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 100000 !important;
            min-width: 120px;
            display: none;
            top: calc(100% + 2px);
            left: 0;
            max-width: 200px;
            white-space: nowrap;
            opacity: 1 !important;
        }
        
        .state-dropdown.show {
            display: block !important;
            opacity: 1 !important;
        }
        
        .state-option {
            padding: 8px 12px;
            cursor: pointer;
            color: #333;
            font-size: 14px;
            display: block;
            text-decoration: none;
        }
        
        .state-option:hover {
            background-color: #f8f9fa;
            color: #333;
        }
        
        .state-badge {
            position: relative;
            display: inline-block;
        }
        
        .state-badge {
            position: relative;
        }
        
        .card {
            overflow: visible !important;
        }
        
        .card-body {
            overflow: visible !important;
        }
        
        .category-info {
            overflow: visible !important;
            position: relative;
        }
        .state-dropdown.show {
            display: block;
        }
        .state-option {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.85rem;
        }
        .state-option:hover {
            background-color: #f8f9fa;
        }
        .state-option:last-child {
            border-bottom: none;
        }
        
        .token-banner {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .token-banner.hidden {
            display: none;
        }
        
        .notes-display {
            font-size: 0.8rem;
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 6px 0;
            border-left: 3px solid #007bff;
        }
        
        .state-management-disabled .state-badge {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .state-management-disabled .card-actions {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Ensure state badges are enabled when state management is active */
        .state-badge {
            opacity: 1;
            cursor: pointer;
        }
        
        .state-badge:hover {
            opacity: 0.8;
        }
    </style>
    
    <!-- Badge State Manager -->
    <script src="{{ url_for('static', filename='js/badge-state-manager.js') }}"></script>
</head>
<body>
    <div class="container-custom mt-3">
        <h1>Collected Feedback</h1>
        <p>
            <a href="/">Back to Collector</a>
            <button class="btn btn-outline-primary ms-2" id="collectionProgressBtn" onclick="toggleCollectionProgress()">
                <i class="bi bi-activity me-1"></i>Collection Progress
                <span class="badge bg-secondary ms-1" id="progressBadge">Ready</span>
            </button>
            <button class="btn btn-primary ms-2" id="fabricSyncBtn" onclick="syncWithFabric()"
                    title="Connect to Fabric SQL database to load and manage feedback states">
                <i class="bi bi-database me-1"></i>Sync with Fabric
                <span class="badge bg-light text-dark ms-1" id="fabricSyncBadge">Not Connected</span>
            </button>
        </p>

        <!-- State Management Disabled Message -->
        <div id="state-management-disabled" class="alert alert-info" style="display: block;">
            <i class="bi bi-info-circle me-2"></i>
            <strong>State Management Disabled:</strong> Click "Sync with Fabric" to connect to the SQL database and enable feedback state management.
        </div>

        <!-- Fabric Auth will now be handled through the persistent drawer -->

        <!-- Enhanced Statistics Dashboard -->
        {% if category_stats %}
        <div class="alert alert-info" role="alert">
            <h5 class="alert-heading">üìä Category Statistics</h5>
            <div class="row">
                <div class="col-md-3">
                    <strong>By Audience:</strong>
                    <ul class="mb-0">
                        {% for audience, count in category_stats.by_audience.items() %}
                        <li>{{ audience }}: {{ count }} ({{ "%.1f"|format((count/category_stats.total_items)*100) }}%)</li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>By Priority:</strong>
                    <ul class="mb-0">
                        {% for priority, data in category_stats.priority_distribution.items() %}
                        <li>{{ priority|title }}: {{ data.count }} ({{ data.percentage }}%)</li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>By Domain:</strong>
                    <ul class="mb-0">
                        {% for domain, count in category_stats.by_domain.items() %}
                        {% if count > 0 %}
                        <li>{{ domain }}: {{ count }}</li>
                        {% endif %}
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>Top Categories:</strong>
                    <ul class="mb-0">
                        {% for category, count in (category_stats.by_enhanced_category.items()|list)[:3] %}
                        <li>{{ category[:20] }}{% if category|length > 20 %}...{% endif %}: {{ count }}</li>
                        {% endfor %}
                    </ul>
                </div>
            </div>
        </div>
        {% elif trending_category_name and trending_category_count > 0 %}
        <div class="alert alert-info" role="alert">
            <h5 class="alert-heading">üî• Trending Category</h5>
            <p>The most frequent category in the current view is: <strong>{{ trending_category_name }}</strong> ({{ trending_category_count }} item{% if trending_category_count != 1 %}s{% endif %}).</p>
        </div>
        {% endif %}

        {% if feedback_items %}
        <div class="alert alert-light border" role="alert">
            <h6 class="alert-heading">üìä Sentiment Overview</h6>
            <div class="row text-center">
                {% set positive_count = feedback_items | selectattr('Sentiment', 'equalto', 'Positive') | list | length %}
                {% set negative_count = feedback_items | selectattr('Sentiment', 'equalto', 'Negative') | list | length %}
                {% set neutral_count = feedback_items | selectattr('Sentiment', 'equalto', 'Neutral') | list | length %}
                <div class="col-4">
                    <span class="badge sentiment-positive">üòä {{ positive_count }} Positive</span>
                </div>
                <div class="col-4">
                    <span class="badge sentiment-neutral">üòê {{ neutral_count }} Neutral</span>
                </div>
                <div class="col-4">
                    <span class="badge sentiment-negative">üòû {{ negative_count }} Negative</span>
                </div>
            </div>
        </div>
        {% endif %}

        <!-- Enhanced Filter Section -->
        <div class="filter-section">
            <h5 class="mb-3">üîç Enhanced Filters</h5>
            
            <!-- State Filter - Multi-select -->
            <div class="filter-group">
                <label class="filter-label" for="stateFilter">üìù Filter by State:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="stateFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_states %}
                            {{ selected_states|length }} state(s) selected
                        {% else %}
                            All States
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 250px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="state_all" onchange="toggleFilterAll('state')"
                                   {% if not selected_states %}checked{% endif %}>
                            <label class="form-check-label" for="state_all">All States</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for state in all_states %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="state"
                                   value="{{ state }}" id="state_{{ state|lower }}"
                                   {% if state in selected_states %}checked{% endif %}>
                            <label class="form-check-label" for="state_{{ state|lower }}">
                                {% if state == 'NEW' %}üÜï New
                                {% elif state == 'TRIAGED' %}üîç Triaged
                                {% elif state == 'CLOSED' %}‚úÖ Closed
                                {% elif state == 'IRRELEVANT' %}‚ùå Irrelevant
                                {% else %}{{ state }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Audience Filter - Multi-select -->
            <div class="filter-group">
                <label class="filter-label" for="audienceFilter">üë• Filter by Audience:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="audienceFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_audiences %}
                            {{ selected_audiences|length }} audience(s) selected
                        {% else %}
                            All Audiences
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 250px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="audience_all" onchange="toggleFilterAll('audience')"
                                   {% if not selected_audiences %}checked{% endif %}>
                            <label class="form-check-label" for="audience_all">All Audiences</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for audience in all_audiences %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="audience"
                                   value="{{ audience }}" id="audience_{{ audience|lower }}"
                                   {% if audience in selected_audiences %}checked{% endif %}>
                            <label class="form-check-label" for="audience_{{ audience|lower }}">
                                {% if audience == 'Developer' %}üõ†Ô∏è Developer
                                {% elif audience == 'Customer' %}üë§ Customer
                                {% elif audience == 'ISV' %}üè¢ ISV
                                {% else %}{{ audience }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Priority Filter - Multi-select -->
            <div class="filter-group">
                <label class="filter-label" for="priorityFilter">‚ö° Filter by Priority:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="priorityFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_priorities %}
                            {{ selected_priorities|length }} priority(s) selected
                        {% else %}
                            All Priorities
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 250px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="priority_all" onchange="toggleFilterAll('priority')"
                                   {% if not selected_priorities %}checked{% endif %}>
                            <label class="form-check-label" for="priority_all">All Priorities</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for priority in all_priorities %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="priority"
                                   value="{{ priority }}" id="priority_{{ priority|lower }}"
                                   {% if priority in selected_priorities %}checked{% endif %}>
                            <label class="form-check-label" for="priority_{{ priority|lower }}">
                                {% if priority|lower == 'critical' %}üî¥ Critical
                                {% elif priority|lower == 'high' %}üü† High
                                {% elif priority|lower == 'medium' %}üü° Medium
                                {% elif priority|lower == 'low' %}‚ö™ Low
                                {% else %}{{ priority|title }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>

            <!-- Enhanced Category Filter - Multi-select -->
            {% if all_enhanced_categories %}
            <div class="filter-group">
                <label class="filter-label" for="enhanced_categoryFilter">üìÇ Filter by Enhanced Category:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="enhanced_categoryFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_enhanced_categories %}
                            {{ selected_enhanced_categories|length }} category(s) selected
                        {% else %}
                            All Categories
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 350px; max-height: 400px; overflow-y: auto;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="enhanced_category_all" onchange="toggleFilterAll('enhanced_category')"
                                   {% if not selected_enhanced_categories %}checked{% endif %}>
                            <label class="form-check-label" for="enhanced_category_all">All Categories</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for cat in all_enhanced_categories %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="enhanced_category"
                                   value="{{ cat }}" id="enhanced_category_{{ loop.index }}"
                                   {% if cat in selected_enhanced_categories %}checked{% endif %}>
                            <label class="form-check-label" for="enhanced_category_{{ loop.index }}">
                                {{ cat[:40] }}{% if cat|length > 40 %}...{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Domain Filter - Multi-select -->
            {% if all_domains %}
            <div class="filter-group">
                <label class="filter-label" for="domainFilter">üéØ Filter by Domain:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="domainFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_domains %}
                            {{ selected_domains|length }} domain(s) selected
                        {% else %}
                            All Domains
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 300px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="domain_all" onchange="toggleFilterAll('domain')"
                                   {% if not selected_domains %}checked{% endif %}>
                            <label class="form-check-label" for="domain_all">All Domains</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for domain in all_domains %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="domain"
                                   value="{{ domain }}" id="domain_{{ domain|lower|replace('_', '') }}"
                                   {% if domain in selected_domains %}checked{% endif %}>
                            <label class="form-check-label" for="domain_{{ domain|lower|replace('_', '') }}">
                                {% if domain == 'GOVERNANCE' %}üèõÔ∏è Governance
                                {% elif domain == 'USER_EXPERIENCE' %}üé® User Experience
                                {% elif domain == 'AUTHENTICATION' %}üîê Authentication & Security
                                {% elif domain == 'PERFORMANCE' %}‚ö° Performance & Scalability
                                {% elif domain == 'INTEGRATION' %}üîó Integration & APIs
                                {% elif domain == 'ANALYTICS' %}üìä Analytics & Reporting
                                {% else %}{{ domain }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Source Filter - Multi-select -->
            {% if all_sources %}
            <div class="filter-group">
                <label class="filter-label" for="sourceFilter">üì° Filter by Source:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="sourceFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_sources %}
                            {{ selected_sources|length }} source(s) selected
                        {% else %}
                            All Sources
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 250px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="source_all" onchange="toggleFilterAll('source')"
                                   {% if not selected_sources %}checked{% endif %}>
                            <label class="form-check-label" for="source_all">All Sources</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for src in all_sources %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="source"
                                   value="{{ src }}" id="source_{{ src|lower|replace(' ', '_') }}"
                                   {% if src in selected_sources %}checked{% endif %}>
                            <label class="form-check-label" for="source_{{ src|lower|replace(' ', '_') }}">
                                {% if src == 'Reddit' %}üì± Reddit
                                {% elif src == 'GitHub' %}üíª GitHub
                                {% elif 'Fabric' in src %}üè¢ {{ src }}
                                {% else %}{{ src }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Sentiment Filter - Multi-select -->
            {% if all_sentiments %}
            <div class="filter-group">
                <label class="filter-label" for="sentimentFilter">üòä Filter by Sentiment:</label>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="sentimentFilter" data-bs-toggle="dropdown" aria-expanded="false">
                        {% if selected_sentiments %}
                            {{ selected_sentiments|length }} sentiment(s) selected
                        {% else %}
                            All Sentiments
                        {% endif %}
                    </button>
                    <div class="dropdown-menu p-3" style="min-width: 250px;">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="sentiment_all" onchange="toggleFilterAll('sentiment')"
                                   {% if not selected_sentiments %}checked{% endif %}>
                            <label class="form-check-label" for="sentiment_all">All Sentiments</label>
                        </div>
                        <hr class="dropdown-divider">
                        {% for sentiment in all_sentiments %}
                        <div class="form-check">
                            <input class="form-check-input filter-checkbox" type="checkbox" data-filter="sentiment"
                                   value="{{ sentiment }}" id="sentiment_{{ sentiment|lower }}"
                                   {% if sentiment in selected_sentiments %}checked{% endif %}>
                            <label class="form-check-label" for="sentiment_{{ sentiment|lower }}">
                                {% if sentiment|lower == 'positive' %}üòä Positive
                                {% elif sentiment|lower == 'negative' %}üòû Negative
                                {% elif sentiment|lower == 'neutral' %}üòê Neutral
                                {% else %}{{ sentiment|title }}{% endif %}
                            </label>
                        </div>
                        {% endfor %}
                        <hr class="dropdown-divider">
                        <button class="btn btn-primary btn-sm w-100" onclick="applyMultiSelectFilters()">Apply Filters</button>
                    </div>
                </div>
            </div>
            {% endif %}

            <!-- Sort Options -->
            <div class="filter-group">
                <span class="filter-label">üìÖ Sort by Date:</span>
                <div class="btn-group btn-group-sm" role="group" aria-label="Date sort options">
                    <a href="{{ url_for('feedback_viewer', sort='newest', state=current_state if current_state != 'All' else None, audience=current_audience if current_audience != 'All' else None, priority=current_priority if current_priority != 'All' else None, source=current_source if current_source != 'All' else None, enhanced_category=current_enhanced_category if current_enhanced_category != 'All' else None, sentiment=current_sentiment if current_sentiment != 'All' else None) }}"
                       class="btn {% if current_sort == 'newest' or not current_sort %}btn-success{% else %}btn-outline-success{% endif %}">üìÖ Newest First</a>
                    <a href="{{ url_for('feedback_viewer', sort='oldest', state=current_state if current_state != 'All' else None, audience=current_audience if current_audience != 'All' else None, priority=current_priority if current_priority != 'All' else None, source=current_source if current_source != 'All' else None, enhanced_category=current_enhanced_category if current_enhanced_category != 'All' else None, sentiment=current_sentiment if current_sentiment != 'All' else None) }}"
                       class="btn {% if current_sort == 'oldest' %}btn-success{% else %}btn-outline-success{% endif %}">üìÜ Oldest First</a>
               </div>
           </div>
           
           <!-- Repeating Requests Toggle -->
           <div class="filter-group">
               <span class="filter-label">üîÑ Repeating Requests Analysis:</span>
               <div class="btn-group btn-group-sm" role="group" aria-label="Repeating requests toggle">
                   <a href="{{ url_for('feedback_viewer', show_repeating='false', state=current_state if current_state != 'All' else None, audience=current_audience if current_audience != 'All' else None, priority=current_priority if current_priority != 'All' else None, enhanced_category=current_enhanced_category if current_enhanced_category != 'All' else None, domain=current_domain if current_domain != 'All' else None, source=current_source if current_source != 'All' else None, sentiment=current_sentiment if current_sentiment != 'All' else None, sort=current_sort if current_sort else None) }}"
                      class="btn {% if not show_repeating %}btn-outline-info{% else %}btn-info{% endif %}">Hide Analysis</a>
                   <a href="{{ url_for('feedback_viewer', show_repeating='true', state=current_state if current_state != 'All' else None, audience=current_audience if current_audience != 'All' else None, priority=current_priority if current_priority != 'All' else None, enhanced_category=current_enhanced_category if current_enhanced_category != 'All' else None, domain=current_domain if current_domain != 'All' else None, source=current_source if current_source != 'All' else None, sentiment=current_sentiment if current_sentiment != 'All' else None, sort=current_sort if current_sort else None) }}"
                      class="btn {% if show_repeating %}btn-info{% else %}btn-outline-info{% endif %}">üîç Analyze Repeating Requests</a>
               </div>
           </div>
       </div>

       <!-- Repeating Requests Analysis -->
       {% if show_repeating and repeating_analysis %}
       <div class="repeating-analysis">
           <h5>üîÑ Repeating Requests Analysis</h5>
           <div class="row">
               <div class="col-md-6">
                   <p><strong>Summary:</strong></p>
                   <ul>
                       <li>Total feedback items: {{ repeating_analysis.total_items }}</li>
                       <li>Unique requests: {{ repeating_analysis.unique_requests }}</li>
                       <li>Repeating clusters: {{ repeating_analysis.cluster_count }}</li>
                       <li>Repetition rate: {{ repeating_analysis.repetition_rate }}%</li>
                   </ul>
               </div>
               <div class="col-md-6">
                   <p><strong>Top Repeating Requests:</strong></p>
                   {% for req in repeating_analysis.top_repeating_requests[:3] %}
                   <div class="mb-2">
                       <strong>{{ req.count }}x:</strong> {{ req.summary }}
                       <br><small class="text-muted">Audiences: {{ req.audiences|join(', ') }} | Sources: {{ req.sources|join(', ') }}</small>
                   </div>
                   {% endfor %}
               </div>
           </div>
       </div>
       {% endif %}

        {% if source_info %}
            <p class="text-muted"><em>{{ source_info }}</em></p>
        {% endif %}
        
        {% if error %}
            <div class="alert alert-danger">{{ error }}</div>
        {% elif not feedback_items %}
            <!-- Empty State -->
            <div class="container text-center py-5">
                <div class="row justify-content-center">
                    <div class="col-md-8">
                        <div class="card shadow-sm">
                            <div class="card-body py-5">
                                <h3 class="card-title mb-4">üìÑ No Feedback Data Available</h3>
                                <p class="card-text mb-4">
                                    You can either collect new feedback from various sources or load existing data from your Fabric SQL database.
                                </p>
                                <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                    <a href="{{ url_for('index') }}" class="btn btn-primary btn-lg me-md-2">
                                        üîÑ Collect New Feedback
                                    </a>
                                    {% if stored_token %}
                                    <button class="btn btn-outline-primary btn-lg" onclick="loadFromFabricSQL()">
                                        üìä Load from Fabric SQL
                                    </button>
                                    {% else %}
                                    <button class="btn btn-outline-secondary btn-lg" onclick="alert('Please connect to Fabric first using the drawer on the right.')">
                                        üìä Load from Fabric SQL
                                    </button>
                                    {% endif %}
                                </div>
                                <hr class="my-4">
                                <small class="text-muted">
                                    <strong>Need to connect to Fabric?</strong> Use the drawer on the right to authenticate and sync your data.
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        {% elif feedback_items %}
            <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-4"> {# Bootstrap grid for cards #}
                {% for item in feedback_items %}
                <div class="col">
                    <div class="card h-100 shadow-sm"> {# h-100 for equal height cards in a row, shadow-sm for Fluent-like depth #}
                        <div class="card-body d-flex flex-column">
                            <h5 class="card-title">
                                {% if item['Feedback_Gist'] and item['Feedback_Gist']|trim != '' and item['Feedback_Gist']|lower != 'no content' and item['Feedback_Gist']|lower != 'summary unavailable' %}
                                    {{ item['Feedback_Gist'] }}
                                {% elif item.Title and item.Title|trim != '' %}
                                    {{ item.Title }} {# Fallback to original Title if Gist is not useful #}
                                {% else %}
                                    Feedback from {{ item.Sources or 'N/A' }} {# Generic fallback #}
                                {% endif %}
                            </h5>
                            <h6 class="card-subtitle mb-2 text-muted">
                                {{ item.Sources or 'Unknown Source' }}
                                {% if item.Created and item.Created|trim != '' %}
                                    - {{ item.Created.split('T')[0] }} {# Show Date part only #}
                                {% endif %}
                            </h6>
                            
                            <!-- Enhanced Categorization Info -->
                            {% if item.Audience or item.Enhanced_Category or item.Priority %}
                            <div class="category-info">
                                {% if item.Audience and item.Audience|trim != '' %}
                                    <span class="audience-badge audience-{{ item.Audience|lower }}"
                                          onclick="updateAudience('{{ item.Feedback_ID or '' }}', '{{ item.Audience }}')"
                                          title="Click to update audience"
                                          style="cursor: pointer;">
                                        {% if item.Audience == 'Developer' %}üõ†Ô∏è Developer
                                        {% elif item.Audience == 'Customer' %}üë§ Customer
                                        {% elif item.Audience == 'ISV' %}üè¢ ISV
                                        {% else %}{{ item.Audience }}{% endif %}
                                    </span>
                                {% endif %}
                                
                                {% if item.Priority and item.Priority|trim != '' %}
                                    <span class="priority-badge priority-{{ item.Priority|lower }}" title="Priority: {{ item.Priority|title }}">
                                        {% if item.Priority|lower == 'critical' %}üî¥ Critical
                                        {% elif item.Priority|lower == 'high' %}üü† High
                                        {% elif item.Priority|lower == 'medium' %}üü° Medium
                                        {% elif item.Priority|lower == 'low' %}‚ö™ Low
                                        {% else %}{{ item.Priority|title }}{% endif %}
                                    </span>
                               {% endif %}
                           </div>
                           
                           <!-- State Management Section -->
                           <div class="category-info">
                               <div class="d-flex justify-content-between align-items-center">
                                   <div>
                                       <!-- State Badge (clickable) with dropdown inside -->
                                       <span class="state-badge state-{{ (item.State or 'NEW')|lower }}"
                                             data-feedback-id="{{ item.Feedback_ID or '' }}"
                                             data-current-state="{{ item.State or 'NEW' }}"
                                             onclick="toggleStateDropdown(this, event)"
                                             title="Click to change state">
                                           {% set state = item.State or 'NEW' %}
                                           {% if state == 'NEW' %}üÜï New
                                           {% elif state == 'TRIAGED' %}üîç Triaged
                                           {% elif state == 'CLOSED' %}‚úÖ Closed
                                           {% elif state == 'IRRELEVANT' %}‚ùå Irrelevant
                                           {% else %}{{ state }}{% endif %}
                                           
                                           <!-- State Dropdown (inside state badge) -->
                                           <div class="state-dropdown" data-feedback-id="{{ item.Feedback_ID or '' }}">
                                               <div class="state-option" data-state="NEW">üÜï New</div>
                                               <div class="state-option" data-state="TRIAGED">üîç Triaged</div>
                                               <div class="state-option" data-state="CLOSED">‚úÖ Closed</div>
                                               <div class="state-option" data-state="IRRELEVANT">‚ùå Irrelevant</div>
                                           </div>
                                       </span>
                                       
                                       <!-- Last Updated Info -->
                                       {% if item.Last_Updated and item.Last_Updated|trim != '' %}
                                           <small class="text-muted ms-2">
                                               Updated: {{ item.Last_Updated.split('T')[0] }}
                                               {% if item.Updated_By and item.Updated_By|trim != '' %}
                                                   by {{ item.Updated_By }}
                                               {% endif %}
                                           </small>
                                       {% endif %}
                                   </div>
                                   
                                   <!-- Actions Menu -->
                                   <div class="card-actions">
                                       <button class="btn btn-sm btn-outline-secondary"
                                               data-feedback-id="{{ item.Feedback_ID or '' }}"
                                               onclick="toggleActionsMenu(this)"
                                               title="More actions">
                                           [...]
                                       </button>
                                       <div class="actions-menu">
                                           <a href="#" onclick="updateDomain('{{ item.Feedback_ID or '' }}', '{{ item.Primary_Domain or '' }}')">Update Domain</a>
                                           <a href="#" onclick="updateNotes('{{ item.Feedback_ID or '' }}', '{{ item.Feedback_Notes or '' }}')">
                                               {% if item.Feedback_Notes and item.Feedback_Notes|trim != '' %}Edit Note{% else %}Add Note{% endif %}
                                           </a>
                                       </div>
                                   </div>
                               </div>
                           </div>
                           
                           <!-- State Notes Display -->
                           {% if item.Feedback_Notes and item.Feedback_Notes|trim != '' %}
                           <div class="notes-display">
                               üìù {{ item.Feedback_Notes }}
                           </div>
                           {% endif %}
                           
                           {% if item.Enhanced_Category and item.Enhanced_Category|trim != '' %}
                           <div class="category-info">
                               <strong>Category:</strong> {{ item.Enhanced_Category }}
                               {% if item.Subcategory and item.Subcategory|trim != '' %}
                                   ‚Üí {{ item.Subcategory }}
                               {% endif %}
                               {% if item.Feature_Area and item.Feature_Area|trim != '' %}
                                   <br><strong>Area:</strong> {{ item.Feature_Area }}
                               {% endif %}
                               {% if item.Categorization_Confidence %}
                                   <span class="text-muted">({{ (item.Categorization_Confidence * 100)|round|int }}% confidence)</span>
                               {% endif %}
                           </div>
                           {% endif %}
                           
                           <!-- Domain Information -->
                           {% if item.Primary_Domain and item.Primary_Domain|trim != '' %}
                           <div class="category-info">
                               <strong>Domain:</strong>
                               <span class="domain-badge" style="background-color: #6c757d;">{{ item.Primary_Domain }}</span>
                           </div>
                           {% endif %}
                           {% endif %}
                            
                            <p class="card-text feedback-content mb-auto">
                                {{ item.Feedback }}
                            </p>
                            <div class="mt-auto pt-2"> {# Push button to bottom #}
                                {% if item.Url and item.Url|trim != '' %}
                                    <a href="{{ item.Url }}" class="btn btn-outline-primary btn-sm" target="_blank" rel="noopener noreferrer">View Source</a>
                                {% endif %}
                                {% if item.Tag and item.Tag|trim != '' %}
                                    <span class="badge bg-secondary ms-2">{{ item.Tag }}</span>
                                {% endif %}
                                {% if item.Status and item.Status|trim != '' %}
                                    <span class="badge bg-info ms-2">{{ item.Status }}</span>
                                {% endif %}
                                {% if item.Sentiment and item.Sentiment|trim != '' %}
                                    {% if item.Sentiment == 'Positive' %}
                                        <span class="badge sentiment-positive ms-2" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòä {{ item.Sentiment }}</span>
                                    {% elif item.Sentiment == 'Negative' %}
                                        <span class="badge sentiment-negative ms-2" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòû {{ item.Sentiment }}</span>
                                    {% else %}
                                        <span class="badge sentiment-neutral ms-2" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòê {{ item.Sentiment }}</span>
                                    {% endif %}
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        {% else %}
            <div class="alert alert-info">No feedback data to display. Try collecting feedback first.</div>
        {% endif %}

    </div> <!-- End of container-custom -->
    <script>
        // Global variables
        let bearerToken = null;
        let stateManagementEnabled = false;
        let cachedStateChanges = {};
        let hasUnsavedChanges = false;
        let fabricConnected = false;
        let fabricStateData = {};
        
        // Override any existing updateDomain function with fixed version
        function updateDomain(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è Domain update requested: ${feedbackId} ‚Üí current: ${currentDomain}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            console.log('üîç Connection check:', {
                stateManagementEnabled,
                hasStateData: !!hasStateData,
                urlIndicatesConnection,
                fabricConnected
            });
            
            // Allow if ANY connection indicator is present
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected) {
                console.log('‚ùå No connection indicators found - showing alert');
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            console.log('‚úÖ Connection check passed - showing domain dropdown');
            // Create domain dropdown
            showDomainDropdown(feedbackId, currentDomain);
        }
        
        // Override any existing updateNotes function too
        function updateNotes(feedbackId, currentNotes) {
            console.log(`üìù Notes update requested: ${feedbackId}`);
            
            // Same connection check as domain update
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Simple prompt for notes (can be enhanced later)
            const newNotes = prompt('Enter notes for this feedback:', currentNotes || '');
            if (newNotes !== null) {
                // Save notes (implementation similar to domain save)
                console.log(`üíæ Saving notes for ${feedbackId}: ${newNotes}`);
            }
        }
        
        // Preserve connection state in localStorage
        function saveFabricConnectionState() {
            localStorage.setItem('fabricConnected', fabricConnected);
            localStorage.setItem('stateManagementEnabled', stateManagementEnabled);
            localStorage.setItem('fabricDataSynced', 'true'); // Mark that actual data sync completed
        }
        
        function loadFabricConnectionState() {
            const savedConnected = localStorage.getItem('fabricConnected');
            const savedStateEnabled = localStorage.getItem('stateManagementEnabled');
            const dataSynced = localStorage.getItem('fabricDataSynced'); // New flag for actual data sync
            
            console.log('üîÑ Loading fabric connection state:', {
                savedConnected,
                savedStateEnabled,
                dataSynced
            });
            
            // Only restore "Connected" state if data was actually synced, not just auth
            if (savedConnected === 'true' && dataSynced === 'true') {
                fabricConnected = true;
                stateManagementEnabled = savedStateEnabled === 'true';
                
                // Try multiple times to restore UI state
                let attempt = 0;
                const maxAttempts = 20; // More attempts for filtering scenarios
                
                function attemptRestore() {
                    attempt++;
                    const syncBtn = document.getElementById('fabricSyncBtn');
                    
                    if (syncBtn) {
                        console.log(`‚úÖ Found UI elements on attempt ${attempt}, restoring connection state`);
                        updateConnectionUI();
                        
                        // Also reapply any state data
                        if (window.fabricStateData) {
                            console.log('üîÑ Reapplying state data after connection restore');
                            setTimeout(() => reapplyStateData(), 100);
                        }
                    } else if (attempt < maxAttempts) {
                        console.log(`‚è≥ UI elements not ready (attempt ${attempt}), retrying in ${100 + (attempt * 50)}ms...`);
                        setTimeout(attemptRestore, 100 + (attempt * 50));
                    } else {
                        console.warn('‚ö†Ô∏è Could not restore connection state - UI elements not found after', maxAttempts, 'attempts');
                    }
                }
                
                // Start restoration attempts
                attemptRestore();
                
                console.log('‚úÖ Fabric connection state restoration initiated');
            } else {
                console.log('‚ÑπÔ∏è No saved fabric data sync state found - showing "Sync with Fabric"');
            }
        }
        
        function updateConnectionUI() {
            // Try multiple times with delays to handle DOM loading
            let attempts = 0;
            const maxAttempts = 10;
            
            function tryUpdate() {
                attempts++;
                const syncBtn = document.getElementById('fabricSyncBtn');
                const badge = document.getElementById('fabricSyncBadge');
                const disabledMsg = document.getElementById('state-management-disabled');
                
                console.log(`üîÑ Updating connection UI (attempt ${attempts}):`, {
                    fabricConnected,
                    syncBtn: !!syncBtn,
                    badge: !!badge,
                    disabledMsg: !!disabledMsg
                });
                
                if (fabricConnected && syncBtn && syncBtn.classList) {
                    // Update sync button (always required)
                    syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Connected to Fabric';
                    syncBtn.classList.remove('btn-primary');
                    syncBtn.classList.add('btn-success');
                    console.log('‚úÖ Updated sync button to connected state');
                    
                    // Update badge (optional - might be missing in filtered views)
                    if (badge && badge.classList) {
                        badge.textContent = 'Connected';
                        badge.classList.remove('bg-light', 'text-dark');
                        badge.classList.add('bg-success');
                        console.log('‚úÖ Updated badge to connected state');
                    } else {
                        console.log('‚ö†Ô∏è Badge element missing (filtered view?) - continuing without badge');
                    }
                    
                    // Hide disabled message
                    if (disabledMsg) {
                        disabledMsg.style.display = 'none';
                        console.log('‚úÖ Hidden disabled message');
                    }
                    
                    // Enable state management (critical - must work even without badge)
                    stateManagementEnabled = true;
                    if (document.body && document.body.classList) {
                        document.body.classList.remove('state-management-disabled');
                    }
                    console.log('‚úÖ State management enabled');
                    
                    // Save state for future page loads
                    saveFabricConnectionState();
                    
                } else if (attempts < maxAttempts && fabricConnected) {
                    // Sync button not found, try again
                    console.log(`‚è≥ Sync button not found, retrying in ${50 * attempts}ms...`);
                    setTimeout(tryUpdate, 50 * attempts);
                } else if (fabricConnected) {
                    // Fallback: Enable state management even if UI elements are missing
                    console.warn('‚ö†Ô∏è Could not find sync button after', maxAttempts, 'attempts');
                    console.log('üîß Enabling state management anyway (fallback mode)');
                    stateManagementEnabled = true;
                    if (document.body && document.body.classList) {
                        document.body.classList.remove('state-management-disabled');
                    }
                }
            }
            
            tryUpdate();
        }
        
        // Check if token is available from session (from previous Fabric write)
        const sessionToken = '{{ stored_token or "" }}';
        const statesLoaded = '{{ states_already_loaded|lower }}' === 'true';
        
        console.log('Session check:', {sessionToken: sessionToken ? 'Present' : 'None', statesLoaded});
        
        // Auto-enable state management if token is available from session
        if (sessionToken && sessionToken.trim() !== '') {
            console.log('üîë Enabling state management from session token');
            bearerToken = sessionToken;
            stateManagementEnabled = true;
            
            // Hide token banner since it's already provided
            const tokenBanner = document.getElementById('tokenBanner');
            if (tokenBanner && tokenBanner.classList) {
                tokenBanner.classList.add('hidden');
            }
            
            // Enable state management UI immediately
            if (document.body && document.body.classList) {
                document.body.classList.remove('state-management-disabled');
            }
            
            // Show brief session message (only if not already shown)
            if (!sessionStorage.getItem('sessionMessageShown')) {
                const sessionMsg = document.createElement('div');
                sessionMsg.className = 'alert alert-success alert-dismissible fade show';
                sessionMsg.innerHTML = `
                    <strong>‚úÖ State management active</strong> - Token from previous Fabric write operation
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                const container = document.querySelector('.container-custom');
                const filterSection = document.querySelector('.filter-section');
                if (container && filterSection) {
                    container.insertBefore(sessionMsg, filterSection);
                } else if (container) {
                    container.appendChild(sessionMsg);
                }
                sessionStorage.setItem('sessionMessageShown', 'true');
                setTimeout(() => {
                    if (sessionMsg.parentNode) sessionMsg.remove();
                }, 3000);
            }
        } else {
            console.log('üîë No session token found - checking localStorage for Fabric connection');
            
            // Check if Fabric was previously connected
            const savedConnected = localStorage.getItem('fabricConnected');
            const savedDataSynced = localStorage.getItem('fabricDataSynced');
            
            if (savedConnected === 'true' && savedDataSynced === 'true') {
                console.log('üîó Restoring Fabric connection state from localStorage');
                fabricConnected = true;
                stateManagementEnabled = true;
                
                // Enable state management UI
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            } else {
                console.log('üîë No Fabric connection found - state management disabled');
                stateManagementEnabled = false;
                if (document.body && document.body.classList) {
                    document.body.classList.add('state-management-disabled');
                }
            }
        }
        
        // Apply cached changes to UI on page load
        applyCachedChangesToUI();
        
        // Apply cached changes to displayed feedback
        function applyCachedChangesToUI() {
            const cached = localStorage.getItem('feedbackStateChanges');
            if (!cached) {
                console.log('üíæ No cached changes found');
                return;
            }
            
            try {
                const changes = JSON.parse(cached);
                const changeCount = Object.keys(changes).length;
                console.log(`üíæ Applying ${changeCount} cached changes to UI`);
                
                Object.keys(changes).forEach(feedbackId => {
                    const change = changes[feedbackId];
                    updateUIFromCache(feedbackId, change);
                });
                
                // Show sync button if there are cached changes and state management is enabled
                if (changeCount > 0) {
                    updateSyncButton();
                }
                
            } catch (e) {
                console.error('Error applying cached changes:', e);
                localStorage.removeItem('feedbackStateChanges');
            }
        }
        
        // Update UI elements from cached data
        function updateUIFromCache(feedbackId, change) {
            console.log(`üíæ Updating UI for ${feedbackId}:`, change);
            
            // Update state if cached
            if (change.state) {
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                if (stateBadge) {
                    const stateNames = {
                        'NEW': 'üÜï New',
                        'TRIAGED': 'üîç Triaged',
                        'CLOSED': '‚úÖ Closed',
                        'IRRELEVANT': '‚ùå Irrelevant'
                    };
                    stateBadge.textContent = stateNames[change.state] || change.state;
                    stateBadge.className = `state-badge state-${change.state.toLowerCase()}`;
                    stateBadge.setAttribute('data-current-state', change.state);
                    console.log(`‚úÖ Updated state badge for ${feedbackId} to ${change.state}`);
                }
            }
            
            // Update domain if cached
            if (change.domain) {
                updateDomainDisplayFromCache(feedbackId, change.domain);
            }
            
            // Update notes if cached
            if (change.notes) {
                updateNotesDisplay(feedbackId, change.notes);
            }
        }
        
        // Update domain display from cache
        function updateDomainDisplayFromCache(feedbackId, domain) {
            const domainNames = {
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.card-body') : null;
            if (card) {
                const domainBadges = card.querySelectorAll('.domain-badge');
                if (domainBadges.length > 0) {
                    domainBadges[0].textContent = domainNames[domain] || domain;
                    console.log(`‚úÖ Updated domain for ${feedbackId} to ${domainNames[domain]}`);
                }
            }
        }
        
        // Enable state management when token is provided manually
        const enableStateBtn = document.getElementById('enableStateManagement');
        if (enableStateBtn && enableStateBtn.addEventListener) {
            enableStateBtn.addEventListener('click', function() {
            const token = document.getElementById('bearerToken').value.trim();
            if (!token) {
                alert('Please enter a valid bearer token');
                return;
            }
            
            bearerToken = token;
            
            // First, store token in session for persistence across navigation
            fetch('/api/store_session_token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({token: token})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('üîë Token stored in session successfully');
                    
                    // Now load states from Fabric Lakehouse
                    loadStatesFromFabric(token);
                } else {
                    alert('Error storing token: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error storing token:', error);
                // Continue with state loading even if session storage fails
                loadStatesFromFabric(token);
            });
        });
        }
        
        // Load actual states from Fabric Lakehouse
        function loadStatesFromFabric(token) {
            // Get all feedback IDs from the page
            const feedbackIds = [];
            document.querySelectorAll('[data-feedback-id]').forEach(element => {
                const id = element.getAttribute('data-feedback-id');
                if (id && !feedbackIds.includes(id)) {
                    feedbackIds.push(id);
                }
            });
            
            if (feedbackIds.length === 0) {
                enableStateManagement();
                return;
            }
            
            // Show loading message
            const loadingMsg = document.createElement('div');
            loadingMsg.id = 'loadingMsg';
            loadingMsg.className = 'alert alert-info';
            loadingMsg.innerHTML = 'üîÑ Loading states from Fabric Lakehouse...';
            document.querySelector('.container-custom').insertBefore(loadingMsg, document.querySelector('.filter-section'));
            
            fetch('/api/feedback/states/load', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': token
                },
                body: JSON.stringify({
                    feedback_ids: feedbackIds
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Update feedback cards with actual states from Fabric
                    updateFeedbackStatesFromFabric(data.states);
                    
                    // Load cached changes from localStorage
                    loadCachedChanges();
                    
                    // Enable state management
                    enableStateManagement();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `‚úÖ Loaded ${Object.keys(data.states).length} feedback states from Fabric Lakehouse`;
                    document.querySelector('.container-custom').insertBefore(successMsg, document.querySelector('.filter-section'));
                    setTimeout(() => successMsg.remove(), 5000);
                } else {
                    alert('Error loading states: ' + data.message);
                }
                
                // Remove loading message
                const loading = document.getElementById('loadingMsg');
                if (loading) loading.remove();
            })
            .catch(error => {
                alert('Error loading states: ' + error.message);
                const loading = document.getElementById('loadingMsg');
                if (loading) loading.remove();
            });
        }
        
        // Update feedback cards with states loaded from Fabric
        function updateFeedbackStatesFromFabric(fabricStates) {
            Object.keys(fabricStates).forEach(feedbackId => {
                const stateData = fabricStates[feedbackId];
                
                // Update state badge
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                if (stateBadge) {
                    const stateNames = {
                        'NEW': 'üÜï New',
                        'TRIAGED': 'üîç Triaged',
                        'CLOSED': '‚úÖ Closed',
                        'IRRELEVANT': '‚ùå Irrelevant'
                    };
                    
                    stateBadge.textContent = stateNames[stateData.State] || stateData.State;
                    stateBadge.className = `state-badge state-${stateData.State.toLowerCase()}`;
                    stateBadge.setAttribute('data-current-state', stateData.State);
                }
                
                // Update notes display (if notes exist)
                if (stateData.Feedback_Notes && stateData.Feedback_Notes.trim() !== '') {
                    // Find or create notes display
                    const card = stateBadge ? stateBadge.closest('.card-body') : null;
                    if (card) {
                        let notesDisplay = card.querySelector('.notes-display');
                        if (!notesDisplay) {
                            notesDisplay = document.createElement('div');
                            notesDisplay.className = 'notes-display';
                            // Insert after state management section
                            const stateSection = card.querySelector('.category-info');
                            if (stateSection) {
                                stateSection.parentNode.insertBefore(notesDisplay, stateSection.nextSibling);
                            }
                        }
                        notesDisplay.innerHTML = `üìù ${stateData.Feedback_Notes}`;
                    }
                }
            });
        }
        
        // Enable state management UI
        function enableStateManagement() {
            stateManagementEnabled = true;
            
            // Hide token banner
            document.getElementById('tokenBanner').classList.add('hidden');
            
            // Enable state management UI
            document.body.classList.remove('state-management-disabled');
            
            // Show sync button if there are cached changes
            updateSyncButton();
        }
        
        // Load cached changes from localStorage
        function loadCachedChanges() {
            const cached = localStorage.getItem('feedbackStateChanges');
            if (cached) {
                try {
                    cachedStateChanges = JSON.parse(cached);
                    hasUnsavedChanges = Object.keys(cachedStateChanges).length > 0;
                    updateSyncButton();
                } catch (e) {
                    console.error('Error loading cached changes:', e);
                    localStorage.removeItem('feedbackStateChanges');
                }
            }
        }
        
        // Save state change to cache
        function cacheStateChange(feedbackId, changeData) {
            if (!cachedStateChanges[feedbackId]) {
                cachedStateChanges[feedbackId] = {};
            }
            
            Object.assign(cachedStateChanges[feedbackId], changeData);
            cachedStateChanges[feedbackId].feedback_id = feedbackId;
            
            // Save to localStorage
            localStorage.setItem('feedbackStateChanges', JSON.stringify(cachedStateChanges));
            
            hasUnsavedChanges = true;
            updateSyncButton();
        }
        
        // Update sync button visibility and state
        function updateSyncButton() {
            let syncButton = document.getElementById('syncToFabricBtn');
            
            if (hasUnsavedChanges && stateManagementEnabled) {
                if (!syncButton) {
                    // Create sync button
                    syncButton = document.createElement('div');
                    syncButton.id = 'syncToFabricBtn';
                    syncButton.className = 'alert alert-warning d-flex justify-content-between align-items-center';
                    syncButton.innerHTML = `
                        <span>üíæ You have unsaved state changes</span>
                        <button class="btn btn-primary" onclick="syncToFabric()">Sync to Fabric</button>
                    `;
                    document.querySelector('.container-custom').insertBefore(syncButton, document.querySelector('.filter-section'));
                }
                
                // Update count
                const changeCount = Object.keys(cachedStateChanges).length;
                syncButton.querySelector('span').textContent = `üíæ You have ${changeCount} unsaved state change${changeCount !== 1 ? 's' : ''}`;
            } else if (syncButton) {
                syncButton.remove();
            }
        }
        
        // Sync cached changes to Fabric
        function syncToFabric() {
            if (!bearerToken || !hasUnsavedChanges) return;
            
            const stateChanges = Object.values(cachedStateChanges);
            
            // Show syncing message
            const syncBtn = document.getElementById('syncToFabricBtn');
            if (syncBtn) {
                syncBtn.innerHTML = 'üîÑ Syncing to Fabric...';
            }
            
            fetch('/api/feedback/states/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': bearerToken
                },
                body: JSON.stringify({
                    state_changes: stateChanges
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Clear cache
                    cachedStateChanges = {};
                    hasUnsavedChanges = false;
                    localStorage.removeItem('feedbackStateChanges');
                    
                    // Update UI
                    updateSyncButton();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `‚úÖ Successfully synced ${data.updated_count} state changes to Fabric`;
                    document.querySelector('.container-custom').insertBefore(successMsg, document.querySelector('.filter-section'));
                    setTimeout(() => successMsg.remove(), 5000);
                } else {
                    alert('Error syncing to Fabric: ' + data.message);
                    // Restore sync button
                    updateSyncButton();
                }
            })
            .catch(error => {
                alert('Error syncing to Fabric: ' + error.message);
                // Restore sync button
                updateSyncButton();
            });
        }
        
        // New SQL-based sync with Fabric function
        function syncWithFabric() {
            console.log('üîÑ Starting Fabric SQL sync process...');
            
            // Update button state
            const syncBtn = document.getElementById('fabricSyncBtn');
            const badge = document.getElementById('fabricSyncBadge');
            
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Connecting...';
            }
            
            // Call new API endpoint
            fetch('/api/fabric/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('‚úÖ Successfully connected to Fabric SQL database');
                    console.log('üìä Loaded state data:', data.state_data);
                    
                    // Store state data globally
                    fabricStateData = data.state_data;
                    fabricConnected = true;
                    
                    // Save connection state to localStorage
                    saveFabricConnectionState();
                    
                    // Update UI with loaded state data
                    updateFeedbackWithSQLData(data.state_data);
                    
                    // Enable state management
                    enableStateManagementSQL();
                    
                    // Update button
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Connected to Fabric';
                        syncBtn.classList.remove('btn-primary');
                        syncBtn.classList.add('btn-success');
                    }
                    
                    if (badge) {
                        badge.textContent = 'Connected';
                        badge.classList.remove('bg-light', 'text-dark');
                        badge.classList.add('bg-success');
                    }
                    
                    // Hide disabled message
                    const disabledMsg = document.getElementById('state-management-disabled');
                    if (disabledMsg) {
                        disabledMsg.style.display = 'none';
                    }
                    
                    // Show comprehensive success message with smart sync details
                    const syncResult = data.sync_result || {};
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `
                        ‚úÖ <strong>Fabric SQL Sync Complete!</strong><br>
                        üìù Added ${syncResult.new_items || 0} new feedback items (${syncResult.existing_items || 0} already existed)<br>
                        üîÑ Loaded ${Object.keys(data.state_data).length} state records from FeedbackState table<br>
                        <small class="text-muted">Smart sync: Only new items were written to avoid duplicates</small>
                    `;
                    document.querySelector('.container-custom').insertBefore(successMsg, document.querySelector('.filter-section'));
                    setTimeout(() => successMsg.remove(), 10000);
                    
                } else {
                    console.error('‚ùå Failed to connect to Fabric SQL database:', data.message);
                    alert('Failed to connect to Fabric SQL database: ' + data.message);
                    
                    // Reset button
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric';
                    }
                }
            })
            .catch(error => {
                console.error('‚ùå Error connecting to Fabric SQL:', error);
                alert('Error connecting to Fabric SQL database: ' + error.message);
                
                // Reset button
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric';
                }
            });
        }
        
        // Update feedback cards with SQL state data
        function updateFeedbackWithSQLData(stateData) {
            console.log('üîÑ Updating feedback cards with SQL state data...', stateData);
            console.log(`üìä State data contains ${Object.keys(stateData).length} records`);
            
            // First, let's see all feedback IDs on the page
            const allFeedbackElements = document.querySelectorAll('[data-feedback-id]');
            console.log(`üìã Found ${allFeedbackElements.length} feedback elements on page:`);
            allFeedbackElements.forEach(el => {
                console.log(`  - Page ID: "${el.getAttribute('data-feedback-id')}"`);
            });
            
            // Now check each state record
            Object.keys(stateData).forEach(feedbackId => {
                console.log(`üîç Looking for SQL feedback ID: "${feedbackId}"`);
            });
            
            let updatedCount = 0;
            let notFoundCount = 0;
            
            Object.keys(stateData).forEach(feedbackId => {
                const state = stateData[feedbackId];
                console.log(`üîÑ Processing state for "${feedbackId}":`, state);
                
                // Find the state badge element specifically (not dropdown elements)
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                
                if (!stateBadge) {
                    console.error(`‚ùå NO STATE BADGE FOUND for feedback ID: "${feedbackId}"`);
                    console.log(`Available feedback IDs on page:`, Array.from(document.querySelectorAll('[data-current-state]')).map(el => el.getAttribute('data-feedback-id')));
                    notFoundCount++;
                    return;
                }
                
                const card = stateBadge.closest('.card');
                if (!card) {
                    console.warn(`No card found for state badge:`, stateBadge);
                    notFoundCount++;
                    return;
                }
                
                console.log(`‚úÖ Found state badge and card for "${feedbackId}"`);
                    
                console.log(`üéØ Updating card for "${feedbackId}"`);
                
                // Update state badge
                if (state.state) {
                    const stateBadgeInCard = card.querySelector('[data-current-state]');
                    console.log(`üîç Looking for state badge in card, found:`, stateBadgeInCard);
                    
                    if (stateBadgeInCard) {
                        const stateNames = {
                            'NEW': 'üÜï New',
                            'TRIAGED': 'üîç Triaged',
                            'CLOSED': '‚úÖ Closed',
                            'IRRELEVANT': '‚ùå Irrelevant'
                        };
                            
                            const oldText = stateBadge.textContent;
                            const oldClass = stateBadge.className;
                            
                            stateBadge.textContent = stateNames[state.state] || state.state;
                            stateBadge.className = `state-badge state-${state.state.toLowerCase()}`;
                            stateBadge.setAttribute('data-current-state', state.state);
                            
                            console.log(`‚úÖ Updated state badge for "${feedbackId}": "${oldText}" ‚Üí "${stateBadge.textContent}"`);
                            console.log(`‚úÖ Updated state class: "${oldClass}" ‚Üí "${stateBadge.className}"`);
                        } else {
                            console.error(`‚ùå No state badge found in card for "${feedbackId}"`);
                        }
                    }
                    
                    // Update or add notes
                    if (state.notes) {
                        let notesDisplay = card.querySelector('.notes-display');
                        if (!notesDisplay) {
                            notesDisplay = document.createElement('div');
                            notesDisplay.className = 'notes-display alert alert-info mt-2';
                            const cardBody = card.querySelector('.card-body');
                            if (cardBody) {
                                cardBody.appendChild(notesDisplay);
                            }
                        }
                        notesDisplay.innerHTML = `üìù <strong>Notes:</strong> ${state.notes}`;
                        console.log(`‚úÖ Updated notes for "${feedbackId}": ${state.notes}`);
                    }
                    
                    // Update domain display
                    if (state.domain) {
                        let domainDisplay = card.querySelector('.domain-display');
                        if (!domainDisplay) {
                            domainDisplay = document.createElement('div');
                            domainDisplay.className = 'domain-display badge bg-secondary mt-1';
                            const cardBody = card.querySelector('.card-body');
                            if (cardBody) {
                                cardBody.appendChild(domainDisplay);
                            }
                        }
                        domainDisplay.textContent = `Domain: ${state.domain}`;
                        console.log(`‚úÖ Updated domain for "${feedbackId}": ${state.domain}`);
                    }
                    
                    updatedCount++;
            });
            
            console.log(`üìä FINAL RESULTS: Updated ${updatedCount} cards, ${notFoundCount} not found, from ${Object.keys(stateData).length} SQL records`);
            
            // Store the state data globally for filtering
            window.fabricStateData = stateData;
            
            // Also persist state data to localStorage for page reload survival
            try {
                localStorage.setItem('fabricStateData', JSON.stringify(stateData));
                localStorage.setItem('fabricStateDataTime', Date.now().toString());
                console.log('üíæ State data persisted to localStorage for page reload survival');
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not persist state data to localStorage:', error);
            }
        }
        
        // Reapply state data after filtering or other operations
        function reapplyStateData() {
            if (window.fabricStateData && Object.keys(window.fabricStateData).length > 0) {
                console.log('üîÑ Reapplying state data after filtering...');
                updateFeedbackWithSQLData(window.fabricStateData);
            }
        }
        
        // Enable state management with SQL backend
        function enableStateManagementSQL() {
            stateManagementEnabled = true;
            fabricConnected = true;
            
            // Save connection state to localStorage with timestamp
            localStorage.setItem('fabricConnected', 'true');
            localStorage.setItem('fabricStateEnabled', 'true');
            localStorage.setItem('fabricDataSynced', 'true');
            localStorage.setItem('fabricConnectionTime', Date.now().toString());
            
            // Enable all state controls
            document.querySelectorAll('.state-badge, .state-dropdown, [onclick*="updateDomain"], [onclick*="updateNotes"]').forEach(element => {
                element.style.pointerEvents = 'auto';
                element.style.opacity = '1';
                if (element.hasAttribute('disabled')) {
                    element.removeAttribute('disabled');
                }
            });
            
            console.log('‚úÖ State management enabled with SQL backend - connection timestamp saved');
        }
        
        // Test function to manually verify state loading
        function testStateLoading() {
            console.log('üß™ Testing state loading with sample data...');
            
            // Create test state data
            const testStateData = {};
            
            // Get the first few feedback IDs from the page
            const feedbackElements = document.querySelectorAll('[data-feedback-id]');
            console.log(`Found ${feedbackElements.length} feedback elements for testing`);
            
            // Apply test states to first few items
            for (let i = 0; i < Math.min(3, feedbackElements.length); i++) {
                const feedbackId = feedbackElements[i].getAttribute('data-feedback-id');
                testStateData[feedbackId] = {
                    state: i === 0 ? 'IRRELEVANT' : i === 1 ? 'TRIAGED' : 'CLOSED',
                    notes: `Test note for ${feedbackId}`,
                    domain: 'TEST_DOMAIN'
                };
            }
            
            console.log('üß™ Test state data:', testStateData);
            updateFeedbackWithSQLData(testStateData);
        }
        
        // Add global DOM observer to reapply state when cards are regenerated
        function setupStatePreservation() {
            // Store observer reference globally so we can disable/enable it
            window.stateObserver = null;
            
            // Create a mutation observer to watch for DOM changes
            const observer = new MutationObserver(function(mutations) {
                let shouldReapply = false;
                
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Only trigger for major DOM changes (new cards), not small UI changes
                        mutation.addedNodes.forEach(function(node) {
                            if (node && node.nodeType === Node.ELEMENT_NODE) {
                                // Only reapply if entire card containers are added (filtering)
                                if ((node.classList && node.classList.contains('row')) ||
                                    (node.querySelector && node.querySelector('.row'))) {
                                    shouldReapply = true;
                                }
                            }
                        });
                    }
                });
                
                if (shouldReapply && window.fabricStateData) {
                    console.log('üîÑ Major DOM change detected, reapplying state data...');
                    setTimeout(() => reapplyStateData(), 200); // Longer delay for stability
                }
            });
            
            // Start observing with reduced scope
            observer.observe(document.body, {
                childList: true,
                subtree: false  // Don't watch deep changes
            });
            
            window.stateObserver = observer;
            
            console.log('üëÅÔ∏è State preservation observer started');
        }
        
        // Check if duplicates should be hidden after recent Fabric sync
        function checkAndHideDuplicates() {
            const shouldHide = localStorage.getItem('hideDuplicatesAfterSync');
            const syncTimestamp = localStorage.getItem('syncTimestamp');
            
            console.log('üîç DEBUG: Checking duplicate hiding...', {
                shouldHide: shouldHide,
                syncTimestamp: syncTimestamp,
                currentTime: Date.now()
            });
            
            // Only hide if sync was recent (within last 10 minutes)
            const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
            
            if (shouldHide === 'true' && syncTimestamp && parseInt(syncTimestamp) > tenMinutesAgo) {
                console.log('üîÑ Hiding duplicate items after recent Fabric sync...');
                
                // Get stored IDs from server
                fetch('/api/fabric/stored_ids')
                    .then(response => {
                        console.log('üì° API response:', response);
                        return response.json();
                    })
                    .then(data => {
                        console.log('üìä Stored IDs data:', data);
                        if (data.status === 'success' && data.stored_ids) {
                            hideDuplicateCards(data.stored_ids);
                            showDuplicateHiddenMessage(data.total_stored, data.total_collected);
                        } else {
                            console.error('‚ùå API returned error:', data);
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Error getting stored IDs:', error);
                    });
                
                // Clear the flag after processing
                localStorage.removeItem('hideDuplicatesAfterSync');
                localStorage.removeItem('syncTimestamp');
            } else {
                console.log('‚è∏Ô∏è Not hiding duplicates:', {
                    shouldHide: shouldHide,
                    hasTimestamp: !!syncTimestamp,
                    isRecent: syncTimestamp ? parseInt(syncTimestamp) > tenMinutesAgo : false
                });
            }
        }
        
        // Manual function to test hiding (for debugging)
        function testHideDuplicates() {
            console.log('üß™ Testing duplicate hiding manually...');
            fetch('/api/fabric/stored_ids')
                .then(response => response.json())
                .then(data => {
                    console.log('üìä Manual test data:', data);
                    if (data.status === 'success' && data.stored_ids) {
                        console.log('üìã Stored IDs:', data.stored_ids);
                        console.log('üìã Total stored:', data.total_stored);
                        console.log('üìã Total collected:', data.total_collected);
                        
                        if (data.stored_ids.length === 0) {
                            console.log('‚ö†Ô∏è No stored IDs found - you need to write data to Fabric SQL first!');
                            alert('No stored IDs found.\n\n"Connected to Fabric" means your authentication token is valid, but no feedback data has been written to the SQL database yet.\n\nTo write data:\n1. Go to the home page\n2. Click "Write to Fabric"\n3. Wait for sync to complete\n4. Then return here to test duplicate filtering');
                            return;
                        }
                        
                        hideDuplicateCards(data.stored_ids);
                        showDuplicateHiddenMessage(data.total_stored, data.total_collected);
                    } else {
                        console.error('‚ùå API returned error:', data);
                        alert('Error: ' + (data.message || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Manual test error:', error);
                    alert('Network error: ' + error.message);
                });
        }
        
        // Hide cards for items not in stored IDs list
        function hideDuplicateCards(storedIds) {
            const cards = document.querySelectorAll('.card');
            let hiddenCount = 0;
            let processedIds = new Set(); // Track which IDs we've already processed
            
            cards.forEach(card => {
                const feedbackIdElement = card.querySelector('[data-feedback-id]');
                if (feedbackIdElement) {
                    const feedbackId = feedbackIdElement.getAttribute('data-feedback-id');
                    
                    // Skip if we've already processed this ID or if ID is empty
                    if (!feedbackId || processedIds.has(feedbackId)) {
                        return;
                    }
                    
                    processedIds.add(feedbackId);
                    
                    // Hide card if ID is NOT in stored IDs (showing only stored items)
                    if (!storedIds.includes(feedbackId)) {
                        card.style.display = 'none';
                        card.classList.add('duplicate-hidden');
                        hiddenCount++;
                        console.log(`üîí Hiding duplicate card with ID: ${feedbackId}`);
                    } else {
                        console.log(`‚úÖ Keeping stored item with ID: ${feedbackId}`);
                    }
                }
            });
            
            console.log(`‚úÖ Hidden ${hiddenCount} duplicate cards out of ${processedIds.size} unique items`);
        }
        
        // Show message about hidden duplicates
        function showDuplicateHiddenMessage(storedCount, totalCount) {
            const hiddenCount = totalCount - storedCount;
            if (hiddenCount > 0) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'alert alert-info alert-dismissible fade show';
                messageDiv.innerHTML = `
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Duplicate filtering active:</strong> Showing ${storedCount} items stored in Fabric.
                    ${hiddenCount} duplicate items are hidden.
                    <button type="button" class="btn btn-link btn-sm ms-2" onclick="showAllCards()">Show All</button>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                
                // Insert at top of container
                const container = document.querySelector('.container-custom');
                if (container && container.firstChild) {
                    container.insertBefore(messageDiv, container.firstChild);
                }
            }
        }
        
        // Function to show all cards again
        function showAllCards() {
            const hiddenCards = document.querySelectorAll('.card.duplicate-hidden');
            hiddenCards.forEach(card => {
                card.style.display = 'block';
                card.classList.remove('duplicate-hidden');
            });
            
            // Remove the alert message
            const alertDiv = document.querySelector('.alert-info');
            if (alertDiv) {
                alertDiv.remove();
            }
            
            console.log(`‚úÖ Restored ${hiddenCards.length} hidden cards`);
        }
        
        // Initialize page - enable state management if connection is available
        if (document && document.addEventListener) {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('üîÑ DOM ready, initializing page...');
                
                // Check if duplicates should be hidden after recent Fabric sync
                checkAndHideDuplicates();
                
                // Load saved connection state
                try {
                    loadFabricConnectionState();
                } catch (error) {
                console.error('‚ùå Error loading fabric connection state:', error);
            }
            
            // Setup state preservation
            try {
                setupStatePreservation();
            } catch (error) {
                console.error('‚ùå Error setting up state preservation:', error);
            }
            
            // Check if state management should be enabled immediately
            const sessionToken = '{{ stored_token or "" }}';
            const savedConnected = localStorage.getItem('fabricConnected');
            const savedDataSynced = localStorage.getItem('fabricDataSynced');
            const lastConnectionTime = localStorage.getItem('fabricConnectionTime');
            
            // Check if we have a valid session token
            if (sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None') {
                console.log('üîë Valid session token found - enabling state management immediately');
                stateManagementEnabled = true;
                fabricConnected = true;
                // Update localStorage with current connection
                localStorage.setItem('fabricConnected', 'true');
                localStorage.setItem('fabricConnectionTime', Date.now().toString());
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            }
            // Check if we have recent localStorage connection (within last 30 minutes)
            else if (savedConnected === 'true' && savedDataSynced === 'true' && lastConnectionTime) {
                const connectionAge = Date.now() - parseInt(lastConnectionTime);
                const thirtyMinutes = 30 * 60 * 1000; // 30 minutes in milliseconds
                
                if (connectionAge < thirtyMinutes) {
                    console.log('üîó Recent Fabric connection found - enabling state management from localStorage');
                    stateManagementEnabled = true;
                    fabricConnected = true;
                    if (document.body && document.body.classList) {
                        document.body.classList.remove('state-management-disabled');
                    }
                } else {
                    console.log('üîí Stale connection found - clearing and disabling state management');
                    // Clear stale connection state
                    localStorage.removeItem('fabricConnected');
                    localStorage.removeItem('fabricStateEnabled');
                    localStorage.removeItem('fabricDataSynced');
                    localStorage.removeItem('fabricConnectionTime');
                    
                    stateManagementEnabled = false;
                    fabricConnected = false;
                    if (document.body && document.body.classList) {
                        document.body.classList.add('state-management-disabled');
                    }
                }
            } else {
                console.log('üîí No connection found - state management disabled');
                stateManagementEnabled = false;
                fabricConnected = false;
                if (document.body && document.body.classList) {
                    document.body.classList.add('state-management-disabled');
                }
            }
            
            // Check if URL indicates fabric connection (from server-side state loading)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('fabric_connected') === 'true') {
                console.log('üîó URL indicates Fabric connection - enabling state management');
                stateManagementEnabled = true;
                fabricConnected = true;
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            }
            
            // If we have a valid connection, try to restore state data from localStorage
            if (stateManagementEnabled && fabricConnected) {
                const savedStateData = localStorage.getItem('fabricStateData');
                const savedStateTime = localStorage.getItem('fabricStateDataTime');
                
                if (savedStateData && savedStateTime) {
                    const stateAge = Date.now() - parseInt(savedStateTime);
                    const thirtyMinutes = 30 * 60 * 1000;
                    
                    if (stateAge < thirtyMinutes) {
                        try {
                            const stateData = JSON.parse(savedStateData);
                            console.log(`üîÑ Restoring ${Object.keys(stateData).length} state records from localStorage`);
                            
                            // Store globally and apply to page
                            window.fabricStateData = stateData;
                            
                            // Apply state data after DOM is fully ready
                            setTimeout(() => {
                                // Check if elements are available before applying
                                const feedbackElements = document.querySelectorAll('[data-feedback-id]');
                                console.log(`üîç DOM Check: Found ${feedbackElements.length} feedback elements before applying state data`);
                                
                                if (feedbackElements.length > 0) {
                                    updateFeedbackWithSQLData(stateData);
                                    console.log('‚úÖ State data restored and applied after page reload');
                                } else {
                                    console.log('‚ö†Ô∏è No feedback elements found yet, retrying state restoration...');
                                    // Retry after a longer delay
                                    setTimeout(() => {
                                        const retryElements = document.querySelectorAll('[data-feedback-id]');
                                        console.log(`üîç Retry Check: Found ${retryElements.length} feedback elements`);
                                        if (retryElements.length > 0) {
                                            updateFeedbackWithSQLData(stateData);
                                            console.log('‚úÖ State data restored after retry');
                                        } else {
                                            console.log('‚ö†Ô∏è Still no feedback elements - state restoration skipped (might be filtered out)');
                                        }
                                    }, 500);
                                }
                            }, 250);
                            
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Could not restore state data from localStorage:', error);
                            localStorage.removeItem('fabricStateData');
                            localStorage.removeItem('fabricStateDataTime');
                        }
                    } else {
                        console.log('üîí State data is stale, clearing localStorage');
                        localStorage.removeItem('fabricStateData');
                        localStorage.removeItem('fabricStateDataTime');
                    }
                }
            }
            
            // Add test button for debugging (remove in production)
            if (window.location.hash === '#debug') {
                try {
                    const testBtn = document.createElement('button');
                    testBtn.textContent = 'Test State Loading';
                    testBtn.className = 'btn btn-warning btn-sm ms-2';
                    testBtn.onclick = testStateLoading;
                    const container = document.querySelector('.container-custom p');
                    if (container) {
                        container.appendChild(testBtn);
                    }
                } catch (error) {
                    console.error('‚ùå Error adding debug button:', error);
                }
            }
            
            console.log('‚úÖ Page initialization complete - State management:', stateManagementEnabled ? 'ENABLED' : 'DISABLED');
        });
        }
        
        // Global dropdown for state selection
        let globalDropdown = null;
        let currentFeedbackElement = null;
        
        // Create global dropdown on page load
        function createGlobalDropdown() {
            if (globalDropdown) return;
            
            globalDropdown = document.createElement('div');
            globalDropdown.className = 'global-state-dropdown';
            globalDropdown.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                z-index: 999999;
                min-width: 120px;
                display: none;
                padding: 4px 0;
            `;
            
            globalDropdown.innerHTML = `
                <div class="state-option" data-state="NEW" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">üÜï New</div>
                <div class="state-option" data-state="TRIAGED" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">üîç Triaged</div>
                <div class="state-option" data-state="CLOSED" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">‚úÖ Closed</div>
                <div class="state-option" data-state="IRRELEVANT" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">‚ùå Irrelevant</div>
            `;
            
            // Add hover effects
            globalDropdown.querySelectorAll('.state-option').forEach(option => {
                option.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#f8f9fa';
                });
                option.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = '';
                });
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const newState = this.getAttribute('data-state');
                    const currentState = currentFeedbackElement.getAttribute('data-current-state');
                    const feedbackId = currentFeedbackElement.getAttribute('data-feedback-id');
                    
                    if (newState !== currentState) {
                        updateState(feedbackId, newState, currentFeedbackElement);
                    }
                    
                    // Hide dropdown
                    globalDropdown.style.display = 'none';
                });
            });
            
            document.body.appendChild(globalDropdown);
        }
        
        // Single dropdown toggle function
        function toggleStateDropdown(element, event) {
            // Check if state management is enabled
            const sessionToken = '{{ stored_token or "" }}';
            const savedConnected = localStorage.getItem('fabricConnected');
            const savedDataSynced = localStorage.getItem('fabricDataSynced');
            
            const isEnabled = stateManagementEnabled ||
                             (sessionToken && sessionToken.trim() !== '') ||
                             (savedConnected === 'true' && savedDataSynced === 'true');
            
            if (!isEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            // Enable state management if not already enabled
            if (!stateManagementEnabled) {
                stateManagementEnabled = true;
                document.body.classList.remove('state-management-disabled');
            }
            
            // Prevent event bubbling
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Create global dropdown if not exists
            createGlobalDropdown();
            
            // Store current element
            currentFeedbackElement = element;
            
            // Position dropdown below the clicked badge (fixed positioning relative to viewport)
            const rect = element.getBoundingClientRect();
            globalDropdown.style.top = (rect.bottom + 2) + 'px';
            globalDropdown.style.left = rect.left + 'px';
            globalDropdown.style.display = 'block';
            
            console.log('‚úÖ Global dropdown positioned at:', globalDropdown.style.top, globalDropdown.style.left);
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            if (globalDropdown && !event.target.closest('.state-badge') && !event.target.closest('.global-state-dropdown')) {
                globalDropdown.style.display = 'none';
            }
        });
        
        // Legacy function for compatibility
        function oldToggleStateDropdown(element) {
            // Check if state management is enabled
            if (!stateManagementEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            // Close all other dropdowns
            document.querySelectorAll('.state-dropdown').forEach(d => {
                if (d && d.classList) {
                    d.classList.remove('show');
                }
            });
            document.querySelectorAll('.actions-menu').forEach(m => {
                if (m && m.classList) {
                    m.classList.remove('show');
                }
            });
            document.querySelectorAll('.card').forEach(c => {
                if (c && c.classList) {
                    c.classList.remove('dropdown-open');
                }
            });
            
            const feedbackId = element.getAttribute('data-feedback-id');
            const dropdown = document.querySelector(`.state-dropdown[data-feedback-id="${feedbackId}"]`);
            const card = element.closest('.card');
            
            if (dropdown && dropdown.classList) {
                dropdown.classList.toggle('show');
                
                // Add dropdown-open class to prevent card hover effects
                if (dropdown.classList.contains('show') && card && card.classList) {
                    card.classList.add('dropdown-open');
                }
            }
            
            // Add click handlers to state options
            if (dropdown) {
                dropdown.querySelectorAll('.state-option').forEach(option => {
                    option.onclick = function() {
                        const newState = this.getAttribute('data-state');
                        const currentState = element.getAttribute('data-current-state');
                        
                        if (newState !== currentState) {
                            updateState(feedbackId, newState, element);
                        }
                        if (dropdown && dropdown.classList) {
                            dropdown.classList.remove('show');
                        }
                        if (card && card.classList) {
                            card.classList.remove('dropdown-open');
                        }
                        
                        // Reconnect observer after state change is complete
                        setTimeout(() => {
                            if (window.stateObserver) {
                                window.stateObserver.observe(document.body, {
                                    childList: true,
                                    subtree: false
                                });
                            }
                        }, 500);
                    };
                });
            }
        }
        
        // Toggle actions menu
        function toggleActionsMenu(element) {
            if (!stateManagementEnabled || !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Close all other dropdowns
            document.querySelectorAll('.state-dropdown').forEach(d => {
                if (d && d.classList) {
                    d.classList.remove('show');
                }
            });
            document.querySelectorAll('.actions-menu').forEach(m => {
                if (m && m.classList) {
                    m.classList.remove('show');
                }
            });
            
            const menu = element.nextElementSibling;
            if (menu && menu.classList) {
                menu.classList.toggle('show');
            }
        }
        
        // Update feedback state (cached)
        function updateState(feedbackId, newState, stateElement) {
            if (!stateManagementEnabled || !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Update UI immediately (no prompt)
            const stateNames = {
                'NEW': 'üÜï New',
                'TRIAGED': 'üîç Triaged',
                'CLOSED': '‚úÖ Closed',
                'IRRELEVANT': '‚ùå Irrelevant'
            };
            
            stateElement.textContent = stateNames[newState] || newState;
            stateElement.className = `state-badge state-${newState.toLowerCase()}`;
            stateElement.setAttribute('data-current-state', newState);
            
            // Immediately sync to SQL database
            const changeData = {
                feedback_id: feedbackId,
                state: newState
            };
            
            console.log(`üîÑ State changed: ${feedbackId} ‚Üí ${newState} (syncing to SQL)`);
            
            // Call new SQL update API
            fetch('/api/feedback/state/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(changeData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log(`‚úÖ Successfully updated state for ${feedbackId} in SQL database`);
                } else {
                    console.error(`‚ùå Failed to update state for ${feedbackId}:`, data.message);
                    alert('Failed to update state: ' + data.message);
                }
            })
            .catch(error => {
                console.error(`‚ùå Error updating state for ${feedbackId}:`, error);
                alert('Error updating state: ' + error.message);
            });
        }
        
        // Update notes display in UI
        function updateNotesDisplay(feedbackId, notes) {
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.card-body') : null;
            if (card) {
                let notesDisplay = card.querySelector('.notes-display');
                if (!notesDisplay) {
                    notesDisplay = document.createElement('div');
                    notesDisplay.className = 'notes-display';
                    // Insert after state management section
                    const stateSection = card.querySelector('.category-info');
                    if (stateSection) {
                        stateSection.parentNode.insertBefore(notesDisplay, stateSection.nextSibling);
                    }
                }
                notesDisplay.innerHTML = `üìù ${notes}`;
            }
        }
        
        // Update domain with proper dropdown
        function updateDomain(feedbackId, currentDomain) {
            if (!stateManagementEnabled || !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Create domain selection modal
            showDomainSelectionModal(feedbackId, currentDomain);
        }
        
        // Show domain selection modal
        function showDomainSelectionModal(feedbackId, currentDomain) {
            const domains = ['GOVERNANCE', 'USER_EXPERIENCE', 'AUTHENTICATION', 'PERFORMANCE', 'INTEGRATION', 'ANALYTICS'];
            const domainNames = {
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            // Create modal HTML
            const modalHtml = `
                <div id="domainModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; border-radius: 8px; padding: 20px; max-width: 400px; width: 90%;">
                        <h5>Update Domain for Feedback</h5>
                        <p class="text-muted">Select a new domain for this feedback:</p>
                        <div class="mb-3">
                            <label class="form-label">Domain:</label>
                            <select id="domainSelect" class="form-select">
                                ${domains.map(domain =>
                                    `<option value="${domain}" ${domain === currentDomain ? 'selected' : ''}>${domainNames[domain]}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="d-flex justify-content-end gap-2">
                            <button type="button" class="btn btn-secondary" onclick="closeDomainModal()">Cancel</button>
                            <button type="button" class="btn btn-primary" onclick="saveDomainChange('${feedbackId}'); return false;">Update Domain</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        // Close domain modal
        function closeDomainModal() {
            const modal = document.getElementById('domainModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Save domain change from modal with direct SQL update
        function saveDomainChange(feedbackId) {
            const selectedDomain = document.getElementById('domainSelect').value;
            const domainNames = {
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${selectedDomain} (${domainNames[selectedDomain]})`);
            
            // Close modal immediately for better UX
            closeDomainModal();
            
            // Update domain directly in SQL database
            fetch('/api/update_domain_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_domain: selectedDomain
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Domain updated successfully: ${feedbackId} ‚Üí ${selectedDomain}`);
                    
                    // Update domain display in UI
                    updateDomainDisplayFromCache(feedbackId, selectedDomain);
                    
                    // Show success message
                    showMessage(`Domain updated to ${domainNames[selectedDomain]}`, 'success');
                } else {
                    console.error(`‚ùå Domain update failed: ${data.message}`);
                    showMessage(`Failed to update domain: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error(`‚ùå Domain update error:`, error);
                showMessage('Error updating domain. Please try again.', 'error');
            });
            
            return false;
        }
        
        // Load data from Fabric SQL when no feedback is available
        function loadFromFabricSQL() {
            if (confirm('Load existing feedback data from Fabric SQL database?')) {
                window.location.href = '/api/fabric/sync';
            }
        }
        
        // Add click handler to close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('domainModal');
            if (modal && event.target === modal) {
                closeDomainModal();
            }
        });
        
        // Multi-select filter functions
        function toggleFilterAll(filterType) {
            const allCheckbox = document.getElementById(filterType + '_all');
            const filterCheckboxes = document.querySelectorAll(`input[data-filter="${filterType}"]`);
            
            if (allCheckbox.checked) {
                // Uncheck all specific filters when "All" is selected
                filterCheckboxes.forEach(cb => cb.checked = false);
            }
        }
        
        function applyMultiSelectFilters() {
            const params = new URLSearchParams();
            
            // Get current non-filter parameters
            const currentParams = new URLSearchParams(window.location.search);
            if (currentParams.get('sort')) params.set('sort', currentParams.get('sort'));
            if (currentParams.get('show_repeating') === 'true') params.set('show_repeating', 'true');
            if (currentParams.get('show_only_stored') === 'true') params.set('show_only_stored', 'true');
            
            // Add fabric connection indicator if user is connected
            if (typeof fabricConnected !== 'undefined' && fabricConnected && typeof stateManagementEnabled !== 'undefined' && stateManagementEnabled) {
                params.set('fabric_connected', 'true');
            }
            
            // Also check if we have state data loaded (indicates connection)
            if (typeof window !== 'undefined' && window.fabricStateData && Object.keys(window.fabricStateData).length > 0) {
                params.set('fabric_connected', 'true');
            }
            
            // Collect selected filters
            const filterTypes = ['audience', 'priority', 'state', 'source', 'domain', 'sentiment', 'enhanced_category'];
            
            filterTypes.forEach(filterType => {
                const allCheckbox = document.getElementById(filterType + '_all');
                
                if (!allCheckbox || !allCheckbox.checked) {
                    const selected = [];
                    const checkboxes = document.querySelectorAll(`input[data-filter="${filterType}"]:checked`);
                    checkboxes.forEach(cb => selected.push(cb.value));
                    
                    if (selected.length > 0) {
                        params.set(filterType, selected.join(','));
                    }
                }
            });
            
            // Navigate to filtered URL
            const newUrl = window.location.pathname + '?' + params.toString();
            window.location.href = newUrl;
        }
        
        // Update dropdown button text when checkboxes change
        document.addEventListener('change', function(event) {
            if (event.target.classList.contains('filter-checkbox')) {
                const filterType = event.target.getAttribute('data-filter');
                updateDropdownButtonText(filterType);
                
                // Uncheck "All" when specific filters are selected
                const allCheckbox = document.getElementById(filterType + '_all');
                if (allCheckbox && event.target.checked) {
                    allCheckbox.checked = false;
                }
            }
        });
        
        function updateDropdownButtonText(filterType) {
            const button = document.getElementById(filterType + 'Filter');
            const selected = document.querySelectorAll(`input[data-filter="${filterType}"]:checked`);
            const allCheckbox = document.getElementById(filterType + '_all');
            
            if (button) {
                if (allCheckbox && allCheckbox.checked) {
                    button.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
                } else if (selected.length === 0) {
                    button.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
                } else {
                    button.textContent = `${selected.length} ${filterType}(s) selected`;
                }
            }
        }
        
        // Show message to user
        function showMessage(message, type = 'info') {
            // Create message element
            const messageEl = document.createElement('div');
            messageEl.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show`;
            messageEl.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            messageEl.innerHTML = `
                ${message}
                <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
            `;
            
            // Add to page
            document.body.appendChild(messageEl);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (messageEl.parentElement) {
                    messageEl.remove();
                }
            }, 3000);
        }
        
        // Update audience function
        function updateAudience(feedbackId, currentAudience) {
            if (!stateManagementEnabled) {
                alert('Please connect to Fabric first to enable audience updates.');
                return;
            }
            
            // Create audience selection modal
            const modal = document.createElement('div');
            modal.id = 'audienceModal';
            modal.className = 'modal fade show';
            modal.style.cssText = 'display: block; background: rgba(0,0,0,0.5); position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1050;';
            
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Update Audience</h5>
                            <button type="button" class="btn-close" onclick="closeAudienceModal()"></button>
                        </div>
                        <div class="modal-body">
                            <p><strong>Current:</strong> ${currentAudience || 'Not set'}</p>
                            <div class="mb-3">
                                <label for="audienceSelect" class="form-label">Select new audience:</label>
                                <select class="form-select" id="audienceSelect">
                                    <option value="Developer" ${currentAudience === 'Developer' ? 'selected' : ''}>üõ†Ô∏è Developer</option>
                                    <option value="Customer" ${currentAudience === 'Customer' ? 'selected' : ''}>üë§ Customer</option>
                                    <option value="ISV" ${currentAudience === 'ISV' ? 'selected' : ''}>üè¢ ISV</option>
                                </select>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="closeAudienceModal()">Cancel</button>
                            <button type="button" class="btn btn-primary" onclick="saveAudienceChange('${feedbackId}')">Update Audience</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Close audience modal
        function closeAudienceModal() {
            const modal = document.getElementById('audienceModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Save audience change from modal with direct SQL update
        function saveAudienceChange(feedbackId) {
            const selectedAudience = document.getElementById('audienceSelect').value;
            
            console.log(`üë• Audience changing: ${feedbackId} ‚Üí ${selectedAudience}`);
            
            // Close modal immediately for better UX
            closeAudienceModal();
            
            // Update audience directly in SQL database
            fetch('/api/update_audience_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_audience: selectedAudience
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Audience updated successfully: ${feedbackId} ‚Üí ${selectedAudience}`);
                    
                    // Update audience display in UI
                    const audienceElement = document.querySelector(`[data-feedback-id="${feedbackId}"] .audience-display`);
                    if (audienceElement) {
                        audienceElement.textContent = selectedAudience;
                    }
                    
                    // Show success message
                    showMessage(`Audience updated to ${selectedAudience}`, 'success');
                } else {
                    console.error(`‚ùå Audience update failed: ${data.message}`);
                    showMessage(`Failed to update audience: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error(`‚ùå Audience update error:`, error);
                showMessage('Error updating audience. Please try again.', 'error');
            });
            
            return false;
        }
        
        // Update notes
        function updateNotes(feedbackId, currentNotes) {
            if (!stateManagementEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            const notes = prompt('Enter notes for this feedback:', currentNotes) || '';
            
            // Cache the notes change
// Update domain display in UI
        function updateDomainDisplay(feedbackId, domainName) {
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.card-body') : null;
            if (card) {
                const domainSection = card.querySelector('.category-info:has(.domain-badge)');
                if (domainSection) {
                    const domainBadge = domainSection.querySelector('.domain-badge');
                    if (domainBadge) {
                        domainBadge.textContent = domainName;
                    }
                }
            }
        }
            cacheStateChange(feedbackId, { notes: notes });
            
            // Update notes display in UI
            updateNotesDisplay(feedbackId, notes);
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.state-badge') && !event.target.closest('.state-dropdown') &&
                !event.target.closest('.card-actions')) {
                document.querySelectorAll('.state-dropdown').forEach(d => d.classList.remove('show'));
                document.querySelectorAll('.actions-menu').forEach(m => m.classList.remove('show'));
                document.querySelectorAll('.card').forEach(c => c.classList.remove('dropdown-open'));
            }
        });
        
        // Initialize on page load with session token check
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîë DOMContentLoaded event fired');
            
            // Check for session token first before disabling state management
            const sessionToken = '{{ stored_token or "" }}';
            
            if (sessionToken && sessionToken.trim() !== '') {
                console.log('üîë DOMContentLoaded: Session token found, enabling state management');
                stateManagementEnabled = true;
                bearerToken = sessionToken;
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
                const tokenBanner = document.getElementById('tokenBanner');
                if (tokenBanner && tokenBanner.classList) {
                    tokenBanner.classList.add('hidden');
                }
            } else {
                console.log('üîë DOMContentLoaded: No session token, ensuring proper disabled state');
                stateManagementEnabled = false;
                // Don't add disabled class if it might already be set in the session logic above
            }
        });
        
        // Fabric Auth and Collection Progress functionality for feedback viewer
        // Declare variables in global scope to avoid hoisting issues
        var fabricAuthDrawer = null;
        var collectionProgressDrawer = null;
        var fabricToken = null;
        var fabricConnectionStatus = 'disconnected';

        // Initialize drawers on page load using new badge state manager
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîß FEEDBACK: DOMContentLoaded - using BadgeStateManager');
            
            // Initialize drawer components
            initializeDrawers();
            
            // Use the new badge state manager for all badge operations
            // It will automatically sync badges on page load
            
            // Watch for URL changes (filtering) and resync badges
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            
            history.pushState = function() {
                originalPushState.apply(history, arguments);
                console.log('üîß FEEDBACK: URL changed (pushState) - refreshing all state...');
                setTimeout(() => {
                    if (window.badgeStateManager) {
                        window.badgeStateManager.forceRefresh();
                    }
                    // CRITICAL: Reapply cached changes after filtering
                    console.log('üîß FEEDBACK: Reapplying cached changes after filter...');
                    applyCachedChangesToUI();
                    
                    // Re-enable sync button after filtering if state management is enabled
                    if (stateManagementEnabled) {
                        updateSyncButton();
                    }
                }, 200); // Increased delay to ensure DOM is updated
            };
            
            history.replaceState = function() {
                originalReplaceState.apply(history, arguments);
                console.log('üîß FEEDBACK: URL changed (replaceState) - refreshing all state...');
                setTimeout(() => {
                    if (window.badgeStateManager) {
                        window.badgeStateManager.forceRefresh();
                    }
                    // CRITICAL: Reapply cached changes after filtering
                    console.log('üîß FEEDBACK: Reapplying cached changes after filter...');
                    applyCachedChangesToUI();
                    
                    // Re-enable sync button after filtering if state management is enabled
                    if (stateManagementEnabled) {
                        updateSyncButton();
                    }
                }, 200); // Increased delay to ensure DOM is updated
            };
        });
        
        // Separate function to initialize drawer components
        function initializeDrawers() {
            console.log('üîß FEEDBACK: Initializing drawer components...');
            
            // Initialize Fabric Auth drawer
            const fabricAuthElement = document.getElementById('fabricAuthDrawer');
            if (fabricAuthElement) {
                if (typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        fabricAuthDrawer = new bootstrap.Offcanvas(fabricAuthElement);
                        console.log('‚úÖ FEEDBACK: Fabric Auth drawer initialized');
                    } catch (error) {
                        console.error('‚ùå FEEDBACK: Error initializing Fabric Auth drawer:', error);
                        fabricAuthDrawer = null;
                    }
                } else {
                    console.error('‚ùå FEEDBACK: Bootstrap not available');
                    fabricAuthDrawer = null;
                }
            }
            
            // Initialize Collection Progress drawer
            const collectionProgressElement = document.getElementById('collectionProgressDrawer');
            if (collectionProgressElement) {
                if (typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        collectionProgressDrawer = new bootstrap.Offcanvas(collectionProgressElement);
                        console.log('‚úÖ FEEDBACK: Collection Progress drawer initialized');
                    } catch (error) {
                        console.error('‚ùå FEEDBACK: Error initializing Collection Progress drawer:', error);
                        collectionProgressDrawer = null;
                    }
                } else {
                    console.error('‚ùå FEEDBACK: Bootstrap not available');
                    collectionProgressDrawer = null;
                }
            }
        }

        // Sync collection progress status from home page
        function syncCollectionProgressStatus() {
            console.log('üîß DEBUG: syncCollectionProgressStatus called');
            // Check for ongoing collection operation
            fetch('/api/collection_status')
                .then(response => {
                    console.log('üîß DEBUG: Collection status response:', response);
                    return response.json();
                })
                .then(data => {
                    console.log('üîß DEBUG: Collection status data:', data);
                    if (data.status === 'running') {
                        updateProgressBadge('Running', 'warning');
                    } else if (data.status === 'completed') {
                        updateProgressBadge('Completed', 'success');
                    } else {
                        updateProgressBadge('Ready', 'secondary');
                    }
                })
                .catch(error => {
                    console.error('üîß DEBUG: Collection status check failed:', error);
                    updateProgressBadge('Ready', 'secondary');
                });
        }

        // Update progress badge
        function updateProgressBadge(text, type) {
            console.log('üîß DEBUG: updateProgressBadge called with:', text, type);
            const badge = document.getElementById('progressBadge');
            console.log('üîß DEBUG: Progress badge element found:', badge);
            if (badge) {
                badge.textContent = text;
                badge.className = `badge bg-${type} ms-1`;
                console.log('üîß DEBUG: Progress badge updated successfully to:', text);
            } else {
                console.error('üîß DEBUG: Progress badge element not found!');
            }
        }

        // Fabric Auth functions (copied from index.html)
        function toggleFabricAuth() {
            console.log('üîß DEBUG: toggleFabricAuth called');
            console.log('üîß DEBUG: fabricAuthDrawer:', fabricAuthDrawer);
            
            // Try to initialize if not already done
            if (!fabricAuthDrawer || fabricAuthDrawer === undefined) {
                console.log('üîß DEBUG: Attempting to reinitialize Fabric Auth drawer...');
                const fabricAuthElement = document.getElementById('fabricAuthDrawer');
                if (fabricAuthElement && typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        fabricAuthDrawer = new bootstrap.Offcanvas(fabricAuthElement);
                        console.log('üîß DEBUG: Fabric Auth drawer reinitialized:', fabricAuthDrawer);
                    } catch (error) {
                        console.error('üîß DEBUG: Failed to reinitialize Fabric Auth drawer:', error);
                        return;
                    }
                } else {
                    console.error('üîß DEBUG: Cannot reinitialize Fabric Auth - element or Bootstrap missing');
                    console.error('üîß DEBUG: Element:', fabricAuthElement);
                    console.error('üîß DEBUG: Bootstrap available:', typeof bootstrap !== 'undefined');
                    return;
                }
            }
            
            if (fabricAuthDrawer) {
                console.log('üîß DEBUG: Attempting to show Fabric Auth drawer...');
                try {
                    fabricAuthDrawer.show();
                    console.log('üîß DEBUG: Fabric Auth drawer show() called successfully');
                } catch (error) {
                    console.error('üîß DEBUG: Error showing Fabric Auth drawer:', error);
                }
            } else {
                console.error('üîß DEBUG: fabricAuthDrawer is still null or undefined');
            }
        }

        function hideFabricAuth() {
            console.log('üîß DEBUG: hideFabricAuth called');
            if (fabricAuthDrawer) {
                fabricAuthDrawer.hide();
            }
        }

        function checkStoredFabricToken() {
            console.log('üîß DEBUG: checkStoredFabricToken called');
            fetch('/api/fabric/token/status')
                .then(response => {
                    console.log('üîß DEBUG: Fabric token status response:', response);
                    return response.json();
                })
                .then(data => {
                    console.log('üîß DEBUG: Fabric token status data:', data);
                    if (data.has_token) {
                        console.log('üîß DEBUG: Restoring full Fabric Auth drawer state...');
                        
                        // Update main UI status and badge
                        updateFabricAuthUI('connected', 'Token stored in session');
                        
                        // Restore all drawer internal elements
                        const currentTokenInfo = document.getElementById('currentTokenInfo');
                        const updateTokenBtn = document.getElementById('updateTokenBtn');
                        const clearTokenBtn = document.getElementById('clearTokenBtn');
                        const lastValidatedTime = document.getElementById('lastValidatedTime');
                        const tokenStatusBadge = document.getElementById('tokenStatusBadge');
                        
                        if (currentTokenInfo) {
                            currentTokenInfo.style.display = 'block';
                            console.log('üîß DEBUG: Restored currentTokenInfo visibility');
                        }
                        if (updateTokenBtn) {
                            updateTokenBtn.style.display = 'block';
                            console.log('üîß DEBUG: Restored updateTokenBtn visibility');
                        }
                        if (clearTokenBtn) {
                            clearTokenBtn.style.display = 'block';
                            console.log('üîß DEBUG: Restored clearTokenBtn visibility');
                        }
                        if (lastValidatedTime) {
                            lastValidatedTime.textContent = data.last_validated || 'Unknown';
                            console.log('üîß DEBUG: Restored lastValidatedTime:', data.last_validated || 'Unknown');
                        }
                        if (tokenStatusBadge) {
                            tokenStatusBadge.className = 'badge bg-success';
                            tokenStatusBadge.textContent = 'Valid';
                            console.log('üîß DEBUG: Restored tokenStatusBadge to Valid');
                        }
                        
                        // Restore token reference
                        fabricToken = 'stored';
                        
                        // Enable state management for feedback page
                        bearerToken = 'stored';
                        stateManagementEnabled = true;
                        if (document.body) {
                            document.body.classList.remove('state-management-disabled');
                        }
                        
                        // Update sync button visibility since state management is now enabled
                        updateSyncButton();
                        
                        console.log('üîß DEBUG: Enabled state management and updated sync button');
                        
                        console.log('üîß DEBUG: Full Fabric Auth drawer state restored successfully');
                    } else {
                        console.log('üîß DEBUG: Restoring disconnected drawer state...');
                        updateFabricAuthUI('disconnected', 'No token stored');
                        
                        // Hide all token management elements
                        const currentTokenInfo = document.getElementById('currentTokenInfo');
                        const updateTokenBtn = document.getElementById('updateTokenBtn');
                        const clearTokenBtn = document.getElementById('clearTokenBtn');
                        
                        if (currentTokenInfo) {
                            currentTokenInfo.style.display = 'none';
                        }
                        if (updateTokenBtn) {
                            updateTokenBtn.style.display = 'none';
                        }
                        if (clearTokenBtn) {
                            clearTokenBtn.style.display = 'none';
                        }
                        
                        // Reset state management
                        fabricToken = null;
                        if (typeof bearerToken !== 'undefined') {
                            bearerToken = null;
                        }
                        if (typeof stateManagementEnabled !== 'undefined') {
                            stateManagementEnabled = false;
                        }
                        
                        console.log('üîß DEBUG: Disconnected drawer state restored');
                    }
                })
                .catch(error => {
                    console.error('üîß DEBUG: Error checking fabric token status:', error);
                    updateFabricAuthUI('error', 'Error checking token status');
                });
        }

        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('fabricAuthToken');
            const visibilityIcon = document.getElementById('tokenVisibilityIcon');
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                visibilityIcon.className = 'bi bi-eye-slash';
            } else {
                tokenInput.type = 'password';
                visibilityIcon.className = 'bi bi-eye';
            }
        }

        function validateFabricToken() {
            const token = document.getElementById('fabricAuthToken').value.trim();
            if (!token) {
                alert('Please enter a Fabric bearer token');
                return;
            }

            updateFabricAuthUI('validating', 'Validating token...');
            addFabricLog('üîÑ Starting fast token validation...');
            
            // Fast validation - if Livy accepts session start, token is valid
            fetch('/api/fabric/token/validate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({token: token})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    fabricToken = token;
                    addFabricLog('‚úÖ Token validation successful');
                    addFabricLog('üöÄ Livy session starting in background');
                    addFabricLog('üìù Token stored in session - state management enabled');
                    
                    if (data.session_id) {
                        addFabricLog(`üîó Session ID: ${data.session_id}`);
                    }
                    
                    // Update badge using BadgeStateManager
                    if (window.badgeStateManager) {
                        window.badgeStateManager.setFabricAuthState('connected', 'Connected', data.session_id);
                    }
                    
                    // Update drawer UI
                    updateFabricAuthUI('connected', 'Token validated - Livy session starting');
                    
                    // Show token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'block';
                    document.getElementById('updateTokenBtn').style.display = 'block';
                    document.getElementById('clearTokenBtn').style.display = 'block';
                    document.getElementById('lastValidatedTime').textContent = new Date().toLocaleString();
                    
                    // Clear token input for security
                    document.getElementById('fabricAuthToken').value = '';
                    
                    // Enable state management in the feedback viewer
                    bearerToken = token;
                    stateManagementEnabled = true;
                    document.body.classList.remove('state-management-disabled');
                    
                } else {
                    updateFabricAuthUI('error', data.message || 'Token validation failed');
                    addFabricLog('‚ùå Token validation failed: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error validating token:', error);
                updateFabricAuthUI('error', 'Error validating token');
                addFabricLog('‚ùå Validation error: ' + error.message);
            });
        }

        function updateFabricToken() {
            document.getElementById('fabricAuthToken').value = '';
            document.getElementById('fabricAuthToken').focus();
            document.getElementById('currentTokenInfo').style.display = 'none';
            document.getElementById('updateTokenBtn').style.display = 'none';
            document.getElementById('clearTokenBtn').style.display = 'none';
            updateFabricAuthUI('disconnected', 'Ready to enter new token');
            addFabricLog('üîÑ Ready to update token');
        }

        function clearFabricToken() {
            if (!confirm('Are you sure you want to clear the stored Fabric token?')) {
                return;
            }

            fetch('/api/fabric/token/clear', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    fabricToken = null;
                    updateFabricAuthUI('disconnected', 'Token cleared');
                    addFabricLog('üóëÔ∏è Token cleared from session');
                    
                    // Hide token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'none';
                    document.getElementById('updateTokenBtn').style.display = 'none';
                    document.getElementById('clearTokenBtn').style.display = 'none';
                    
                    // Disable state management
                    bearerToken = null;
                    stateManagementEnabled = false;
                    if (document.body) {
                        document.body.classList.add('state-management-disabled');
                    }
                    
                } else {
                    addFabricLog('‚ùå Error clearing token: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error clearing token:', error);
                addFabricLog('‚ùå Clear error: ' + error.message);
            });
        }

        function updateFabricAuthUI(status, message) {
            console.log('üîß DEBUG: updateFabricAuthUI called with:', status, message);
            const statusBadge = document.getElementById('fabricConnectionStatus');
            const authBadge = document.getElementById('fabricAuthBadge');
            const statusAlert = document.getElementById('fabricStatusAlert');
            const statusText = document.getElementById('fabricStatusText');
            const spinner = document.getElementById('fabricAuthSpinner');
            
            console.log('üîß DEBUG: Fabric Auth badge element:', authBadge);
            console.log('üîß DEBUG: Status badge element:', statusBadge);
            
            if (statusText) statusText.textContent = message;
            if (statusAlert) statusAlert.style.display = 'block';
            
            switch (status) {
                case 'connected':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-success';
                        statusBadge.textContent = 'Connected';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-success ms-1';
                        authBadge.textContent = 'Connected';
                        console.log('üîß DEBUG: Fabric auth badge updated to Connected');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-success';
                    if (spinner) spinner.style.display = 'none';
                    break;
                case 'validating':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-warning';
                        statusBadge.textContent = 'Validating';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-warning ms-1';
                        authBadge.textContent = 'Validating';
                        console.log('üîß DEBUG: Fabric auth badge updated to Validating');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-warning';
                    if (spinner) spinner.style.display = 'block';
                    break;
                case 'error':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-danger';
                        statusBadge.textContent = 'Error';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-danger ms-1';
                        authBadge.textContent = 'Error';
                        console.log('üîß DEBUG: Fabric auth badge updated to Error');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-danger';
                    if (spinner) spinner.style.display = 'none';
                    break;
                default: // disconnected
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-secondary';
                        statusBadge.textContent = 'Not Connected';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-secondary ms-1';
                        authBadge.textContent = 'Not Connected';
                        console.log('üîß DEBUG: Fabric auth badge updated to Not Connected');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-secondary';
                    if (spinner) spinner.style.display = 'none';
                    break;
            }
            
            fabricConnectionStatus = status;
        }

        function addFabricLog(message) {
            const log = document.getElementById('fabricLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            log.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('fabricLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        function clearFabricLog() {
            document.getElementById('fabricLog').innerHTML = '';
        }

        // Collection Progress functions (placeholder)
        function toggleCollectionProgress() {
            console.log('üîß DEBUG: toggleCollectionProgress called');
            console.log('üîß DEBUG: collectionProgressDrawer:', collectionProgressDrawer);
            
            // Try to initialize if not already done
            if (!collectionProgressDrawer || collectionProgressDrawer === undefined) {
                console.log('üîß DEBUG: Attempting to reinitialize Collection Progress drawer...');
                const collectionProgressElement = document.getElementById('collectionProgressDrawer');
                if (collectionProgressElement && typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        collectionProgressDrawer = new bootstrap.Offcanvas(collectionProgressElement);
                        console.log('üîß DEBUG: Collection Progress drawer reinitialized:', collectionProgressDrawer);
                    } catch (error) {
                        console.error('üîß DEBUG: Failed to reinitialize Collection Progress drawer:', error);
                        return;
                    }
                } else {
                    console.error('üîß DEBUG: Cannot reinitialize - element or Bootstrap missing');
                    console.error('üîß DEBUG: Element:', collectionProgressElement);
                    console.error('üîß DEBUG: Bootstrap available:', typeof bootstrap !== 'undefined');
                    return;
                }
            }
            
            if (collectionProgressDrawer) {
                console.log('üîß DEBUG: Attempting to show drawer...');
                try {
                    collectionProgressDrawer.show();
                    console.log('üîß DEBUG: Drawer show() called successfully');
                    
                    // Refresh collection status when drawer opens
                    setTimeout(() => {
                        refreshCollectionStatus();
                    }, 100);
                    
                } catch (error) {
                    console.error('üîß DEBUG: Error showing drawer:', error);
                }
            } else {
                console.error('üîß DEBUG: collectionProgressDrawer is still null or undefined');
            }
        }

        function hideCollectionProgress() {
            console.log('üîß DEBUG: hideCollectionProgress called');
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }
        
        // Populate Collection Progress drawer with real status
        function refreshCollectionStatus() {
            console.log('üîß COLLECTION: Refreshing collection status...');
            
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    console.log('üîß COLLECTION: Status data:', data);
                    updateCollectionProgressDrawer(data);
                })
                .catch(error => {
                    console.error('‚ùå COLLECTION: Error fetching status:', error);
                    updateCollectionProgressDrawer({
                        status: 'error',
                        message: 'Error fetching collection status',
                        error_message: error.message
                    });
                });
        }
        
        // Update Collection Progress drawer content
        function updateCollectionProgressDrawer(statusData) {
            // Update status and badge
            const statusElement = document.getElementById('collectionProgressStatus');
            const badgeElement = document.getElementById('collectionStatusBadge');
            const sourceElement = document.getElementById('collectionSourceText');
            
            if (statusElement) {
                statusElement.textContent = statusData.message || 'Unknown status';
            }
            
            if (badgeElement && badgeElement.classList) {
                badgeElement.textContent = statusData.status || 'Unknown';
                
                // Update badge color based on status
                badgeElement.classList.remove('bg-secondary', 'bg-primary', 'bg-success', 'bg-warning', 'bg-danger');
                switch (statusData.status) {
                    case 'running':
                        badgeElement.classList.add('bg-primary');
                        break;
                    case 'completed':
                        badgeElement.classList.add('bg-success');
                        break;
                    case 'error':
                        badgeElement.classList.add('bg-danger');
                        break;
                    default:
                        badgeElement.classList.add('bg-secondary');
                        break;
                }
            }
            
            if (sourceElement) {
                sourceElement.textContent = statusData.current_source || 'No active collection';
            }
            
            // Show/hide progress info based on status
            const progressInfo = document.getElementById('collectionProgressInfo');
            const sourcesProgress = document.getElementById('collectionSourcesProgress');
            
            if (statusData.status === 'running' || statusData.status === 'completed') {
                // Show progress information
                if (progressInfo) {
                    progressInfo.style.display = 'block';
                    
                    const startTimeElement = document.getElementById('collectionStartTime');
                    const totalItemsElement = document.getElementById('collectionTotalItems');
                    
                    if (startTimeElement && statusData.start_time) {
                        const startTime = new Date(statusData.start_time);
                        startTimeElement.textContent = startTime.toLocaleString();
                    }
                    
                    if (totalItemsElement) {
                        totalItemsElement.textContent = statusData.total_items || '0';
                    }
                }
                
                // Show sources progress
                if (sourcesProgress && statusData.sources_completed) {
                    sourcesProgress.style.display = 'block';
                    const sourcesListElement = document.getElementById('collectionSourcesList');
                    if (sourcesListElement) {
                        if (statusData.sources_completed.length > 0) {
                            sourcesListElement.textContent = statusData.sources_completed.join(', ');
                        } else {
                            sourcesListElement.textContent = 'None';
                        }
                    }
                }
            } else {
                // Hide progress information for ready/error states
                if (progressInfo) progressInfo.style.display = 'none';
                if (sourcesProgress) sourcesProgress.style.display = 'none';
            }
            
            // Add log entry about status update
            addCollectionDrawerLog(`üìä Status: ${statusData.status} - ${statusData.message}`);
            
            if (statusData.error_message) {
                addCollectionDrawerLog(`‚ùå Error: ${statusData.error_message}`);
            }
        }
        
        // Add log entry to collection drawer
        function addCollectionDrawerLog(message) {
            const logContainer = document.getElementById('collectionLog');
            if (logContainer) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                
                // Auto-scroll to bottom
                const container = document.getElementById('collectionLogContainer');
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            }
        }
        
        // Clear collection log
        function clearCollectionLog() {
            const logContainer = document.getElementById('collectionLog');
            if (logContainer) {
                logContainer.innerHTML = '';
            }
        }
        
        // Client-side filtering to preserve cached state changes
        function applyClientFilter(filterType, filterValue) {
            console.log(`üîß CLIENT FILTER: Applying ${filterType} = ${filterValue}`);
            
            // Get all feedback cards
            const feedbackCards = document.querySelectorAll('.feedback-card');
            let visibleCount = 0;
            
            feedbackCards.forEach(card => {
                let shouldShow = true;
                
                // Apply audience filter
                if (filterType === 'audience' && filterValue !== 'All') {
                    const audienceBadge = card.querySelector('.audience-badge');
                    if (audienceBadge) {
                        const cardAudience = audienceBadge.textContent.trim();
                        // Extract audience name from badge text (remove emojis)
                        const cleanAudience = cardAudience.replace(/[üõ†Ô∏èüë§üè¢]/g, '').trim();
                        shouldShow = cleanAudience === filterValue;
                    }
                }
                
                // Apply state filter
                if (filterType === 'state' && filterValue !== 'All') {
                    const stateBadge = card.querySelector('.state-badge');
                    if (stateBadge) {
                        const cardState = stateBadge.getAttribute('data-current-state');
                        shouldShow = cardState === filterValue;
                    }
                }
                
                // Apply source filter
                if (filterType === 'source' && filterValue !== 'All') {
                    const sourceText = card.querySelector('.card-subtitle')?.textContent || '';
                    shouldShow = sourceText.includes(filterValue);
                }
                
                // Show/hide card
                if (shouldShow) {
                    card.style.display = 'block';
                    visibleCount++;
                } else {
                    card.style.display = 'none';
                }
            });
            
            // Update filter button states
            updateFilterButtonStates(filterType, filterValue);
            
            // Update URL without page reload
            const url = new URL(window.location);
            if (filterValue === 'All') {
                url.searchParams.delete(filterType);
            } else {
                url.searchParams.set(filterType, filterValue);
            }
            window.history.pushState({}, '', url);
            
            // Ensure cached changes are preserved and sync button is maintained
            if (stateManagementEnabled && hasUnsavedChanges) {
                updateSyncButton();
            }
            
            console.log(`‚úÖ CLIENT FILTER: Showing ${visibleCount} cards for ${filterType} = ${filterValue}`);
            console.log(`‚úÖ CLIENT FILTER: Cached changes preserved: ${Object.keys(cachedStateChanges).length} items`);
        }
        
        // Update filter button visual states
        function updateFilterButtonStates(activeFilterType, activeValue) {
            // Update audience buttons
            if (activeFilterType === 'audience') {
                document.querySelectorAll('[data-filter-type="audience"]').forEach(btn => {
                    const value = btn.getAttribute('data-filter-value');
                    btn.className = btn.className.replace(/btn-(primary|secondary|success|info|outline-primary|outline-secondary|outline-success|outline-info)/g, '');
                    
                    if (value === activeValue) {
                        if (value === 'Developer') btn.classList.add('btn-primary');
                        else if (value === 'Customer') btn.classList.add('btn-success');
                        else if (value === 'ISV') btn.classList.add('btn-info');
                        else btn.classList.add('btn-secondary');
                    } else {
                        if (value === 'Developer') btn.classList.add('btn-outline-primary');
                        else if (value === 'Customer') btn.classList.add('btn-outline-success');
                        else if (value === 'ISV') btn.classList.add('btn-outline-info');
                        else btn.classList.add('btn-outline-secondary');
                    }
                });
            }
        }
        
        // Global domain dropdown positioning
        let globalDomainDropdown = null;
        
        // Update domain function
        function updateDomain(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${currentDomain}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Create domain dropdown
            showDomainDropdown(feedbackId, currentDomain);
        }
        
        function showDomainDropdown(feedbackId, currentDomain) {
            // Store current scroll position to prevent scroll changes
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Remove any existing dropdown
            if (globalDomainDropdown) {
                globalDomainDropdown.remove();
                globalDomainDropdown = null;
            }
            
            // Find the actions button for positioning
            const actionsBtn = document.querySelector(`[data-feedback-id="${feedbackId}"][onclick*="toggleActionsMenu"]`);
            if (!actionsBtn) {
                console.error('Could not find actions button for positioning');
                return;
            }
            
            // Calculate position relative to viewport (no scrolling)
            const rect = actionsBtn.getBoundingClientRect();
            
            // Create dropdown with event delegation to prevent scroll events
            globalDomainDropdown = document.createElement('div');
            globalDomainDropdown.className = 'global-domain-dropdown';
            globalDomainDropdown.innerHTML = `
                <div class="dropdown-header">Select Domain:</div>
                <div class="dropdown-item" data-domain="GOVERNANCE">üèõÔ∏è Governance</div>
                <div class="dropdown-item" data-domain="USER_EXPERIENCE">üë§ User Experience</div>
                <div class="dropdown-item" data-domain="AUTHENTICATION">üîê Authentication & Security</div>
                <div class="dropdown-item" data-domain="PERFORMANCE">‚ö° Performance & Scalability</div>
                <div class="dropdown-item" data-domain="INTEGRATION">üîó Integration & APIs</div>
                <div class="dropdown-item" data-domain="ANALYTICS">üìä Analytics & Reporting</div>
                <div class="dropdown-divider"></div>
                <div class="dropdown-item text-danger" data-action="cancel">Cancel</div>
            `;
            
            // Add event delegation to prevent scroll issues
            globalDomainDropdown.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const item = e.target.closest('.dropdown-item');
                if (item) {
                    const domain = item.getAttribute('data-domain');
                    const action = item.getAttribute('data-action');
                    
                    if (action === 'cancel') {
                        hideGlobalDropdown();
                    } else if (domain) {
                        saveDomainChange(feedbackId, domain);
                    }
                }
                
                // Restore scroll position after any action
                setTimeout(() => {
                    window.scrollTo(currentScrollLeft, currentScrollTop);
                }, 0);
                
                return false;
            });
            
            // Position relative to viewport (fixed positioning)
            globalDomainDropdown.style.position = 'fixed';
            globalDomainDropdown.style.left = rect.left + 'px';
            globalDomainDropdown.style.top = (rect.bottom + 5) + 'px';
            globalDomainDropdown.style.backgroundColor = 'white';
            globalDomainDropdown.style.border = '1px solid #ddd';
            globalDomainDropdown.style.borderRadius = '4px';
            globalDomainDropdown.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            globalDomainDropdown.style.zIndex = '10000';
            globalDomainDropdown.style.minWidth = '250px';
            
            document.body.appendChild(globalDomainDropdown);
            
            console.log(`‚úÖ Global dropdown positioned at: ${globalDomainDropdown.style.left} ${globalDomainDropdown.style.top}`);
            console.log(`üìç Scroll position preserved: ${currentScrollLeft}, ${currentScrollTop}`);
            
            // Add click outside to close with scroll preservation
            setTimeout(() => {
                document.addEventListener('click', function hideGlobalDropdownOutsidePreserveScroll(event) {
                    if (globalDomainDropdown && !globalDomainDropdown.contains(event.target)) {
                        hideGlobalDropdown();
                        // Restore scroll position
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        document.removeEventListener('click', hideGlobalDropdownOutsidePreserveScroll);
                    }
                });
            }, 100);
        }
        
        function hideGlobalDropdown() {
            if (globalDomainDropdown) {
                globalDomainDropdown.remove();
                globalDomainDropdown = null;
                document.removeEventListener('click', hideGlobalDropdownOutside);
            }
        }
        
        function hideGlobalDropdownOutside(event) {
            if (globalDomainDropdown && !globalDomainDropdown.contains(event.target)) {
                hideGlobalDropdown();
            }
        }
        
        function saveDomainChange(feedbackId, newDomain) {
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${newDomain}`);
            
            // Store current scroll position before any operations
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            hideGlobalDropdown();
            
            // Map internal domain codes to display names
            const domainNames = {
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            // Send to server
            fetch('/api/update_domain_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_domain: newDomain
                })
            })
            .then(response => response.json())
            .then(data => {
                // Restore scroll position immediately
                window.scrollTo(currentScrollLeft, currentScrollTop);
                
                if (data.success) {
                    console.log(`‚úÖ Domain updated successfully: ${newDomain}`);
                    
                    // Update the UI immediately
                    const domainBadge = document.querySelector(`[data-feedback-id="${feedbackId}"]`).closest('.card').querySelector('.domain-badge');
                    if (domainBadge) {
                        domainBadge.textContent = domainNames[newDomain] || newDomain;
                    }
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success alert-dismissible fade show';
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
                    successMsg.innerHTML = `
                        ‚úÖ Domain updated successfully: ${domainNames[newDomain] || newDomain}
                        <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
                    `;
                    document.body.appendChild(successMsg);
                    setTimeout(() => {
                        if (successMsg.parentElement) {
                            successMsg.remove();
                        }
                    }, 3000);
                } else {
                    console.error('‚ùå Domain update failed:', data.message);
                    alert('‚ùå Domain update failed: ' + data.message);
                }
            })
            .catch(error => {
                // Restore scroll position on error too
                window.scrollTo(currentScrollLeft, currentScrollTop);
                console.error('‚ùå Domain update error:', error);
                alert('‚ùå Domain update failed: ' + error.message);
            });
        }
        
        // Add CSS for domain dropdown
        const style = document.createElement('style');
        style.textContent = `
            .global-domain-dropdown {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            }
            .global-domain-dropdown .dropdown-header {
                padding: 8px 16px;
                font-weight: bold;
                color: #6c757d;
                border-bottom: 1px solid #eee;
                background-color: #f8f9fa;
                font-size: 0.875rem;
            }
            .global-domain-dropdown .dropdown-item {
                padding: 8px 16px;
                cursor: pointer;
                font-size: 0.875rem;
                border-bottom: 1px solid #f0f0f0;
            }
            .global-domain-dropdown .dropdown-item:hover {
                background-color: #f8f9fa;
            }
            .global-domain-dropdown .dropdown-divider {
                height: 1px;
                background-color: #ddd;
                margin: 4px 0;
            }
            .global-domain-dropdown .text-danger {
                color: #dc3545 !important;
            }
        `;
        document.head.appendChild(style);
        
        // FINAL OVERRIDE - This will definitely take precedence with scroll preservation
        window.updateDomain = function(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è FINAL OVERRIDE - Domain update requested: ${feedbackId} ‚Üí current: ${currentDomain}`);
            
            // IMMEDIATELY capture and preserve scroll position
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            console.log(`üìç FINAL OVERRIDE - Captured scroll position: ${currentScrollLeft}, ${currentScrollTop}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            console.log('üîç FINAL OVERRIDE - Connection check:', {
                stateManagementEnabled,
                hasStateData: !!hasStateData,
                urlIndicatesConnection,
                fabricConnected,
                storedStateEnabled: localStorage.getItem('stateManagementEnabled') === 'true',
                storedFabricConnected: localStorage.getItem('fabricConnected') === 'true'
            });
            
            // Allow if ANY connection indicator is present
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected &&
                localStorage.getItem('stateManagementEnabled') !== 'true' &&
                localStorage.getItem('fabricConnected') !== 'true') {
                console.log('‚ùå FINAL OVERRIDE - No connection indicators found - showing alert');
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                // Restore scroll position after alert
                setTimeout(() => {
                    window.scrollTo(currentScrollLeft, currentScrollTop);
                    console.log(`üìç FINAL OVERRIDE - Scroll restored after alert: ${currentScrollLeft}, ${currentScrollTop}`);
                }, 0);
                return;
            }
            
            console.log('‚úÖ FINAL OVERRIDE - Connection check passed - showing domain dropdown');
            
            // Wrap the showDomainDropdown call to ensure scroll preservation
            setTimeout(() => {
                // Create domain dropdown
                if (typeof showDomainDropdown === 'function') {
                    showDomainDropdown(feedbackId, currentDomain);
                    // Force scroll restoration immediately after dropdown creation
                    setTimeout(() => {
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        console.log(`üìç FINAL OVERRIDE - Scroll forcibly restored after dropdown: ${currentScrollLeft}, ${currentScrollTop}`);
                    }, 0);
                } else {
                    console.log('üîß FINAL OVERRIDE - showDomainDropdown not found, creating inline dropdown');
                    // Fallback: create a simple dropdown inline
                    const newDomain = prompt('Select new domain:\n1. GOVERNANCE\n2. USER_EXPERIENCE\n3. AUTHENTICATION\n4. PERFORMANCE\n5. INTEGRATION\n6. ANALYTICS\n\nEnter domain name:', currentDomain);
                    if (newDomain && newDomain.trim()) {
                        if (typeof saveDomainChange === 'function') {
                            saveDomainChange(feedbackId, newDomain.trim().toUpperCase());
                        } else {
                            console.log('üîß FINAL OVERRIDE - saveDomainChange not found either, calling API directly');
                            // Direct API call with scroll preservation
                            fetch('/api/update_domain_sql', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    feedback_id: feedbackId,
                                    new_domain: newDomain.trim().toUpperCase()
                                })
                            })
                            .then(response => {
                                // Restore scroll immediately on response
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                                return response.json();
                            })
                            .then(data => {
                                if (data.success) {
                                    alert('‚úÖ Domain updated successfully!');
                                } else {
                                    alert('‚ùå Domain update failed: ' + data.message);
                                }
                                // Restore scroll after alert
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                            })
                            .catch(error => {
                                alert('‚ùå Domain update error: ' + error.message);
                                // Restore scroll after error
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                            });
                        }
                    }
                    // Restore scroll after prompt regardless
                    setTimeout(() => {
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        console.log(`üìç FINAL OVERRIDE - Scroll restored after prompt: ${currentScrollLeft}, ${currentScrollTop}`);
                    }, 0);
                }
            }, 0);
        };
        
        // Also override updateNotes
        window.updateNotes = function(feedbackId, currentNotes) {
            console.log(`üìù FINAL OVERRIDE - Notes update requested: ${feedbackId}`);
            
            // Same connection check as domain update
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected &&
                localStorage.getItem('stateManagementEnabled') !== 'true' &&
                localStorage.getItem('fabricConnected') !== 'true') {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            console.log('‚úÖ FINAL OVERRIDE - Notes update allowed');
            const newNotes = prompt('Enter notes for this feedback:', currentNotes || '');
            if (newNotes !== null) {
                console.log(`üíæ FINAL OVERRIDE - Saving notes for ${feedbackId}: ${newNotes}`);
                // TODO: Implement notes API call
                alert('Notes functionality to be implemented');
            }
        };
        
        console.log('üîß FINAL OVERRIDE - Functions registered on window object');
        
        // ALSO OVERRIDE toggleActionsMenu - this is where the early check is happening
        window.toggleActionsMenu = function(button) {
            console.log('üîß FINAL OVERRIDE - toggleActionsMenu called');
            
            // Don't check connection here - just show/hide the menu
            const feedbackId = button.getAttribute('data-feedback-id');
            const actionsMenu = button.parentElement.querySelector('.actions-menu');
            
            if (!actionsMenu) {
                console.error('Actions menu not found');
                return;
            }
            
            // Toggle menu visibility
            if (actionsMenu.style.display === 'block') {
                actionsMenu.style.display = 'none';
                button.parentElement.classList.remove('actions-open');
            } else {
                // Hide all other menus first
                document.querySelectorAll('.actions-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
                document.querySelectorAll('.card-actions').forEach(actions => {
                    actions.classList.remove('actions-open');
                });
                
                // Show this menu
                actionsMenu.style.display = 'block';
                button.parentElement.classList.add('actions-open');
                
                console.log(`‚úÖ FINAL OVERRIDE - Actions menu opened for ${feedbackId}`);
            }
        };
        
        console.log('üîß FINAL OVERRIDE - toggleActionsMenu also registered on window object');

    </script>

    <!-- Fabric Auth Drawer -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="fabricAuthDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-shield-check me-2"></i>Fabric Authentication
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" onclick="hideFabricAuth()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Current Token Status -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Connection Status</span>
                    <span id="fabricConnectionStatus" class="badge bg-secondary">Not Connected</span>
                </div>
                <div class="alert" id="fabricStatusAlert" role="alert" style="display: none;">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status" id="fabricAuthSpinner" style="display: none;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span id="fabricStatusText">Ready to connect</span>
                    </div>
                </div>
            </div>

            <!-- Token Input -->
            <div class="mb-4">
                <h6 class="text-muted mb-3">Fabric Bearer Token</h6>
                <div class="mb-3">
                    <label for="fabricAuthToken" class="form-label">Bearer Token</label>
                    <div class="input-group">
                        <input type="password" class="form-control" id="fabricAuthToken" placeholder="Paste your Fabric bearer token here...">
                        <button class="btn btn-outline-secondary" type="button" onclick="toggleTokenVisibility()">
                            <i class="bi bi-eye" id="tokenVisibilityIcon"></i>
                        </button>
                    </div>
                    <div class="form-text">
                        This token enables state management and Fabric Lakehouse operations.
                    </div>
                </div>
            </div>

            <!-- Current Token Info -->
            <div class="mb-4" id="currentTokenInfo" style="display: none;">
                <h6 class="text-muted mb-2">Current Token</h6>
                <div class="card">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="small text-muted">Last Validated</span>
                            <span class="badge bg-success" id="lastValidatedTime">Never</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-primary" id="validateTokenBtn" onclick="validateFabricToken()">
                    <i class="bi bi-check-circle me-1"></i>Validate & Connect
                </button>
                <button class="btn btn-outline-warning" id="updateTokenBtn" onclick="updateFabricToken()" style="display: none;">
                    <i class="bi bi-arrow-clockwise me-1"></i>Update Token
                </button>
                <button class="btn btn-outline-danger" id="clearTokenBtn" onclick="clearFabricToken()" style="display: none;">
                    <i class="bi bi-x-circle me-1"></i>Clear Token
                </button>
            </div>

            <!-- Validation Log -->
            <div class="mt-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Validation Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearFabricLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="fabricLogContainer" style="height: 200px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="fabricLog" class="font-monospace small"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Collection Progress Drawer (simplified for feedback viewer) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="collectionProgressDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-activity me-2"></i>Collection Progress
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" onclick="hideCollectionProgress()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Collection Status Display -->
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span id="collectionProgressStatus">Ready to start...</span>
                    <span class="badge bg-secondary" id="collectionStatusBadge">Ready</span>
                </div>
                <div class="card-body">
                    <div id="collectionSourceText">No active collection</div>
                    
                    <!-- Progress Information -->
                    <div class="row mt-3" id="collectionProgressInfo" style="display: none;">
                        <div class="col-md-6">
                            <small class="text-muted">Started</small>
                            <div id="collectionStartTime">-</div>
                        </div>
                        <div class="col-md-6">
                            <small class="text-muted">Total Items</small>
                            <div id="collectionTotalItems">0</div>
                        </div>
                    </div>
                    
                    <!-- Sources Progress -->
                    <div class="mt-3" id="collectionSourcesProgress" style="display: none;">
                        <small class="text-muted">Sources Completed</small>
                        <div id="collectionSourcesList">None</div>
                    </div>
                </div>
            </div>
            
            <!-- Collection Log -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Collection Log</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearCollectionLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="collectionLogContainer" style="height: 250px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="collectionLog" class="font-monospace small"></div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mt-3 d-flex gap-2">
                <a href="/" class="btn btn-primary">
                    <i class="bi bi-plus-circle me-1"></i>Start New Collection
                </a>
                <button class="btn btn-outline-secondary" onclick="refreshCollectionStatus()">
                    <i class="bi bi-arrow-clockwise me-1"></i>Refresh Status
                </button>
            </div>
        </div>
    </div>

</body>
</html>
