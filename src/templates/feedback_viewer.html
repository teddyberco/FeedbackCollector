<!DOCTYPE html>
<html>
<head>
    <title>Feedback Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/fluent-design.css') }}" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Domain display name mapping -->
    {% set domain_names = {
        'GETTING_STARTED': 'Getting Started',
        'GOVERNANCE': 'Governance', 
        'USER_EXPERIENCE': 'User Experience',
        'AUTHENTICATION': 'Authentication & Security',
        'PERFORMANCE': 'Performance & Scalability',
        'INTEGRATION': 'Integration & APIs',
        'ANALYTICS': 'Analytics & Reporting'
    } %}
    
    <!-- Domain color mapping -->
    {% set domain_colors = {
        'GETTING_STARTED': '#20c997',
        'GOVERNANCE': '#6f42c1',
        'USER_EXPERIENCE': '#28a745',
        'AUTHENTICATION': '#dc3545',
        'PERFORMANCE': '#fd7e14',
        'INTEGRATION': '#17a2b8',
        'ANALYTICS': '#ffc107'
    } %}
    
    <style>
        /* 
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            margin: 0; 
            background-color: #f8f9fa; 
        }
        */
        .container-custom { /* Renamed from container-fluid to allow custom padding */
            padding: 20px;
        }
        
        /* Card specific styles */
        .card {
            border: 1px solid #e1dfdd; /* fabric-gray-40 */
            border-radius: 8px; /* border-radius-lg */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            height: 100%;
            background-color: #ffffff;
        }
        .card:hover {
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: #c8c6c4; /* fabric-gray-60 */
        }
        
        .category-chip, .subcategory-chip, .domain-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.1s ease;
            margin-right: 4px;
            margin-bottom: 4px;
            vertical-align: middle;
        }
        
        .category-chip {
            background-color: #e6f2fb; /* Light blue */
            color: #0078d4; /* fabric-primary */
            border: 1px solid transparent;
        }
        .category-chip:hover {
            background-color: #cce4f7;
            border-color: #0078d4;
        }
        
        .subcategory-chip {
            background-color: #f3f2f1; /* fabric-neutral-lighter */
            color: #323130; /* fabric-neutral-dark */
            border: 1px solid #e1dfdd;
        }
        .subcategory-chip:hover {
            background-color: #edebe9;
            border-color: #8a8886;
        }
        .subcategory-empty {
            border-style: dashed;
            color: #605e5c;
        }
        
        .domain-badge {
            /* Background color is set inline */
            border: 1px solid transparent;
            color: white !important;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .domain-badge:hover {
            opacity: 0.9;
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }

        .card.dropdown-open {
            z-index: 1000;
            transform: none !important;
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 500;
        }
        .card-subtitle {
            font-size: 0.85rem;
        }
        .feedback-content {
            font-size: 0.9rem;
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 5;
            -webkit-box-orient: vertical;
            overflow: hidden;
            margin-bottom: 1.5rem;
            cursor: pointer;
            transition: color 0.2s ease;
            height: 7.5em; /* Force fixed height for 5 lines alignment */
        }
        .feedback-content:hover {
            color: #0078d4 !important;
        }
        .card .badge { /* Style badges a bit */
            font-size: 0.75em;
        }
        /* Fluent-inspired clickable effect (optional, can be enhanced) */
        .card a.btn { /* Make button stand out a bit */
            font-weight: 500;
        }
        /* Sentiment badge styles */
        .sentiment-positive {
            background-color: #28a745 !important;
            animation: pulse-green 2s infinite;
        }
        .sentiment-negative {
            background-color: #dc3545 !important;
            animation: pulse-red 2s infinite;
        }
        .sentiment-neutral {
            background-color: #6c757d !important;
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }
        
        /* Keyword badge styles */
        .keyword-tags {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }
        .keyword-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #495057;
            margin-right: 2px;
        }
        .keyword-badge {
            background-color: #20c997 !important;
            color: white !important;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            transition: transform 0.2s ease;
        }
        .keyword-badge:hover {
            transform: scale(1.05);
        }
        .keyword-more {
            background-color: #0dcaf0 !important;
            color: white !important;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: help;
            transition: transform 0.2s ease;
        }
        .keyword-more:hover {
            transform: scale(1.1);
            background-color: #0bb5d6 !important;
        }
        
        /* Enhanced categorization styles */
        .audience-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 12px;
            padding: 4px 8px;
            margin-right: 4px;
        }
        .audience-developer { background-color: #007bff; color: white; }
        .audience-customer { background-color: #28a745; color: white; }
        .audience-isv { background-color: #6f42c1; color: white; }
        .audience-platform { background-color: #fd7e14; color: white; }
        .audience-unknown { background-color: #6c757d; color: white; }
        
        .priority-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 8px;
            padding: 3px 6px;
            margin-left: 4px;
        }
        .priority-critical {
            background-color: #dc3545;
            color: white;
            animation: pulse-red 2s infinite;
        }
        .priority-high { background-color: #fd7e14; color: white; }
        .priority-medium { background-color: #ffc107; color: #212529; }
        .priority-low { background-color: #6c757d; color: white; }
        
        .category-info {
            font-size: 0.75rem;
            color: #6c757d;
            margin-bottom: 8px;
        }
        
        .filter-section {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
            z-index: 100;
        }
        
        /* Modern Card Layout */
        .filters-container {
            display: grid;
            grid-template-columns: 1fr 1fr 2fr;
            gap: 16px;
            margin-top: 24px;
        }
        
        .filter-card.content-card {
            grid-column: span 1;
        }
        
        .filter-card.content-card .filter-groups-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            column-gap: 20px;
            row-gap: 20px;
            grid-auto-rows: 1fr;
        }
        
        .filter-card.content-card .filter-groups-grid .filter-group {
            margin-bottom: 0 !important;
        }
        
        @media (max-width: 1200px) {
            .filters-container {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .filter-card.content-card .filter-groups-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 600px) {
            .filters-container {
                grid-template-columns: 1fr;
            }
        }
        
        /*
        .filter-card {
            background: #ffffff;
            border-radius: 16px;
            padding: 24px;
            border: 2px solid #e3e8ef;
            box-shadow: 0 4px 16px rgba(0,0,0,0.06);
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }
        
        .filter-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px 16px 0 0;
        }
        
        .filter-card:hover {
            border-color: #c5d0e0;
            box-shadow: 0 8px 24px rgba(0,0,0,0.12);
            transform: translateY(-4px);
        }
        */
        
        .filter-card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #f0f3f7;
        }
        
        .filter-card-icon {
            font-size: 2rem;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .filter-card-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #2d3748;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .filter-group {
            margin-bottom: 20px;
        }
        
        .filter-group:last-child {
            margin-bottom: 0;
        }
        
        .filter-label {
            font-weight: 700;
            color: #4a5568;
            margin-bottom: 8px;
            display: block;
            font-size: 0.9rem;
            letter-spacing: 0.3px;
        }
        
        /*
        .btn-outline-secondary {
            border: 2px solid #e2e8f0;
            font-weight: 600;
            color: #4a5568;
            background: #ffffff;
            transition: all 0.2s ease;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 0.9rem;
        }
        
        .btn-outline-secondary:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: #ffffff;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
        }
        
        .btn-outline-secondary:focus {
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        */
        
        /* Dropdown menu styling */
        .dropdown-menu {
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            padding: 12px;
            z-index: 9999 !important;
            margin-top: 4px !important;
            position: absolute !important;
            top: 100% !important;
            transform: none !important;
            will-change: auto !important;
        }
        
        .dropdown-menu.show {
            animation: dropdownFadeIn 0.15s ease-out;
        }
        
        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .form-check {
            padding: 8px 12px;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }
        
        .form-check:hover {
            background-color: #f7fafc;
        }
        
        .form-check-input:checked {
            background-color: #667eea;
            border-color: #667eea;
        }
        
        .form-check-label {
            cursor: pointer;
            user-select: none;
        }
        
        /* Apply button styling */
        /*
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            border: none !important;
            color: #ffffff !important;
            font-weight: 600 !important;
            padding: 10px 20px !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3) !important;
            transition: all 0.2s ease !important;
        }
        
        .btn-primary:hover {
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4) !important;
            transform: translateY(-2px) !important;
        }
        
        .btn-primary:active {
            transform: translateY(0) !important;
        }
        */
        
        @media (max-width: 768px) {
            .filters-row {
                flex-direction: column;
                gap: 10px;
            }
            .filter-col {
                min-width: unset;
            }
        }
        
        .domain-badge {
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 8px;
            padding: 3px 6px;
            margin-right: 4px;
            color: white;
        }

        .category-chip,
        .subcategory-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #edf2ff;
            color: #364fc7;
            border: 1px solid rgba(54, 79, 199, 0.15);
        }

        .category-chip:hover,
        .subcategory-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(54, 79, 199, 0.2);
        }

        .subcategory-chip {
            background-color: #f1f5f9;
            color: #0f172a;
            border-color: rgba(15, 23, 42, 0.08);
        }

        .subcategory-chip.subcategory-empty {
            background-color: #fff3cd;
            color: #8a6d3b;
            font-style: italic;
            border-color: rgba(138, 109, 59, 0.15);
        }

        .feature-chip {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.7rem;
            font-weight: 600;
            background-color: #e2e8f0;
            color: #4a5568;
            border: 1px solid rgba(74, 85, 104, 0.12);
        }

        .interactive-categories {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
        }
        
        /* Hide duplicate domain displays - we should only use domain-badge */
        .domain-display {
            display: none !important;
        }
        
        .repeating-analysis {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .similarity-indicator {
            font-size: 0.75rem;
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }
        
        /* State Management Styles */
        .state-badge {
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            padding: 4px 10px;
            margin-right: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .state-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .state-new { background-color: #6c757d; color: white; }
        .state-triaged { background-color: #007bff; color: white; }
        .state-closed { background-color: #28a745; color: white; }
        .state-irrelevant { background-color: #dc3545; color: white; }
        
        .card-actions {
            position: relative;
            display: inline-block;
        }
        .state-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 100000 !important;
            min-width: 120px;
            display: none;
            top: calc(100% + 2px);
            left: 0;
            max-width: 200px;
            white-space: nowrap;
            opacity: 1 !important;
        }
        
        .state-dropdown.show {
            display: block !important;
            opacity: 1 !important;
        }
        
        .state-option {
            padding: 8px 12px;
            cursor: pointer;
            color: #333;
            font-size: 14px;
            display: block;
            text-decoration: none;
        }
        
        .state-option:hover {
            background-color: #f8f9fa;
            color: #333;
        }
        
        .state-badge {
            position: relative;
            display: inline-block;
        }
        
        .state-badge {
            position: relative;
        }
        
        .card {
            overflow: visible !important;
        }
        
        .card-body {
            overflow: visible !important;
        }
        
        .category-info {
            overflow: visible !important;
            position: relative;
        }
        .state-dropdown.show {
            display: block;
        }
        .state-option {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.85rem;
        }
        .state-option:hover {
            background-color: #f8f9fa;
        }
        .state-option:last-child {
            border-bottom: none;
        }
        
        .token-banner {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .token-banner.hidden {
            display: none;
        }
        
        .notes-display {
            font-size: 0.8rem;
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 6px 0;
            border-left: 3px solid #007bff;
        }
        
        .state-management-disabled .state-badge {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .state-management-disabled .card-actions {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Ensure state badges are enabled when state management is active */
        .state-badge {
            opacity: 1;
            cursor: pointer;
        }
        
        .state-badge:hover {
            opacity: 0.8;
        }

        .spin {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    
    <!-- Badge State Manager -->
    <script src="{{ url_for('static', filename='js/badge-state-manager.js') }}"></script>
    
    <!-- Modern Filter System -->
    <script src="{{ url_for('static', filename='js/modern-filter-system.js') }}"></script>
</head>
<body>
    <div class="fluent-container">
        <h1 class="fluent-title">Collected Feedback</h1>
        <div class="d-flex gap-2 mb-4">
            <a href="/" class="fluent-button fluent-button-secondary text-decoration-none">
                <i class="bi bi-arrow-left me-2"></i>Back to Collector
            </a>
            <button class="fluent-button fluent-button-secondary" id="collectionProgressBtn" onclick="toggleCollectionProgress()">
                <i class="bi bi-activity me-2"></i>Collection Progress
                <span class="fluent-badge fluent-badge-secondary ms-2" id="progressBadge">Ready</span>
            </button>
            <button class="fluent-button fluent-button-primary" id="fabricSyncBtn" onclick="syncWithFabric()"
                    title="Connect to Fabric SQL database to load and manage feedback states">
                <i class="bi bi-database me-2"></i>Sync with Fabric
                <span class="fluent-badge fluent-badge-secondary ms-2" id="fabricSyncBadge" style="background: rgba(255,255,255,0.2); color: white;">Not Connected</span>
            </button>
            <button class="fluent-button fluent-button-secondary" id="domainSyncBtn" onclick="syncDomainsFromState()"
                    title="Sync domain updates from FeedbackState to Feedback table (useful after table recreation)"
                    style="display: none;">
                <i class="bi bi-arrow-repeat me-2"></i>Sync Domains
            </button>
        </div>

        <!-- Fabric Auth will now be handled through the persistent drawer -->

        <!-- Enhanced Statistics Dashboard -->
        {% if category_stats %}
        <div class="fluent-alert fluent-alert-info" role="alert">
            <h5 class="fluent-section-title" style="font-size: 1rem; margin-bottom: 10px;">üìä Category Statistics</h5>
            <div class="row">
                <div class="col-md-3">
                    <strong>By Audience:</strong>
                    <ul class="mb-0 ps-3">
                        {% for audience, count in category_stats.by_audience.items() %}
                        <li>{{ audience }}: {{ count }} ({{ "%.1f"|format((count/category_stats.total_items)*100) }}%)</li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>By Priority:</strong>
                    <ul class="mb-0 ps-3">
                        {% for priority, data in category_stats.priority_distribution.items() %}
                        <li>{{ priority|title }}: {{ data.count }} ({{ data.percentage }}%)</li>
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>By Domain:</strong>
                    <ul class="mb-0 ps-3">
                        {% for domain, count in category_stats.by_domain.items() %}
                        {% if count > 0 %}
                        <li>{{ domain }}: {{ count }}</li>
                        {% endif %}
                        {% endfor %}
                    </ul>
                </div>
                <div class="col-md-3">
                    <strong>Top Categories:</strong>
                    <ul class="mb-0 ps-3">
                        {% for category, count in (category_stats.by_enhanced_category.items()|list)[:3] %}
                        <li>{{ category[:20] }}{% if category|length > 20 %}...{% endif %}: {{ count }}</li>
                        {% endfor %}
                    </ul>
                </div>
            </div>
        </div>
        {% elif trending_category_name and trending_category_count > 0 %}
        <div class="fluent-alert fluent-alert-info" role="alert">
            <h5 class="fluent-section-title" style="font-size: 1rem;">üî• Trending Category</h5>
            <p class="mb-0">The most frequent category in the current view is: <strong>{{ trending_category_name }}</strong> ({{ trending_category_count }} item{% if trending_category_count != 1 %}s{% endif %}).</p>
        </div>
        {% endif %}

        {% if feedback_items %}
        <div class="fluent-card mb-4">
            <div class="fluent-card-body">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
                    <h6 class="fluent-section-title mb-0" style="font-size: 1rem;">üìä Sentiment Overview</h6>
                    
                    <!-- Sort & Display Options -->
                    <div class="d-flex gap-2 align-items-center flex-wrap">
                        <!-- Sort Options -->
                        <div class="d-flex gap-2" role="group" aria-label="Date sort options">
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateSort('newest')"
                               class="fluent-button {% if current_sort == 'newest' or not current_sort %}fluent-button-primary{% else %}fluent-button-secondary{% endif %}" style="font-size: 0.75rem; min-height: 32px;">üìÖ Newest</button>
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateSort('oldest')"
                               class="fluent-button {% if current_sort == 'oldest' %}fluent-button-primary{% else %}fluent-button-secondary{% endif %}" style="font-size: 0.75rem; min-height: 32px;">üìÜ Oldest</button>
                        </div>

                        <!-- Repeating Requests Toggle -->
                        <div class="d-flex gap-2" role="group" aria-label="Repeating requests toggle">
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateRepeating(false)"
                               class="fluent-button {% if not show_repeating %}fluent-button-primary{% else %}fluent-button-secondary{% endif %}" style="font-size: 0.75rem; min-height: 32px;">Hide</button>
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateRepeating(true)"
                               class="fluent-button {% if show_repeating %}fluent-button-primary{% else %}fluent-button-secondary{% endif %}" style="font-size: 0.75rem; min-height: 32px;">üîç Analyze</button>
                        </div>

                        <!-- Density Toggle -->
                        <div class="d-flex gap-2 ms-2 border-start ps-3" role="group" aria-label="Density toggle">
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateDensity('cozy')"
                               class="fluent-button fluent-button-secondary density-btn-cozy active" style="font-size: 0.75rem; min-height: 32px;" title="Cozy View">
                               <i class="bi bi-grid-3x3-gap"></i> Cozy
                            </button>
                            <button onclick="if(modernFilterSystem) modernFilterSystem.updateDensity('dense')"
                               class="fluent-button fluent-button-secondary density-btn-dense" style="font-size: 0.75rem; min-height: 32px;" title="Dense View">
                               <i class="bi bi-grid-3x3"></i> Dense
                            </button>
                        </div>
                    </div>
                </div>
                <div class="d-flex gap-2 flex-wrap">
                    {% set positive_count = feedback_items | selectattr('Sentiment', 'equalto', 'Positive') | list | length %}
                    {% set negative_count = feedback_items | selectattr('Sentiment', 'equalto', 'Negative') | list | length %}
                    {% set neutral_count = feedback_items | selectattr('Sentiment', 'equalto', 'Neutral') | list | length %}
                    <span class="fluent-badge fluent-badge-success">üòä {{ positive_count }} Positive</span>
                    <span class="fluent-badge fluent-badge-secondary">üòê {{ neutral_count }} Neutral</span>
                    <span class="fluent-badge fluent-badge-error">üòû {{ negative_count }} Negative</span>
                </div>
            </div>
        </div>
        {% endif %}

        <!-- Enhanced Filter Section -->
        <div class="mb-4 filter-section" id="filter-section-container">
            <h5 class="fluent-section-title mb-3"><i class="bi bi-funnel-fill"></i> Filters</h5>
            
            <div class="filters-container">
                <!-- Workflow Card -->
                <div class="fluent-card p-3">
                        <div class="fluent-card-header p-0 border-0 mb-3">
                            <div class="d-flex align-items-center gap-2">
                                <span class="filter-card-icon" style="width: 32px; height: 32px; font-size: 1.2rem;">üìã</span>
                                <h6 class="fluent-section-title mb-0" style="font-size: 1rem;">Workflow</h6>
                            </div>
                        </div>
                        <!-- State Filter -->
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="stateFilter">üìù State</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="stateFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_states %}
                                        {{ selected_states|length }} selected
                                    {% else %}
                                        All States
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for state in all_states %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="state"
                                               value="{{ state }}" id="state_{{ state|lower }}"
                                               {% if state in selected_states %}checked{% endif %}>
                                        <label class="form-check-label" for="state_{{ state|lower }}">
                                            {% if state == 'NEW' %}üÜï New
                                            {% elif state == 'TRIAGED' %}üîç Triaged
                                            {% elif state == 'CLOSED' %}‚úÖ Closed
                                            {% elif state == 'IRRELEVANT' %}‚ùå Irrelevant
                                            {% else %}{{ state }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>

                        <!-- Audience Filter -->
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="audienceFilter">üë• Audience</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="audienceFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_audiences %}
                                        {{ selected_audiences|length }} selected
                                    {% else %}
                                        All Audiences
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for audience in all_audiences %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="audience"
                                               value="{{ audience }}" id="audience_{{ audience|lower }}"
                                               {% if audience in selected_audiences %}checked{% endif %}>
                                        <label class="form-check-label" for="audience_{{ audience|lower }}">
                                            {% if audience == 'Developer' %}üõ†Ô∏è Developer
                                            {% elif audience == 'Customer' %}üë§ Customer
                                            {% elif audience == 'ISV' %}üè¢ ISV
                                            {% else %}{{ audience }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>

                        <!-- Priority Filter -->
                        <div class="filter-group">
                            <label class="fluent-label" for="priorityFilter">‚ö° Priority</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="priorityFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_priorities %}
                                        {{ selected_priorities|length }} selected
                                    {% else %}
                                        All Priorities
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for priority in all_priorities %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="priority"
                                               value="{{ priority }}" id="priority_{{ priority|lower }}"
                                               {% if priority in selected_priorities %}checked{% endif %}>
                                        <label class="form-check-label" for="priority_{{ priority|lower }}">
                                            {% if priority|lower == 'critical' %}üî¥ Critical
                                            {% elif priority|lower == 'high' %}üü† High
                                            {% elif priority|lower == 'medium' %}üü° Medium
                                            {% elif priority|lower == 'low' %}‚ö™ Low
                                            {% else %}{{ priority|title }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                </div>

                <!-- Classification Card -->
                <div class="fluent-card p-3">
                        <div class="fluent-card-header p-0 border-0 mb-3">
                            <div class="d-flex align-items-center gap-2">
                                <span class="filter-card-icon" style="width: 32px; height: 32px; font-size: 1.2rem;">üéØ</span>
                                <h6 class="fluent-section-title mb-0" style="font-size: 1rem;">Classification</h6>
                            </div>
                        </div>
                        
                        <!-- Impact Type Filter -->
                        {% if all_impact_types %}
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="impacttypeFilter">‚ö†Ô∏è Impact Type</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="impacttypeFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    All Types
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for itype in all_impact_types %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="impacttype"
                                               value="{{ itype }}" id="impacttype_{{ loop.index }}">
                                        <label class="form-check-label" for="impacttype_{{ loop.index }}">
                                            {% if itype == 'BUG' %}üêõ Bug
                                            {% elif itype == 'FEATURE_REQUEST' %}‚ú® Feature Request
                                            {% elif itype == 'QUESTION' %}‚ùì Question
                                            {% elif itype == 'PRAISE' %}üëè Praise
                                            {% elif itype == 'COMPLAINT' %}üò§ Complaint
                                            {% else %}{{ itype }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}

                        <!-- Sentiment Filter -->
                        {% if all_sentiments %}
                        <div class="filter-group">
                            <label class="fluent-label" for="sentimentFilter">üòä Sentiment</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="sentimentFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_sentiments %}
                                        {{ selected_sentiments|length }} selected
                                    {% else %}
                                        All Sentiments
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for sentiment in all_sentiments %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="sentiment"
                                               value="{{ sentiment }}" id="sentiment_{{ sentiment|lower }}"
                                               {% if sentiment in selected_sentiments %}checked{% endif %}>
                                        <label class="form-check-label" for="sentiment_{{ sentiment|lower }}">
                                            {% if sentiment|lower == 'positive' %}üòä Positive
                                            {% elif sentiment|lower == 'negative' %}üòû Negative
                                            {% elif sentiment|lower == 'neutral' %}üòê Neutral
                                            {% else %}{{ sentiment|title }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}
                </div>

                <!-- Content Card -->
                <div class="fluent-card p-3 content-card">
                        <div class="fluent-card-header p-0 border-0 mb-3">
                            <div class="d-flex align-items-center gap-2">
                                <span class="filter-card-icon" style="width: 32px; height: 32px; font-size: 1.2rem;">üìå</span>
                                <h6 class="fluent-section-title mb-0" style="font-size: 1rem;">Content</h6>
                            </div>
                        </div>
                        
                        <div class="filter-groups-grid">
                        <!-- Category Filter -->
                        {% if all_enhanced_categories %}
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="enhanced_categoryFilter">üìÇ Category</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="enhanced_categoryFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_enhanced_categories %}
                                        {{ selected_enhanced_categories|length }} selected
                                    {% else %}
                                        All Categories
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 350px; max-height: 400px; overflow-y: auto;">
                                    {% for cat in all_enhanced_categories %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="enhanced_category"
                                               value="{{ cat }}" id="enhanced_category_{{ loop.index }}"
                                               {% if cat in selected_enhanced_categories %}checked{% endif %}>
                                        <label class="form-check-label" for="enhanced_category_{{ loop.index }}">
                                            {% if cat == 'Uncategorized' %}‚ùì Uncategorized
                                            {% else %}{{ cat[:40] }}{% if cat|length > 40 %}...{% endif %}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}

                        <!-- Subcategory Filter (Grouped by Feature Area) -->
                        {% if all_subcategories %}
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="subcategoryFilter">üìã Subcategory</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="subcategoryFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    All Subcategories
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 350px; max-height: 400px; overflow-y: auto;">
                                    {% for feature_area, subcats in subcategories_by_feature_area.items() %}
                                    <div class="text-muted small fw-bold px-2 pt-2" style="font-size: 0.75rem;">{{ feature_area }}</div>
                                    {% for subcat in subcats %}
                                    <div class="form-check ms-2">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="subcategory"
                                               value="{{ subcat }}" id="subcategory_{{ subcat|replace(' ', '_')|replace('/', '_')|lower }}">
                                        <label class="form-check-label" for="subcategory_{{ subcat|replace(' ', '_')|replace('/', '_')|lower }}">
                                            {{ subcat[:40] }}{% if subcat|length > 40 %}...{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    {% if not loop.last %}<hr class="dropdown-divider my-2">{% endif %}
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}

                        <!-- Domain Filter -->
                        {% if all_domains %}
                        <div class="filter-group mb-3">
                            <label class="fluent-label" for="domainFilter">üéØ Domain</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="domainFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_domains %}
                                        {{ selected_domains|length }} selected
                                    {% else %}
                                        All Domains
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 300px; max-height: 400px; overflow-y: auto;">
                                    {% for domain in all_domains %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="domain"
                                               value="{{ domain }}" id="domain_{{ domain|lower|replace('_', '') }}"
                                               {% if domain in selected_domains %}checked{% endif %}>
                                        <label class="form-check-label" for="domain_{{ domain|lower|replace('_', '') }}">
                                            {% if domain == 'Getting Started' %}üöÄ Getting Started
                                            {% elif domain == 'Governance' %}üèõÔ∏è Governance
                                            {% elif domain == 'User Experience' %}üé® User Experience
                                            {% elif domain == 'Authentication & Security' %}üîê Auth & Security
                                            {% elif domain == 'Performance & Scalability' %}‚ö° Performance
                                            {% elif domain == 'Integration & APIs' %}üîó Integration
                                            {% elif domain == 'Analytics & Reporting' %}üìä Analytics
                                            {% elif domain == 'Uncategorized' %}‚ùì Uncategorized
                                            {% else %}{{ domain }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}

                        <!-- Source Filter -->
                        {% if all_sources %}
                        <div class="filter-group">
                            <label class="fluent-label" for="sourceFilter">üì° Source</label>
                            <div class="dropdown">
                                <button class="fluent-select d-flex justify-content-between align-items-center" type="button" id="sourceFilter" data-bs-toggle="dropdown" aria-expanded="false">
                                    {% if selected_sources %}
                                        {{ selected_sources|length }} selected
                                    {% else %}
                                        All Sources
                                    {% endif %}
                                    <i class="bi bi-chevron-down"></i>
                                </button>
                                <div class="dropdown-menu p-3 shadow-sm border-0" style="min-width: 250px;">
                                    {% for src in all_sources %}
                                    <div class="form-check">
                                        <input class="form-check-input filter-checkbox" type="checkbox" data-filter="source"
                                               value="{{ src }}" id="source_{{ src|lower|replace(' ', '_') }}"
                                               {% if src in selected_sources %}checked{% endif %}>
                                        <label class="form-check-label" for="source_{{ src|lower|replace(' ', '_') }}">
                                            {% if src == 'Reddit' %}üì± Reddit
                                            {% elif src == 'GitHub' %}üíª GitHub
                                            {% elif 'Fabric' in src %}üè¢ {{ src }}
                                            {% else %}{{ src }}{% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                    <hr class="dropdown-divider">
                                    <button class="fluent-button fluent-button-primary w-100" onclick="applyMultiSelectFilters()">Apply</button>
                                </div>
                            </div>
                        </div>
                        {% endif %}
                        </div>
                </div>
            </div>
        </div>

       <!-- Repeating Requests Analysis -->
       {% if show_repeating and repeating_analysis %}
       <div class="repeating-analysis">
           <h5>üîÑ Repeating Requests Analysis</h5>
           <div class="row">
               <div class="col-md-6">
                   <p><strong>Summary:</strong></p>
                   <ul>
                       <li>Total feedback items: {{ repeating_analysis.total_items }}</li>
                       <li>Unique requests: {{ repeating_analysis.unique_requests }}</li>
                       <li>Repeating clusters: {{ repeating_analysis.cluster_count }}</li>
                       <li>Repetition rate: {{ repeating_analysis.repetition_rate }}%</li>
                   </ul>
               </div>
               <div class="col-md-6">
                   <p><strong>Top Repeating Requests:</strong></p>
                   {% for req in repeating_analysis.top_repeating_requests[:3] %}
                   <div class="mb-2">
                       <strong>{{ req.count }}x:</strong> {{ req.summary }}
                       <br><small class="text-muted">Audiences: {{ req.audiences|join(', ') }} | Sources: {{ req.sources|join(', ') }}</small>
                   </div>
                   {% endfor %}
               </div>
           </div>
       </div>
       {% endif %}

        <!-- Modern Filter System Loading & Error States -->
        <div id="filter-loading" class="alert alert-info d-none" role="alert">
            <div class="d-flex align-items-center">
                <div class="spinner-border spinner-border-sm me-2" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <span>Applying filters...</span>
            </div>
        </div>
        
        <div id="filter-error" class="fluent-alert fluent-alert-error d-none" role="alert">
            <i class="bi bi-exclamation-triangle me-2"></i>
            <span id="filter-error-message">Error applying filters</span>
            <button class="fluent-button fluent-button-danger ms-2" onclick="location.reload()" style="padding: 4px 12px; min-height: 32px;">Reload Page</button>
        </div>
        
        {% if error %}
            <div class="fluent-alert fluent-alert-error">{{ error }}</div>
        {% elif not feedback_items %}
            <!-- Empty State -->
            <div class="container text-center py-5">
                <div class="row justify-content-center">
                    <div class="col-md-8">
                        <div class="fluent-card">
                            <div class="fluent-card-body py-5">
                                <h3 class="fluent-card-title mb-4">üìÑ No Feedback Data Available</h3>
                                <p class="mb-4">
                                    You can either collect new feedback from various sources or load existing data from your Fabric SQL database.
                                </p>
                                <div class="d-grid gap-2 d-md-flex justify-content-md-center">
                                    <a href="{{ url_for('index') }}" class="fluent-button fluent-button-primary me-md-2" style="min-height: 40px; padding: 0 24px;">
                                        üîÑ Collect New Feedback
                                    </a>
                                    {% if stored_token %}
                                    <button class="fluent-button fluent-button-secondary" onclick="loadFromFabricSQL()" style="min-height: 40px; padding: 0 24px;">
                                        üìä Load from Fabric SQL
                                    </button>
                                    {% else %}
                                    <button class="fluent-button fluent-button-secondary" onclick="alert('Please connect to Fabric first using the drawer on the right.')" style="min-height: 40px; padding: 0 24px;">
                                        üìä Load from Fabric SQL
                                    </button>
                                    {% endif %}
                                </div>
                                <hr class="my-4">
                                <small class="text-muted">
                                    <strong>Need to connect to Fabric?</strong> Use the drawer on the right to authenticate and sync your data.
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        {% elif feedback_items %}
            <!-- Feedback Items Container - This will be updated by AJAX -->
            <div id="feedback-container">
            <div id="feedback-grid" class="row row-cols-1 row-cols-md-2 row-cols-lg-3 row-cols-xl-4 row-cols-xxl-5 g-4"> {# Bootstrap grid for cards #}
                {% for item in feedback_items %}
                <div class="col">
                    <div class="fluent-card h-100 d-flex flex-column">
                        <div class="fluent-card-header border-bottom-0 pb-0 pt-3 px-3">
                            <h5 class="fluent-section-title mb-1 fluent-card-title-truncate" style="font-size: 1.1rem; line-height: 1.4;" title="{{ item['Feedback_Gist'] or item.Title or ('Feedback from ' + (item.Sources or 'N/A')) }}">
                                {% if item['Feedback_Gist'] and item['Feedback_Gist']|trim != '' and item['Feedback_Gist']|lower != 'no content' and item['Feedback_Gist']|lower != 'summary unavailable' %}
                                    {{ item['Feedback_Gist'] }}
                                {% elif item.Title and item.Title|trim != '' %}
                                    {{ item.Title }} {# Fallback to original Title if Gist is not useful #}
                                {% else %}
                                    Feedback from {{ item.Sources or 'N/A' }} {# Generic fallback #}
                                {% endif %}
                            </h5>
                            <h6 class="text-muted small mb-2">
                                {{ item.Sources or 'Unknown Source' }}
                                {% if item.Created and item.Created|trim != '' %}
                                    - {{ item.Created.split('T')[0] }} {# Show Date part only #}
                                {% endif %}
                            </h6>
                        </div>
                        
                        <div class="fluent-card-body pt-2 flex-grow-1">
                            <!-- Metadata Section: Audience, Priority, State -->
                            <div class="category-info mb-3">
                                <div class="d-flex flex-wrap align-items-center gap-2">
                                    {% if item.Audience and item.Audience|trim != '' %}
                                        <span class="audience-badge audience-{{ item.Audience|lower }}"
                                              onclick="updateAudience('{{ item.Feedback_ID or '' }}', '{{ item.Audience }}')"
                                              title="Click to update audience"
                                              style="cursor: pointer;">
                                            {% if item.Audience == 'Developer' %}üõ†Ô∏è Developer
                                            {% elif item.Audience == 'Customer' %}üë§ Customer
                                            {% elif item.Audience == 'ISV' %}üè¢ ISV
                                            {% else %}{{ item.Audience }}{% endif %}
                                        </span>
                                    {% endif %}
                                    
                                    {% if item.Priority and item.Priority|trim != '' %}
                                        <span class="priority-badge priority-{{ item.Priority|lower }}" title="Priority: {{ item.Priority|title }}">
                                            {% if item.Priority|lower == 'critical' %}üî¥ Critical
                                            {% elif item.Priority|lower == 'high' %}üü† High
                                            {% elif item.Priority|lower == 'medium' %}üü° Medium
                                            {% elif item.Priority|lower == 'low' %}‚ö™ Low
                                            {% else %}{{ item.Priority|title }}{% endif %}
                                        </span>
                                   {% endif %}
                                   
                                   <!-- State Badge (clickable) with dropdown inside -->
                                   <span class="state-badge state-{{ (item.State or 'NEW')|lower }}"
                                         data-feedback-id="{{ item.Feedback_ID or '' }}"
                                         data-current-state="{{ item.State or 'NEW' }}"
                                         onclick="toggleStateDropdown(this, event)"
                                         title="Click to change state">
                                       {% set state = item.State or 'NEW' %}
                                       {% if state == 'NEW' %}üÜï New
                                       {% elif state == 'TRIAGED' %}üîç Triaged
                                       {% elif state == 'CLOSED' %}‚úÖ Closed
                                       {% elif state == 'IRRELEVANT' %}‚ùå Irrelevant
                                       {% else %}{{ state }}{% endif %}
                                       <div class="state-dropdown" data-feedback-id="{{ item.Feedback_ID or '' }}">
                                           <div class="state-option" data-state="NEW">üÜï New</div>
                                           <div class="state-option" data-state="TRIAGED">üîç Triaged</div>
                                           <div class="state-option" data-state="CLOSED">‚úÖ Closed</div>
                                           <div class="state-option" data-state="IRRELEVANT">‚ùå Irrelevant</div>
                                       </div>
                                   </span>
                                   
                                   {% if item.Last_Updated and item.Last_Updated|trim != '' %}
                                   <small class="text-muted">
                                       Updated: {{ item.Last_Updated.split('T')[0] }}
                                       {% if item.Updated_By and item.Updated_By|trim != '' %} by {{ item.Updated_By }}{% endif %}
                                   </small>
                                   {% endif %}
                               </div>
                           </div>
                           
                           <!-- State Notes Display -->
                           {% if item.Feedback_Notes and item.Feedback_Notes|trim != '' %}
                           <div class="notes-display bg-light p-2 rounded border-start border-3 border-primary mb-3 small">
                               üìù {{ item.Feedback_Notes }}
                           </div>
                           {% endif %}
                           
                           <div class="category-info mb-3 small text-muted interactive-categories">
                               <span class="text-uppercase fw-bold text-muted me-2" style="font-size: 0.65rem; letter-spacing: 1px;">Category</span>
                               {% if item.Categorization_Confidence %}
                                   <i class="bi bi-info-circle me-2 text-muted" style="font-size: 0.75rem; cursor: help;" title="Confidence: {{ (item.Categorization_Confidence * 100)|round|int }}%"></i>
                               {% endif %}
                               <span class="category-chip"
                                 data-category-feedback-id="{{ item.Feedback_ID or '' }}"
                                     data-category-name="{{ (item.Enhanced_Category or '')|e }}"
                                     data-subcategory-name="{{ (item.Subcategory or '')|e }}"
                                     data-feature-area="{{ (item.Feature_Area or '')|e }}"
                                     data-domain-code="{{ item.Primary_Domain or '' }}"
                                     onclick="showCategoryPickerFromElement(this)"
                                     title="Click to update category">
                                   {% if item.Enhanced_Category and item.Enhanced_Category|trim != '' %}
                                       {{ item.Enhanced_Category }}
                                   {% else %}
                                       Set category
                                   {% endif %}
                               </span>
                             <span class="subcategory-chip{% if not item.Subcategory or item.Subcategory|trim == '' %} subcategory-empty{% endif %}"
                                 data-category-feedback-id="{{ item.Feedback_ID or '' }}"
                                     data-category-name="{{ (item.Enhanced_Category or '')|e }}"
                                     data-subcategory-name="{{ (item.Subcategory or '')|e }}"
                                     data-feature-area="{{ (item.Feature_Area or '')|e }}"
                                     data-domain-code="{{ item.Primary_Domain or '' }}"
                                     onclick="showCategoryPickerFromElement(this)"
                                     title="Click to update subcategory">
                                   {% if item.Subcategory and item.Subcategory|trim != '' %}
                                       {{ item.Subcategory }}
                                   {% else %}
                                       Add subcategory
                                   {% endif %}
                               </span>
                               {% set domain_code = item.Primary_Domain or '' %}
                               {% set domain_display = domain_names.get(item.Primary_Domain, item.Primary_Domain) if domain_code else '‚ùì Uncategorized' %}
                               <span class="domain-badge"
                                     style="background-color: {{ domain_colors.get(domain_code, '#6c757d') }};"
                                     title="Click to update domain"
                                     data-domain-code="{{ domain_code }}"
                                     data-domain-name="{{ domain_display }}"
                                     data-category-feedback-id="{{ item.Feedback_ID or '' }}"
                                     data-category-name="{{ (item.Enhanced_Category or '')|e }}"
                                     data-subcategory-name="{{ (item.Subcategory or '')|e }}"
                                     data-feature-area="{{ (item.Feature_Area or '')|e }}"
                                     onclick="showCategoryPickerFromElement(this)">
                                   {{ domain_display }}
                               </span>
                           </div>
                           
                           <!-- Domain Information removed: domain badge now inline with category -->
                           
                            <p class="card-text feedback-content mb-auto text-secondary" onclick="showFeedbackDetail(this)" title="Click to read full feedback">
                                {{ item.Feedback }}
                            </p>
                            <div class="mt-auto pt-3 d-flex align-items-center flex-wrap gap-2"> {# Push button to bottom #}
                                {% if item.Url and item.Url|trim != '' %}
                                    <a href="{{ item.Url }}" class="fluent-button fluent-button-secondary" target="_blank" rel="noopener noreferrer" style="min-height: 32px; padding: 4px 12px;">View Source</a>
                                {% endif %}
                                {% if item.Tag and item.Tag|trim != '' %}
                                    <span class="fluent-badge fluent-badge-secondary" title="Source Tag: {{ item.Tag }}"><i class="bi bi-tag-fill me-1"></i>{{ item.Tag }}</span>
                                {% endif %}
                                {% if item.Sentiment and item.Sentiment|trim != '' %}
                                    {% if item.Sentiment == 'Positive' %}
                                        <span class="fluent-badge fluent-badge-success" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòä {{ item.Sentiment }}</span>
                                    {% elif item.Sentiment == 'Negative' %}
                                        <span class="fluent-badge fluent-badge-error" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòû {{ item.Sentiment }}</span>
                                    {% else %}
                                        <span class="fluent-badge fluent-badge-secondary" title="Sentiment: {{ item.Sentiment }}{% if item.Sentiment_Score %} (Score: {{ item.Sentiment_Score }}){% endif %}{% if item.Sentiment_Confidence %} - Confidence: {{ item.Sentiment_Confidence }}{% endif %}">üòê {{ item.Sentiment }}</span>
                                    {% endif %}
                                {% endif %}
                                {% if item.Matched_Keywords and item.Matched_Keywords|length > 0 %}
                                    <span class="keyword-tags d-inline-flex align-items-center gap-1">
                                        <span class="keyword-label small text-muted fw-bold">üîë Keywords:</span>
                                        {% for keyword in item.Matched_Keywords[:3] %}
                                            <span class="fluent-badge fluent-badge-secondary" style="background: #e1dfdd; color: #323130;">{{ keyword }}</span>
                                        {% endfor %}
                                        {% if item.Matched_Keywords|length > 3 %}
                                            <span class="fluent-badge fluent-badge-primary" title="{{ item.Matched_Keywords[3:]|join(', ') }}">+{{ item.Matched_Keywords|length - 3 }} more</span>
                                        {% endif %}
                                    </span>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div> <!-- End of feedback grid -->
            </div> <!-- End of feedback-container -->
        {% else %}
            <div class="fluent-alert fluent-alert-info">No feedback data to display. Try collecting feedback first.</div>
        {% endif %}

    </div> <!-- End of container-custom -->
    <script>
        // Global variables
        let bearerToken = null;
        let stateManagementEnabled = false;
        let cachedStateChanges = {};
        let hasUnsavedChanges = false;
        let fabricConnected = false;
        let fabricStateData = {};
        
        // Modern Filter System
        let modernFilterSystem = null;
        
        // Initialize Modern Filter System when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the modern filter system
            modernFilterSystem = new ModernFilterSystem({
                apiEndpoint: '/api/feedback/filtered',
                containerId: 'feedback-container',
                loadingId: 'filter-loading',
                errorId: 'filter-error',
                errorMessageId: 'filter-error-message'
            });
            
            console.log('üîß Modern Filter System initialized');
        });
        
        // Override any existing updateDomain function with fixed version
        function updateDomain(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è Domain update requested: ${feedbackId} ‚Üí current: ${currentDomain}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            console.log('üîç Connection check:', {
                stateManagementEnabled,
                hasStateData: !!hasStateData,
                urlIndicatesConnection,
                fabricConnected
            });
            
            // Allow if ANY connection indicator is present
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected) {
                console.log('‚ùå No connection indicators found - showing alert');
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            console.log('‚úÖ Connection check passed - showing domain dropdown');
            // Create domain dropdown
            showDomainDropdown(feedbackId, currentDomain);
        }
        
        // Override any existing updateNotes function
        function updateNotes(feedbackId, currentNotes) {
            console.log(`üìù Notes update requested: ${feedbackId}`);
            
            // Same connection check as domain update
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Simple prompt for notes (can be enhanced later)
            const newNotes = prompt('Enter notes for this feedback:', currentNotes || '');
            if (newNotes !== null) {
                // Save notes to database
                console.log(`üíæ Saving notes for ${feedbackId}: ${newNotes}`);
                
                fetch('/api/feedback/notes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        feedback_id: feedbackId,
                        notes: newNotes
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        console.log('‚úÖ Notes updated successfully');
                        // Update the UI immediately
                        updateNotesDisplay(feedbackId, newNotes);
                        // Show success message
                        showToastMessage('Notes updated successfully', 'success');
                        // Reload page to reflect changes
                        setTimeout(() => window.location.reload(), 1000);
                    } else {
                        console.error('‚ùå Error updating notes:', data.message);
                        alert('Error updating notes: ' + data.message);
                    }
                })
                .catch(error => {
                    console.error('‚ùå Network error updating notes:', error);
                    alert('Network error updating notes. Please try again.');
                });
            }
        }
        
        // Helper function to show toast messages
        function showToastMessage(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            const alertType = type === 'danger' ? 'error' : type;
            toast.className = `fluent-alert fluent-alert-${alertType} position-fixed`;
            toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; box-shadow: var(--shadow-depth-16);';
            toast.innerHTML = `
                <div class="d-flex align-items-center justify-content-between w-100">
                    <div>${message}</div>
                    <button type="button" class="fluent-button-icon" onclick="this.closest('.fluent-alert').remove()">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(toast);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 3000);
        }
        
        // Helper function to update notes display in UI
        function updateNotesDisplay(feedbackId, notes) {
            // Find the feedback card and update notes display
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.fluent-card-body') : null;
            
            if (card) {
                // Look for existing notes display
                let notesDisplay = card.querySelector('.notes-display');
                
                if (notes && notes.trim() !== '') {
                    if (!notesDisplay) {
                        // Create new notes display
                        notesDisplay = document.createElement('div');
                        notesDisplay.className = 'notes-display';
                        
                        // Insert after the category info section
                        const categoryInfo = card.querySelector('.category-info');
                        if (categoryInfo && categoryInfo.nextSibling) {
                            categoryInfo.parentNode.insertBefore(notesDisplay, categoryInfo.nextSibling);
                        } else {
                            card.appendChild(notesDisplay);
                        }
                    }
                    notesDisplay.innerHTML = `üìù ${notes}`;
                } else if (notesDisplay) {
                    // Remove notes display if notes are empty
                    notesDisplay.remove();
                }
            }
        }
        
        // Preserve connection state in localStorage
        function saveFabricConnectionState() {
            localStorage.setItem('fabricConnected', fabricConnected);
            localStorage.setItem('stateManagementEnabled', stateManagementEnabled);
            localStorage.setItem('fabricDataSynced', 'true'); // Mark that actual data sync completed
        }
        
        function loadFabricConnectionState() {
            // IMPROVED: Check backend session state via API instead of relying only on localStorage
            console.log('üîÑ Checking backend session state via API');
            
            // Call API to check session state
            fetch('/api/session_state')
                .then(response => response.json())
                .then(sessionData => {
                    console.log('üì° Backend session state:', sessionData);
                    
                    // Enable state management if backend confirms Fabric SQL connection OR bearer token
                    if (sessionData.fabric_sql_connected || sessionData.has_bearer_token) {
                        console.log('üîë Backend confirms Fabric connection - enabling state management');
                        fabricConnected = true;
                        window.fabricConnected = true;
                        stateManagementEnabled = true;
                        window.stateManagementEnabled = true;
                        
                        // Update UI to reflect connected state
                        if (document.body && document.body.classList) {
                            document.body.classList.remove('state-management-disabled');
                        }
                        
                        // Update connection UI elements
                        updateConnectionUI();
                        
                        // Hide token banner since connection is established
                        const tokenBanner = document.getElementById('tokenBanner');
                        if (tokenBanner && tokenBanner.classList) {
                            tokenBanner.classList.add('hidden');
                        }
                        
                        console.log('‚úÖ Fabric connection state restored from backend session');
                    } else {
                        console.log('‚ÑπÔ∏è No backend Fabric connection found - state management disabled');
                        fabricConnected = false;
                        stateManagementEnabled = false;
                        
                        // Clear any stale localStorage
                        localStorage.removeItem('fabricConnected');
                        localStorage.removeItem('stateManagementEnabled');
                        localStorage.removeItem('fabricDataSynced');
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error checking backend session state:', error);
                    console.log('‚ÑπÔ∏è Falling back to template variables for connection state');
                    
                    // Fallback to template-based detection
                    const sessionToken = '{{ stored_token or "" }}';
                    const fabricSqlConnected = '{{ fabric_sql_connected|lower }}' === 'true';
                    
                    if (fabricSqlConnected || (sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None')) {
                        console.log('üéØ Template confirms Fabric connection - enabling state management');
                        fabricConnected = true;
                        window.fabricConnected = true;
                        stateManagementEnabled = true;
                        window.stateManagementEnabled = true;
                        
                        if (document.body && document.body.classList) {
                            document.body.classList.remove('state-management-disabled');
                        }
                        
                        updateConnectionUI();
                    }
                });
        }
        
        function updateConnectionUI() {
            // Try multiple times with delays to handle DOM loading
            let attempts = 0;
            const maxAttempts = 10;
            
            function tryUpdate() {
                attempts++;
                const syncBtn = document.getElementById('fabricSyncBtn');
                const badge = document.getElementById('fabricSyncBadge');
                
                console.log(`üîÑ Updating connection UI (attempt ${attempts}):`, {
                    fabricConnected,
                    syncBtn: !!syncBtn,
                    badge: !!badge
                });
                
                if (fabricConnected && syncBtn && syncBtn.classList) {
                    // Update sync button - always use btn-primary styling for consistency
                    syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric <span class="fluent-badge fluent-badge-success ms-1" id="fabricSyncBadge">Connected</span>';
                    syncBtn.className = 'fluent-button fluent-button-primary ms-2'; // Force btn-primary styling
                    console.log('‚úÖ Updated sync button to connected state with btn-primary styling');
                    
                    // Badge is now handled inline in the button text above
                    console.log('‚úÖ Badge included inline in button text');
                    
                    // Enable state management (critical - must work even without badge)
                    stateManagementEnabled = true;
                    if (document.body && document.body.classList) {
                        document.body.classList.remove('state-management-disabled');
                    }
                    console.log('‚úÖ State management enabled');
                    
                    // Save state for future page loads
                    saveFabricConnectionState();
                    
                } else if (attempts < maxAttempts && fabricConnected) {
                    // Sync button not found, try again
                    console.log(`‚è≥ Sync button not found, retrying in ${50 * attempts}ms...`);
                    setTimeout(tryUpdate, 50 * attempts);
                } else if (fabricConnected) {
                    // Fallback: Enable state management even if UI elements are missing
                    console.warn('‚ö†Ô∏è Could not find sync button after', maxAttempts, 'attempts');
                    console.log('üîß Enabling state management anyway (fallback mode)');
                    stateManagementEnabled = true;
                    if (document.body && document.body.classList) {
                        document.body.classList.remove('state-management-disabled');
                    }
                }
            }
            
            tryUpdate();
        }
        
        // Check state management initialization
        const sessionToken = '{{ stored_token or "" }}';  // Bearer token for lakehouse writes
        const statesLoaded = '{{ states_already_loaded|lower }}' === 'true';  // Based on Fabric SQL connection
        const fabricSqlConnected = '{{ fabric_sql_connected|lower }}' === 'true';  // Explicit SQL connection state
        
        console.log('State management check:', {
            sessionToken: sessionToken ? 'Present' : 'None', 
            statesLoaded: statesLoaded,
            fabricSqlConnected: fabricSqlConnected
        });
        
        // Auto-enable state management if Fabric SQL is connected (not based on bearer token)
        // BALANCED CONNECTION DETECTION: Check both fresh connections and existing sessions
        // Trust backend session validation while being conservative about false positives
        const hasValidToken = sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None';
        const hasUrlConnection = new URLSearchParams(window.location.search).get('fabric_connected') === 'true';
        
        // BALANCED APPROACH: Enable if backend confirms SQL connection OR fresh connection with token
        // This preserves sessions on refresh while preventing false positives
        if (fabricSqlConnected && hasValidToken) {
            console.log('‚úÖ Enabling state management: VERIFIED Fabric SQL connection + bearer token confirmed');
            fabricConnected = true;
            stateManagementEnabled = true;
            window.fabricConnected = true;
            window.stateManagementEnabled = true;
            
            // Update UI to reflect connected state
            if (document.body && document.body.classList) {
                document.body.classList.remove('state-management-disabled');
            }
            
            // Hide token banner since it's already provided
            const tokenBanner = document.getElementById('tokenBanner');
            if (tokenBanner && tokenBanner.classList) {
                tokenBanner.classList.add('hidden');
            }
            
            // Show brief session message (only if not already shown)
            if (!sessionStorage.getItem('sessionMessageShown')) {
                const sessionMsg = document.createElement('div');
                sessionMsg.className = 'alert alert-success alert-dismissible fade show';
                sessionMsg.innerHTML = `
                    <strong>‚úÖ State management active</strong> - Connected to Fabric
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                const container = document.querySelector('.fluent-container');
                const filterSection = document.querySelector('#filter-section-container');
                if (container && filterSection) {
                    container.insertBefore(sessionMsg, filterSection);
                } else if (container) {
                    container.appendChild(sessionMsg);
                }
                sessionStorage.setItem('sessionMessageShown', 'true');
                setTimeout(() => {
                    if (sessionMsg.parentNode) sessionMsg.remove();
                }, 3000);
            }
        } else if (hasValidToken) {
            // Token exists but backend doesn't confirm full connection - limited functionality
            console.log('üîë Partial connection: Bearer token exists but not fully connected - enabling domain updates only');
            fabricConnected = false;  // Don't show as fully connected
            stateManagementEnabled = true;  // But allow domain updates
            
            // Don't show success message for partial connections
        } else {
            console.log('üîë No valid connection found - state management disabled');
            console.log('üîç Connection check details:', {
                fabricSqlConnected: fabricSqlConnected,
                hasValidToken: hasValidToken,
                hasUrlConnection: hasUrlConnection,
                sessionToken: sessionToken ? 'Present' : 'None'
            });
            
            // No valid connection means no Fabric connection
            fabricConnected = false;
            stateManagementEnabled = false;
            
            // Disable state management UI
            if (document.body && document.body.classList) {
                document.body.classList.add('state-management-disabled');
            }
            
            // Clear any stale localStorage connection flags
            localStorage.removeItem('fabricConnected');
            localStorage.removeItem('stateManagementEnabled');
            localStorage.removeItem('fabricDataSynced');
            
            // Update status display
            if (typeof updateFeedbackStatusDisplay === 'function') {
                updateFeedbackStatusDisplay();
            }
        }
        
        // Apply cached changes to UI on page load
        applyCachedChangesToUI();
        
        // Apply cached changes to displayed feedback
        function applyCachedChangesToUI() {
            const cached = localStorage.getItem('feedbackStateChanges');
            if (!cached) {
                console.log('üíæ No cached changes found');
                return;
            }
            
            try {
                const changes = JSON.parse(cached);
                const changeCount = Object.keys(changes).length;
                console.log(`üíæ Applying ${changeCount} cached changes to UI`);
                
                Object.keys(changes).forEach(feedbackId => {
                    const change = changes[feedbackId];
                    updateUIFromCache(feedbackId, change);
                });
                
                // Show sync button if there are cached changes and state management is enabled
                if (changeCount > 0) {
                    updateSyncButton();
                }
                
            } catch (e) {
                console.error('Error applying cached changes:', e);
                localStorage.removeItem('feedbackStateChanges');
            }
        }
        
        // Update UI elements from cached data
        function updateUIFromCache(feedbackId, change) {
            console.log(`üíæ Updating UI for ${feedbackId}:`, change);
            
            // Update state if cached
            if (change.state) {
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                if (stateBadge) {
                    const stateNames = {
                        'NEW': 'üÜï New',
                        'TRIAGED': 'üîç Triaged',
                        'CLOSED': '‚úÖ Closed',
                        'IRRELEVANT': '‚ùå Irrelevant'
                    };
                    stateBadge.textContent = stateNames[change.state] || change.state;
                    stateBadge.className = `state-badge state-${change.state.toLowerCase()}`;
                    stateBadge.setAttribute('data-current-state', change.state);
                    console.log(`‚úÖ Updated state badge for ${feedbackId} to ${change.state}`);
                }
            }
            
            // Update domain if cached
            if (change.domain) {
                updateDomainDisplayFromCache(feedbackId, change.domain);
            }
            
            // Update notes if cached
            if (change.notes) {
                updateNotesDisplay(feedbackId, change.notes);
            }
        }
        
        // Update domain display from cache
        function updateDomainDisplayFromCache(feedbackId, domain) {
            const domainNames = {
                'GETTING_STARTED': 'Getting Started',
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.fluent-card-body') : null;
            if (card) {
                const domainBadges = card.querySelectorAll('.domain-badge');
                if (domainBadges.length > 0) {
                    domainBadges[0].textContent = domainNames[domain] || domain;
                    console.log(`‚úÖ Updated domain for ${feedbackId} to ${domainNames[domain]}`);
                }
            }
        }
        
        // Enable state management when token is provided manually
        const enableStateBtn = document.getElementById('enableStateManagement');
        if (enableStateBtn && enableStateBtn.addEventListener) {
            enableStateBtn.addEventListener('click', function() {
            const token = document.getElementById('bearerToken').value.trim();
            if (!token) {
                alert('Please enter a valid bearer token');
                return;
            }
            
            bearerToken = token;
            
            // First, store token in session for persistence across navigation
            fetch('/api/store_session_token', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({token: token})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('üîë Token stored in session successfully');
                    
                    // Now load states from Fabric Lakehouse
                    loadStatesFromFabric(token);
                } else {
                    alert('Error storing token: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error storing token:', error);
                // Continue with state loading even if session storage fails
                loadStatesFromFabric(token);
            });
        });
        }
        
        // Load actual states from Fabric Lakehouse
        function loadStatesFromFabric(token) {
            // Get all feedback IDs from the page
            const feedbackIds = [];
            document.querySelectorAll('[data-feedback-id]').forEach(element => {
                const id = element.getAttribute('data-feedback-id');
                if (id && !feedbackIds.includes(id)) {
                    feedbackIds.push(id);
                }
            });
            
            if (feedbackIds.length === 0) {
                enableStateManagement();
                return;
            }
            
            // Show loading message
            const loadingMsg = document.createElement('div');
            loadingMsg.id = 'loadingMsg';
            loadingMsg.className = 'alert alert-info';
            loadingMsg.innerHTML = 'üîÑ Loading states from Fabric Lakehouse...';
            document.querySelector('.fluent-container').insertBefore(loadingMsg, document.querySelector('#filter-section-container'));
            
            fetch('/api/feedback/states/load', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': token
                },
                body: JSON.stringify({
                    feedback_ids: feedbackIds
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Update feedback cards with actual states from Fabric
                    updateFeedbackStatesFromFabric(data.states);
                    
                    // Load cached changes from localStorage
                    loadCachedChanges();
                    
                    // Enable state management
                    enableStateManagement();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `‚úÖ Loaded ${Object.keys(data.states).length} feedback states from Fabric Lakehouse`;
                    document.querySelector('.fluent-container').insertBefore(successMsg, document.querySelector('#filter-section-container'));
                    setTimeout(() => successMsg.remove(), 5000);
                } else {
                    alert('Error loading states: ' + data.message);
                }
                
                // Remove loading message
                const loading = document.getElementById('loadingMsg');
                if (loading) loading.remove();
            })
            .catch(error => {
                alert('Error loading states: ' + error.message);
                const loading = document.getElementById('loadingMsg');
                if (loading) loading.remove();
            });
        }
        
        // Update feedback cards with states loaded from Fabric
        function updateFeedbackStatesFromFabric(fabricStates) {
            Object.keys(fabricStates).forEach(feedbackId => {
                const stateData = fabricStates[feedbackId];
                
                // Update state badge
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                if (stateBadge) {
                    const stateNames = {
                        'NEW': 'üÜï New',
                        'TRIAGED': 'üîç Triaged',
                        'CLOSED': '‚úÖ Closed',
                        'IRRELEVANT': '‚ùå Irrelevant'
                    };
                    
                    stateBadge.textContent = stateNames[stateData.State] || stateData.State;
                    stateBadge.className = `state-badge state-${stateData.State.toLowerCase()}`;
                    stateBadge.setAttribute('data-current-state', stateData.State);
                }
                
                // Update notes display (if notes exist)
                if (stateData.Feedback_Notes && stateData.Feedback_Notes.trim() !== '') {
                    // Find or create notes display
                    const card = stateBadge ? stateBadge.closest('.fluent-card-body') : null;
                    if (card) {
                        let notesDisplay = card.querySelector('.notes-display');
                        if (!notesDisplay) {
                            notesDisplay = document.createElement('div');
                            notesDisplay.className = 'notes-display';
                            // Insert after state management section
                            const stateSection = card.querySelector('.category-info');
                            if (stateSection) {
                                stateSection.parentNode.insertBefore(notesDisplay, stateSection.nextSibling);
                            }
                        }
                        notesDisplay.innerHTML = `üìù ${stateData.Feedback_Notes}`;
                    }
                }
            });
        }
        
        // Enable state management UI
        function enableStateManagement() {
            stateManagementEnabled = true;
            
            // Hide token banner
            document.getElementById('tokenBanner').classList.add('hidden');
            
            // Enable state management UI
            document.body.classList.remove('state-management-disabled');
            
            // Show sync button if there are cached changes
            updateSyncButton();
        }
        
        // Load cached changes from localStorage
        function loadCachedChanges() {
            const cached = localStorage.getItem('feedbackStateChanges');
            if (!cachedStateChanges[feedbackId]) {
                cachedStateChanges[feedbackId] = {};
            }
            
            Object.assign(cachedStateChanges[feedbackId], changeData);
            cachedStateChanges[feedbackId].feedback_id = feedbackId;
            
            // Save to localStorage
            localStorage.setItem('feedbackStateChanges', JSON.stringify(cachedStateChanges));
            
            hasUnsavedChanges = true;
            updateSyncButton();
        }
        
        // Update sync button visibility and state
        function updateSyncButton() {
            let syncButton = document.getElementById('syncToFabricBtn');
            
            if (hasUnsavedChanges && stateManagementEnabled) {
                if (!syncButton) {
                    // Create sync button
                    syncButton = document.createElement('div');
                    syncButton.id = 'syncToFabricBtn';
                    syncButton.className = 'alert alert-warning d-flex justify-content-between align-items-center';
                    syncButton.innerHTML = `
                        <span>üíæ You have unsaved state changes</span>
                        <button class="btn btn-primary" onclick="syncToFabric()">Sync to Fabric</button>
                    `;
                    document.querySelector('.fluent-container').insertBefore(syncButton, document.querySelector('#filter-section-container'));
                }
                
                // Update count
                const changeCount = Object.keys(cachedStateChanges).length;
                syncButton.querySelector('span').textContent = `üíæ You have ${changeCount} unsaved state change${changeCount !== 1 ? 's' : ''}`;
            } else if (syncButton) {
                syncButton.remove();
            }
        }
        
        // Sync cached changes to Fabric
        function syncToFabric() {
            if (!bearerToken || !hasUnsavedChanges) return;
            
            const stateChanges = Object.values(cachedStateChanges);
            
            // Show syncing message
            const syncBtn = document.getElementById('syncToFabricBtn');
            if (syncBtn) {
                syncBtn.innerHTML = 'üîÑ Syncing to Fabric...';
            }
            
            fetch('/api/feedback/states/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': bearerToken
                },
                body: JSON.stringify({
                    state_changes: stateChanges
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Clear cache
                    cachedStateChanges = {};
                    hasUnsavedChanges = false;
                    localStorage.removeItem('feedbackStateChanges');
                    
                    // Update UI
                    updateSyncButton();
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `‚úÖ Successfully synced ${data.updated_count} state changes to Fabric`;
                    document.querySelector('.fluent-container').insertBefore(successMsg, document.querySelector('#filter-section-container'));
                    setTimeout(() => successMsg.remove(), 5000);
                } else {
                    alert('Error syncing to Fabric: ' + data.message);
                    // Restore sync button
                    updateSyncButton();
                }
            })
            .catch(error => {
                alert('Error syncing to Fabric: ' + error.message);
                // Restore sync button
                updateSyncButton();
            });
        }
        
        // New SQL-based sync with Fabric function
        function syncWithFabric() {
            console.log('üîÑ Starting Fabric SQL sync process...');
            
            // Update button state
            const syncBtn = document.getElementById('fabricSyncBtn');
            const badge = document.getElementById('fabricSyncBadge');
            
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Connecting...';
            }
            
            // Call new API endpoint
            fetch('/api/fabric/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('‚úÖ Successfully connected to Fabric SQL database');
                    console.log('üìä Loaded state data:', data.state_data);
                    
                    // Store state data globally
                    fabricStateData = data.state_data;
                    fabricConnected = true;
                    window.fabricConnected = true;
                    
                    // Save connection state to localStorage
                    saveFabricConnectionState();
                    
                    // Update UI with loaded state data
                    updateFeedbackWithSQLData(data.state_data);
                    
                    // Enable state management
                    enableStateManagementSQL();
                    
                    // Update status display
                    if (typeof updateFeedbackStatusDisplay === 'function') {
                        updateFeedbackStatusDisplay();
                    }
                    
                    // Update button - ensure btn-primary styling for consistency
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.className = 'btn btn-primary ms-2'; // Force btn-primary styling
                        syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric <span class="badge bg-success ms-1">Connected</span>';
                    }
                    
                    // Show domain sync button after successful fabric sync
                    const domainSyncBtn = document.getElementById('domainSyncBtn');
                    if (domainSyncBtn) {
                        domainSyncBtn.style.display = 'inline-block';
                        console.log('‚úÖ Domain sync button enabled');
                    }
                    
                    // Badge is now handled inline in the button text above
                    
                    // Show comprehensive success message with smart sync details
                    const syncResult = data.sync_result || {};
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success';
                    successMsg.innerHTML = `
                        ‚úÖ <strong>Fabric SQL Sync Complete!</strong><br>
                        üìù Added ${syncResult.new_items || 0} new feedback items (${syncResult.existing_items || 0} already existed)<br>
                        üîÑ Loaded ${Object.keys(data.state_data).length} state records from FeedbackState table<br>
                        <small class="text-muted">Smart sync: Only new items were written to avoid duplicates</small>
                    `;
                    document.querySelector('.fluent-container').insertBefore(successMsg, document.querySelector('#filter-section-container'));
                    
                    // CRITICAL FIX: Redirect to include fabric_connected parameter for session persistence
                    setTimeout(() => {
                        const currentUrl = new URL(window.location);
                        currentUrl.searchParams.set('fabric_connected', 'true');
                        console.log('üîÑ Redirecting to set fabric_connected parameter for session persistence...');
                        window.location.href = currentUrl.toString();
                    }, 2000);
                    setTimeout(() => successMsg.remove(), 10000);
                    
                } else {
                    console.error('‚ùå Failed to connect to Fabric SQL database:', data.message);
                    alert('Failed to connect to Fabric SQL database: ' + data.message);
                    
                    // Reset button
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric';
                    }
                }
            })
            .catch(error => {
                console.error('‚ùå Error connecting to Fabric SQL:', error);
                alert('Error connecting to Fabric SQL database: ' + error.message);
                
                // Reset button
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric';
                }
            });
        }
        
        // Update feedback cards with SQL state data
        function updateFeedbackWithSQLData(stateData) {
            console.log(`üìä Syncing ${Object.keys(stateData).length} state records with feedback cards...`);
            
            // Clean up any duplicate domain-display elements that might exist
            document.querySelectorAll('.domain-display').forEach(element => {
                element.remove();
            });
            
            let updatedCount = 0;
            let notFoundCount = 0;
            
            Object.keys(stateData).forEach(feedbackId => {
                const state = stateData[feedbackId];
                
                // Find the state badge element specifically (not dropdown elements)
                const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                
                if (!stateBadge) {
                    // This is normal for paginated results - feedback not on current page
                    notFoundCount++;
                    return;
                }
                
                const card = stateBadge.closest('.fluent-card');
                if (!card) {
                    console.warn(`No card found for state badge:`, stateBadge);
                    notFoundCount++;
                    return;
                }
                
                // Update state badge
                if (state.state) {
                    const stateBadgeInCard = card.querySelector('[data-current-state]');
                    
                    if (stateBadgeInCard) {
                        const stateNames = {
                            'NEW': 'üÜï New',
                            'TRIAGED': 'üîç Triaged',
                            'CLOSED': '‚úÖ Closed',
                            'IRRELEVANT': '‚ùå Irrelevant'
                        };
                            
                            stateBadge.textContent = stateNames[state.state] || state.state;
                            stateBadge.className = `state-badge state-${state.state.toLowerCase()}`;
                            stateBadge.setAttribute('data-current-state', state.state);
                        }
                    }
                    
                    // Update or add notes
                    if (state.notes) {
                        let notesDisplay = card.querySelector('.notes-display');
                        if (!notesDisplay) {
                            notesDisplay = document.createElement('div');
                            notesDisplay.className = 'notes-display alert alert-info mt-2';
                            const cardBody = card.querySelector('.fluent-card-body');
                            if (cardBody) {
                                cardBody.appendChild(notesDisplay);
                            }
                        }
                        notesDisplay.innerHTML = `üìù <strong>Notes:</strong> ${state.notes}`;
                    }
                    
                    // Update domain display - use existing domain-badge only
                    if (state.domain) {
                        // Find existing domain-badge and update it
                        let domainBadge = card.querySelector('.domain-badge');
                        if (domainBadge) {
                            // Update existing domain badge
                            domainBadge.textContent = state.domain;
                        }
                    }
                    
                    updatedCount++;
            });
            
            console.log(`üìä State sync complete: Updated ${updatedCount} cards on current page (${notFoundCount} records not displayed due to pagination)`);
            
            // Store the state data globally for filtering
            window.fabricStateData = stateData;
            
            // Also persist state data to localStorage for page reload survival
            try {
                localStorage.setItem('fabricStateData', JSON.stringify(stateData));
                localStorage.setItem('fabricStateDataTime', Date.now().toString());
                console.log('üíæ State data persisted to localStorage for page reload survival');
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not persist state data to localStorage:', error);
            }
        }
        
        // Reapply state data after filtering or other operations
        function reapplyStateData() {
            if (window.fabricStateData && Object.keys(window.fabricStateData).length > 0) {
                console.log('üîÑ Reapplying state data after filtering...');
                updateFeedbackWithSQLData(window.fabricStateData);
            }
        }
        
        // Enable state management with SQL backend
        function enableStateManagementSQL() {
            stateManagementEnabled = true;
            fabricConnected = true;
            window.fabricConnected = true;
            window.stateManagementEnabled = true;  // Add this global variable
            
            // Save connection state to localStorage with timestamp
            localStorage.setItem('fabricConnected', 'true');
            localStorage.setItem('fabricStateEnabled', 'true');
            localStorage.setItem('fabricDataSynced', 'true');
            localStorage.setItem('fabricConnectionTime', Date.now().toString());
            
            // Enable all state controls
            document.querySelectorAll('.state-badge, .state-dropdown, [onclick*="updateDomain"], [onclick*="updateNotes"]').forEach(element => {
                element.style.pointerEvents = 'auto';
                element.style.opacity = '1';
                if (element.hasAttribute('disabled')) {
                    element.removeAttribute('disabled');
                }
            });
            
            // Remove the state-management-disabled class from the feedback section
            const feedbackSection = document.getElementById('feedbackSection');
            if (feedbackSection && feedbackSection.classList.contains('state-management-disabled')) {
                feedbackSection.classList.remove('state-management-disabled');
                console.log('üîì Removed state-management-disabled class from feedback section');
            }
            
            console.log('‚úÖ State management enabled with SQL backend - connection timestamp saved');
            
            // Update the status display to show Connected state
            if (typeof updateFeedbackStatusDisplay === 'function') {
                updateFeedbackStatusDisplay();
            }
        }
        
        // Test function to manually verify state loading
        function testStateLoading() {
            console.log('üß™ Testing state loading with sample data...');
            
            // Create test state data
            const testStateData = {};
            
            // Get the first few feedback IDs from the page
            const feedbackElements = document.querySelectorAll('[data-feedback-id]');
            console.log(`Found ${feedbackElements.length} feedback elements for testing`);
            
            // Apply test states to first few items
            for (let i = 0; i < Math.min(3, feedbackElements.length); i++) {
                const feedbackId = feedbackElements[i].getAttribute('data-feedback-id');
                testStateData[feedbackId] = {
                    state: i === 0 ? 'IRRELEVANT' : i === 1 ? 'TRIAGED' : 'CLOSED',
                    notes: `Test note for ${feedbackId}`,
                    domain: 'TEST_DOMAIN'
                };
            }
            
            console.log('üß™ Test state data:', testStateData);
            updateFeedbackWithSQLData(testStateData);
        }
        
        // Add global DOM observer to reapply state when cards are regenerated
        function setupStatePreservation() {
            // Store observer reference globally so we can disable/enable it
            window.stateObserver = null;
            
            // Create a mutation observer to watch for DOM changes
            const observer = new MutationObserver(function(mutations) {
                let shouldReapply = false;
                
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Only trigger for major DOM changes (new cards), not small UI changes
                        mutation.addedNodes.forEach(function(node) {
                            if (node && node.nodeType === Node.ELEMENT_NODE) {
                                // Only reapply if entire card containers are added (filtering)
                                if ((node.classList && node.classList.contains('row')) ||
                                    (node.querySelector && node.querySelector('.row'))) {
                                    shouldReapply = true;
                                }
                            }
                        });
                    }
                });
                
                if (shouldReapply && window.fabricStateData) {
                    console.log('üîÑ Major DOM change detected, reapplying state data...');
                    setTimeout(() => reapplyStateData(), 200); // Longer delay for stability
                }
            });
            
            // Start observing with reduced scope
            observer.observe(document.body, {
                childList: true,
                subtree: false  // Don't watch deep changes
            });
            
            window.stateObserver = observer;
            
            console.log('üëÅÔ∏è State preservation observer started');
        }
        
        // Check if duplicates should be hidden after recent Fabric sync
        function checkAndHideDuplicates() {
            const shouldHide = localStorage.getItem('hideDuplicatesAfterSync');
            const syncTimestamp = localStorage.getItem('syncTimestamp');
            
            console.log('üîç DEBUG: Checking duplicate hiding...', {
                shouldHide: shouldHide,
                syncTimestamp: syncTimestamp,
                currentTime: Date.now()
            });
            
            // Only hide if sync was recent (within last 10 minutes)
            const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
            
            if (shouldHide === 'true' && syncTimestamp && parseInt(syncTimestamp) > tenMinutesAgo) {
                console.log('üîÑ Hiding duplicate items after recent Fabric sync...');
                
                // Get stored IDs from server
                fetch('/api/fabric/stored_ids')
                    .then(response => {
                        console.log('üì° API response:', response);
                        return response.json();
                    })
                    .then(data => {
                        console.log('üìä Stored IDs data:', data);
                        if (data.status === 'success' && data.stored_ids) {
                            hideDuplicateCards(data.stored_ids);
                            showDuplicateHiddenMessage(data.total_stored, data.total_collected);
                        } else {
                            console.error('‚ùå API returned error:', data);
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Error getting stored IDs:', error);
                    });
                
                // Clear the flag after processing
                localStorage.removeItem('hideDuplicatesAfterSync');
                localStorage.removeItem('syncTimestamp');
            } else {
                console.log('‚è∏Ô∏è Not hiding duplicates:', {
                    shouldHide: shouldHide,
                    hasTimestamp: !!syncTimestamp,
                    isRecent: syncTimestamp ? parseInt(syncTimestamp) > tenMinutesAgo : false
                });
            }
        }
        
        // Manual function to test hiding (for debugging)
        function testHideDuplicates() {
            console.log('üß™ Testing duplicate hiding manually...');
            fetch('/api/fabric/stored_ids')
                .then(response => response.json())
                .then(data => {
                    console.log('üìä Manual test data:', data);
                    if (data.status === 'success' && data.stored_ids) {
                        console.log('üìã Stored IDs:', data.stored_ids);
                        console.log('üìã Total stored:', data.total_stored);
                        console.log('üìã Total collected:', data.total_collected);
                        
                        if (data.stored_ids.length === 0) {
                            console.log('‚ö†Ô∏è No stored IDs found - you need to write data to Fabric SQL first!');
                            alert('No stored IDs found.\n\n"Connected to Fabric" means your authentication token is valid, but no feedback data has been written to the SQL database yet.\n\nTo write data:\n1. Go to the home page\n2. Click "Write to Fabric"\n3. Wait for sync to complete\n4. Then return here to test duplicate filtering');
                            return;
                        }
                        
                        hideDuplicateCards(data.stored_ids);
                        showDuplicateHiddenMessage(data.total_stored, data.total_collected);
                    } else {
                        console.error('‚ùå API returned error:', data);
                        alert('Error: ' + (data.message || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('‚ùå Manual test error:', error);
                    alert('Network error: ' + error.message);
                });
        }
        
        // Hide cards for items not in stored IDs list
        function hideDuplicateCards(storedIds) {
            const cards = document.querySelectorAll('.fluent-card');
            let hiddenCount = 0;
            let processedIds = new Set(); // Track which IDs we've already processed
            
            cards.forEach(card => {
                const feedbackIdElement = card.querySelector('[data-feedback-id]');
                if (feedbackIdElement) {
                    const feedbackId = feedbackIdElement.getAttribute('data-feedback-id');
                    
                    // Skip if we've already processed this ID or if ID is empty
                    if (!feedbackId || processedIds.has(feedbackId)) {
                        return;
                    }
                    
                    processedIds.add(feedbackId);
                    
                    // Hide card if ID is NOT in stored IDs (showing only stored items)
                    if (!storedIds.includes(feedbackId)) {
                        card.style.display = 'none';
                        card.classList.add('duplicate-hidden');
                        hiddenCount++;
                        console.log(`üîí Hiding duplicate card with ID: ${feedbackId}`);
                    } else {
                        console.log(`‚úÖ Keeping stored item with ID: ${feedbackId}`);
                    }
                }
            });
            
            console.log(`‚úÖ Hidden ${hiddenCount} duplicate cards out of ${processedIds.size} unique items`);
        }
        
        // Show message about hidden duplicates
        function showDuplicateHiddenMessage(storedCount, totalCount) {
            const hiddenCount = totalCount - storedCount;
            if (hiddenCount > 0) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'alert alert-info alert-dismissible fade show';
                messageDiv.innerHTML = `
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Duplicate filtering active:</strong> Showing ${storedCount} items stored in Fabric.
                    ${hiddenCount} duplicate items are hidden.
                    <button type="button" class="btn btn-link btn-sm ms-2" onclick="showAllCards()">Show All</button>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                
                // Insert at top of container
                const container = document.querySelector('.fluent-container');
                if (container && container.firstChild) {
                    container.insertBefore(messageDiv, container.firstChild);
                }
            }
        }
        
        // Function to show all cards again
        function showAllCards() {
            const hiddenCards = document.querySelectorAll('.fluent-card.duplicate-hidden');
            hiddenCards.forEach(card => {
                card.style.display = 'block';
                card.classList.remove('duplicate-hidden');
            });
            
            // Remove the alert message
            const alertDiv = document.querySelector('.alert-info');
            if (alertDiv) {
                alertDiv.remove();
            }
            
            console.log(`‚úÖ Restored ${hiddenCards.length} hidden cards`);
        }
        
        // Initialize page - enable state management if connection is available
        if (document && document.addEventListener) {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('üîÑ DOM ready, initializing page...');
                
                // Load saved connection state from backend session
                loadFabricConnectionState();
                
                // Check if duplicates should be hidden after recent Fabric sync
                checkAndHideDuplicates();
            
            // Setup state preservation
            try {
                setupStatePreservation();
            } catch (error) {
                console.error('‚ùå Error setting up state preservation:', error);
            }
            
            // Check if state management should be enabled immediately
            const sessionToken = '{{ stored_token or "" }}';  // Bearer token for lakehouse writes only
            const fabricConnectedParam = {% if fabric_connected_param %}true{% else %}false{% endif %};
            // Use the fabricSqlConnected variable from above instead of redeclaring
            const savedConnected = localStorage.getItem('fabricConnected');
            const savedDataSynced = localStorage.getItem('fabricDataSynced');
            const lastConnectionTime = localStorage.getItem('fabricConnectionTime');
            
            // Check if we have Fabric SQL connection OR fabric_connected URL parameter
            if (fabricSqlConnected) {
                console.log('ÔøΩ Fabric SQL connection active - enabling state management from session');
                stateManagementEnabled = true;
                fabricConnected = true;
                window.fabricConnected = true;
                window.stateManagementEnabled = true;
                // Update localStorage with current connection
                localStorage.setItem('fabricConnected', 'true');
                localStorage.setItem('fabricConnectionTime', Date.now().toString());
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            } else if (fabricConnectedParam) {
                console.log('üîó Fabric connected URL parameter found - enabling state management from URL');
                stateManagementEnabled = true;
                fabricConnected = true;
                window.fabricConnected = true;
                window.stateManagementEnabled = true;
                // Update localStorage with current connection
                localStorage.setItem('fabricConnected', 'true');
                localStorage.setItem('fabricConnectionTime', Date.now().toString());
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            } else {
                console.log('üîí No Fabric SQL connection - state management disabled');
                stateManagementEnabled = false;
                fabricConnected = false;
                window.fabricConnected = false;
                window.stateManagementEnabled = false;
                
                // Clear any stale connection state
                localStorage.removeItem('fabricConnected');
                localStorage.removeItem('fabricStateEnabled');
                localStorage.removeItem('fabricDataSynced');
                localStorage.removeItem('fabricConnectionTime');
                
                if (document.body && document.body.classList) {
                    document.body.classList.add('state-management-disabled');
                }
            }
            
            // Check if URL indicates fabric connection (from server-side state loading)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('fabric_connected') === 'true') {
                console.log('üîó URL indicates Fabric connection - enabling state management');
                stateManagementEnabled = true;
                fabricConnected = true;
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
            }
            
            // If we have a valid connection, try to restore state data from localStorage
            if (stateManagementEnabled && fabricConnected) {
                const savedStateData = localStorage.getItem('fabricStateData');
                const savedStateTime = localStorage.getItem('fabricStateDataTime');
                
                if (savedStateData && savedStateTime) {
                    const stateAge = Date.now() - parseInt(savedStateTime);
                    const thirtyMinutes = 30 * 60 * 1000;
                    
                    if (stateAge < thirtyMinutes) {
                        try {
                            const stateData = JSON.parse(savedStateData);
                            console.log(`üîÑ Restoring ${Object.keys(stateData).length} state records from localStorage`);
                            
                            // Store globally and apply to page
                            window.fabricStateData = stateData;
                            
                            // Apply state data after DOM is fully ready
                            setTimeout(() => {
                                // Check if elements are available before applying
                                const feedbackElements = document.querySelectorAll('[data-feedback-id]');
                                console.log(`üîç DOM Check: Found ${feedbackElements.length} feedback elements before applying state data`);
                                
                                if (feedbackElements.length > 0) {
                                    updateFeedbackWithSQLData(stateData);
                                    console.log('‚úÖ State data restored and applied after page reload');
                                } else {
                                    console.log('‚ö†Ô∏è No feedback elements found yet, retrying state restoration...');
                                    // Retry after a longer delay
                                    setTimeout(() => {
                                        const retryElements = document.querySelectorAll('[data-feedback-id]');
                                        console.log(`üîç Retry Check: Found ${retryElements.length} feedback elements`);
                                        if (retryElements.length > 0) {
                                            updateFeedbackWithSQLData(stateData);
                                            console.log('‚úÖ State data restored after retry');
                                        } else {
                                            console.log('‚ö†Ô∏è Still no feedback elements - state restoration skipped (might be filtered out)');
                                        }
                                    }, 500);
                                }
                            }, 250);
                            
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Could not restore state data from localStorage:', error);
                            localStorage.removeItem('fabricStateData');
                            localStorage.removeItem('fabricStateDataTime');
                        }
                    } else {
                        console.log('üîí State data is stale, clearing localStorage');
                        localStorage.removeItem('fabricStateData');
                        localStorage.removeItem('fabricStateDataTime');
                    }
                }
            }
            
            // Add test button for debugging (remove in production)
            if (window.location.hash === '#debug') {
                try {
                    const testBtn = document.createElement('button');
                    testBtn.textContent = 'Test State Loading';
                    testBtn.className = 'btn btn-warning btn-sm ms-2';
                    testBtn.onclick = testStateLoading;
                    const container = document.querySelector('.fluent-container');
                    if (container) {
                        container.appendChild(testBtn);
                    }
                } catch (error) {
                    console.error('‚ùå Error adding debug button:', error);
                }
            }
            
            console.log('‚úÖ Page initialization complete - State management:', stateManagementEnabled ? 'ENABLED' : 'DISABLED');
        });
        }
        
        // Global dropdown for state selection
        let globalDropdown = null;
        let currentFeedbackElement = null;
        
        // Create global dropdown on page load
        function createGlobalDropdown() {
            if (globalDropdown) return;
            
            globalDropdown = document.createElement('div');
            globalDropdown.className = 'global-state-dropdown';
            globalDropdown.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                z-index: 999999;
                min-width: 120px;
                display: none;
                padding: 4px 0;
            `;
            
            globalDropdown.innerHTML = `
                <div class="state-option" data-state="NEW" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">üÜï New</div>
                <div class="state-option" data-state="TRIAGED" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">üîç Triaged</div>
                <div class="state-option" data-state="CLOSED" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">‚úÖ Closed</div>
                <div class="state-option" data-state="IRRELEVANT" style="padding: 8px 12px; cursor: pointer; font-size: 14px;">‚ùå Irrelevant</div>
            `;
            
            // Add hover effects
            globalDropdown.querySelectorAll('.state-option').forEach(option => {
                option.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#f8f9fa';
                });
                option.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = '';
                });
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const newState = this.getAttribute('data-state');
                    const currentState = currentFeedbackElement.getAttribute('data-current-state');
                    const feedbackId = currentFeedbackElement.getAttribute('data-feedback-id');
                    
                    if (newState !== currentState) {
                        updateState(feedbackId, newState, currentFeedbackElement);
                    }
                    
                    // Hide dropdown
                    globalDropdown.style.display = 'none';
                });
            });
            
            document.body.appendChild(globalDropdown);
        }
        
        // Single dropdown toggle function
        function toggleStateDropdown(element, event) {
            // Check if state management is enabled - ONLY based on backend session, not localStorage
            const sessionToken = '{{ stored_token or "" }}';
            
            const isEnabled = stateManagementEnabled ||
                             (sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None');
            
            if (!isEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            // Enable state management if not already enabled
            if (!stateManagementEnabled) {
                stateManagementEnabled = true;
                document.body.classList.remove('state-management-disabled');
            }
            
            // Prevent event bubbling
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Create global dropdown if not exists
            createGlobalDropdown();
            
            // Store current element
            currentFeedbackElement = element;
            
            // Position dropdown below the clicked badge (fixed positioning relative to viewport)
            const rect = element.getBoundingClientRect();
            globalDropdown.style.top = (rect.bottom + 2) + 'px';
            globalDropdown.style.left = rect.left + 'px';
            globalDropdown.style.display = 'block';
            
            console.log('‚úÖ Global dropdown positioned at:', globalDropdown.style.top, globalDropdown.style.left);
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            if (globalDropdown && !event.target.closest('.state-badge') && !event.target.closest('.global-state-dropdown')) {
                globalDropdown.style.display = 'none';
            }
        });
        
        // Legacy function for compatibility
        function oldToggleStateDropdown(element) {
            // Check if state management is enabled
            if (!stateManagementEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            // Close all other dropdowns
            document.querySelectorAll('.state-dropdown').forEach(d => {
                if (d && d.classList) {
                    d.classList.remove('show');
                }
            });
            document.querySelectorAll('.actions-menu').forEach(m => {
                if (m && m.classList) {
                    m.classList.remove('show');
                }
            });
            document.querySelectorAll('.fluent-card').forEach(c => {
                if (c && c.classList) {
                    c.classList.remove('dropdown-open');
                }
            });
            
            const feedbackId = element.getAttribute('data-feedback-id');
            const dropdown = document.querySelector(`.state-dropdown[data-feedback-id="${feedbackId}"]`);
            const card = element.closest('.fluent-card');
            
            if (dropdown && dropdown.classList) {
                dropdown.classList.toggle('show');
                
                // Add dropdown-open class to prevent card hover effects
                if (dropdown.classList.contains('show') && card && card.classList) {
                    card.classList.add('dropdown-open');
                }
            }
            
            // Add click handlers to state options
            if (dropdown) {
                dropdown.querySelectorAll('.state-option').forEach(option => {
                    option.onclick = function() {
                        const newState = this.getAttribute('data-state');
                        const currentState = element.getAttribute('data-current-state');
                        
                        if (newState !== currentState) {
                            updateState(feedbackId, newState, element);
                        }
                        if (dropdown && dropdown.classList) {
                            dropdown.classList.remove('show');
                        }
                        if (card && card.classList) {
                            card.classList.remove('dropdown-open');
                        }
                        
                        // Reconnect observer after state change is complete
                        setTimeout(() => {
                            if (window.stateObserver) {
                                window.stateObserver.observe(document.body, {
                                    childList: true,
                                    subtree: false
                                });
                            }
                        }, 500);
                    };
                });
            }
        }
        
        // Toggle actions menu
        // Update feedback state (cached)
        function updateState(feedbackId, newState, stateElement) {
            if (!stateManagementEnabled || !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Update UI immediately (no prompt)
            const stateNames = {
                'NEW': 'üÜï New',
                'TRIAGED': 'üîç Triaged',
                'CLOSED': '‚úÖ Closed',
                'IRRELEVANT': '‚ùå Irrelevant'
            };
            
            stateElement.textContent = stateNames[newState] || newState;
            stateElement.className = `state-badge state-${newState.toLowerCase()}`;
            stateElement.setAttribute('data-current-state', newState);
            
            // Immediately sync to SQL database
            const changeData = {
                feedback_id: feedbackId,
                state: newState
            };
            
            console.log(`üîÑ State changed: ${feedbackId} ‚Üí ${newState} (syncing to SQL)`);
            
            // Call new SQL update API
            fetch('/api/feedback/state/update', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(changeData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log(`‚úÖ Successfully updated state for ${feedbackId} in SQL database`);
                } else {
                    console.error(`‚ùå Failed to update state for ${feedbackId}:`, data.message);
                    alert('Failed to update state: ' + data.message);
                }
            })
            .catch(error => {
                console.error(`‚ùå Error updating state for ${feedbackId}:`, error);
                alert('Error updating state: ' + error.message);
            });
        }
        
        // Update notes display in UI
        function updateNotesDisplay(feedbackId, notes) {
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.fluent-card-body') : null;
            if (card) {
                let notesDisplay = card.querySelector('.notes-display');
                if (!notesDisplay) {
                    notesDisplay = document.createElement('div');
                    notesDisplay.className = 'notes-display';
                    // Insert after state management section
                    const stateSection = card.querySelector('.category-info');
                    if (stateSection) {
                        stateSection.parentNode.insertBefore(notesDisplay, stateSection.nextSibling);
                    }
                }
                notesDisplay.innerHTML = `üìù ${notes}`;
            }
        }
        
        // Update domain with proper dropdown
        function updateDomain(feedbackId, currentDomain) {
            if (!stateManagementEnabled || !fabricConnected) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Create domain selection modal
            showDomainSelectionModal(feedbackId, currentDomain);
        }
        
        // Show domain selection modal
        function showDomainSelectionModal(feedbackId, currentDomain) {
            const domains = ['GETTING_STARTED', 'GOVERNANCE', 'USER_EXPERIENCE', 'AUTHENTICATION', 'PERFORMANCE', 'INTEGRATION', 'ANALYTICS'];
            const domainNames = {
                'GETTING_STARTED': 'Getting Started',
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            // Create modal HTML
            const modalHtml = `
                <div id="domainModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; border-radius: 8px; padding: 20px; max-width: 400px; width: 90%;">
                        <h5>Update Domain for Feedback</h5>
                        <p class="text-muted">Select a new domain for this feedback:</p>
                        <div class="mb-3">
                            <label class="form-label">Domain:</label>
                            <select id="domainSelect" class="form-select">
                                ${domains.map(domain =>
                                    `<option value="${domain}" ${domain === currentDomain ? 'selected' : ''}>${domainNames[domain]}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="d-flex justify-content-end gap-2">
                            <button type="button" class="btn btn-secondary" onclick="closeDomainModal()">Cancel</button>
                            <button type="button" class="btn btn-primary" onclick="saveDomainChange('${feedbackId}'); return false;">Update Domain</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        // Close domain modal
        function closeDomainModal() {
            const modal = document.getElementById('domainModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Save domain change from modal with direct SQL update
        function saveDomainChange(feedbackId) {
            const selectedDomain = document.getElementById('domainSelect').value;
            const domainNames = {
                'GETTING_STARTED': 'Getting Started',
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${selectedDomain} (${domainNames[selectedDomain]})`);
            
            // Close modal immediately for better UX
            closeDomainModal();
            
            // Update domain directly in SQL database
            fetch('/api/update_domain_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_domain: selectedDomain
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Domain updated successfully: ${feedbackId} ‚Üí ${selectedDomain}`);
                    
                    // Update domain display in UI
                    updateDomainDisplayFromCache(feedbackId, selectedDomain);
                    
                    // Show success message
                    showMessage(`Domain updated to ${domainNames[selectedDomain]}`, 'success');
                } else {
                    console.error(`‚ùå Domain update failed: ${data.message}`);
                    showMessage(`Failed to update domain: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error(`‚ùå Domain update error:`, error);
                showMessage('Error updating domain. Please try again.', 'error');
            });
            
            return false;
        }
        
        // Load data from Fabric SQL when no feedback is available
        function loadFromFabricSQL() {
            if (confirm('Load existing feedback data from Fabric SQL database?')) {
                window.location.href = '/api/fabric/sync';
            }
        }
        
        // Add click handler to close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('domainModal');
            if (modal && event.target === modal) {
                closeDomainModal();
            }
        });
        
        // Multi-select filter functions - make them globally accessible
        function toggleFilterAll(filterType) {
            const allCheckbox = document.getElementById(filterType + '_all');
            const filterCheckboxes = document.querySelectorAll(`input[data-filter="${filterType}"]`);
            
            if (allCheckbox && allCheckbox.checked) {
                // Uncheck all specific filters when "All" is selected
                filterCheckboxes.forEach(cb => cb.checked = false);
            } else if (!allCheckbox) {
                // If no "All" checkbox exists, this function is not applicable
                console.log(`üîß No "All" checkbox found for filter type: ${filterType}`);
            }
        }
        
        function applyMultiSelectFilters() {
            console.log('üîß MULTI-SELECT FILTER: Applying filters using AJAX system');
            
            // Always use the modern filter system instead of page reload
            if (window.modernFilterSystem) {
                // Check if system is currently loading to prevent race conditions
                if (window.modernFilterSystem.isLoading) {
                    console.log('üîß MULTI-SELECT FILTER: System is loading, skipping duplicate request');
                    return;
                }
                
                // Read current UI state and apply filters via AJAX
                console.log('üîß Using modern filter system for filter application');
                window.modernFilterSystem.readFiltersFromUI();
                window.modernFilterSystem.currentPage = 1;
                window.modernFilterSystem.fetchFilteredData();
            } else {
                console.warn('üîß Modern filter system not available, falling back to page reload');
                // Fallback to old method if modern system isn't available
                const params = new URLSearchParams();
                
                // Get current non-filter parameters
                const currentParams = new URLSearchParams(window.location.search);
                if (currentParams.get('sort')) params.set('sort', currentParams.get('sort'));
                if (currentParams.get('show_repeating') === 'true') params.set('show_repeating', 'true');
                if (currentParams.get('show_only_stored') === 'true') params.set('show_only_stored', 'true');
                
                // Preserve Fabric connection state to prevent state management loss after filtering
                if (fabricConnected || stateManagementEnabled) {
                    params.set('fabric_connected', 'true');
                    console.log('üîß MULTI-SELECT FILTER: Preserving Fabric connection state in URL');
                }
                
                // Collect selected filters (without checking for "All" checkboxes)
                const filterTypes = ['audience', 'priority', 'state', 'source', 'domain', 'sentiment', 'enhanced_category'];
                
                filterTypes.forEach(filterType => {
                    const selected = [];
                    const checkboxes = document.querySelectorAll(`input[data-filter="${filterType}"]:checked`);
                    checkboxes.forEach(cb => selected.push(cb.value));
                    
                    if (selected.length > 0) {
                        params.set(filterType, selected.join(','));
                    }
                });
                
                // Navigate to filtered URL
                const newUrl = window.location.pathname + '?' + params.toString();
                window.location.href = newUrl;
            }
        }
        
        // Make functions globally accessible
        window.toggleFilterAll = toggleFilterAll;
        window.applyMultiSelectFilters = applyMultiSelectFilters;
        
        // Update dropdown button text when checkboxes change
        document.addEventListener('change', function(event) {
            if (event.target.classList.contains('filter-checkbox')) {
                const filterType = event.target.getAttribute('data-filter');
                updateDropdownButtonText(filterType);
                
                // Uncheck "All" when specific filters are selected
                const allCheckbox = document.getElementById(filterType + '_all');
                if (allCheckbox && event.target.checked) {
                    allCheckbox.checked = false;
                }
            }
        });
        
        function updateDropdownButtonText(filterType) {
            const button = document.getElementById(filterType + 'Filter');
            const selected = document.querySelectorAll(`input[data-filter="${filterType}"]:checked`);
            const allCheckbox = document.getElementById(filterType + '_all');
            
            if (button) {
                if (allCheckbox && allCheckbox.checked) {
                    button.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
                } else if (selected.length === 0) {
                    button.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
                } else {
                    button.textContent = `${selected.length} ${filterType}(s) selected`;
                }
            }
        }
        
        // Show message to user
        function showMessage(message, type = 'info') {
            // Create message element
            const messageEl = document.createElement('div');
            messageEl.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show`;
            messageEl.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            messageEl.innerHTML = `
                ${message}
                <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
            `;
            
            // Add to page
            document.body.appendChild(messageEl);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (messageEl.parentElement) {
                    messageEl.remove();
                }
            }, 3000);
        }
        
        // Update audience function
        function updateAudience(feedbackId, currentAudience) {
            if (!stateManagementEnabled) {
                alert('Please connect to Fabric first to enable audience updates.');
                return;
            }
            
            // Create audience selection modal
            const modal = document.createElement('div');
            modal.id = 'audienceModal';
            modal.className = 'modal fade show';
            modal.style.cssText = 'display: block; background: rgba(0,0,0,0.5); position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1050;';
            
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Update Audience</h5>
                            <button type="button" class="btn-close" onclick="closeAudienceModal()"></button>
                        </div>
                        <div class="modal-body">
                            <p><strong>Current:</strong> ${currentAudience || 'Not set'}</p>
                            <div class="mb-3">
                                <label for="audienceSelect" class="form-label">Select new audience:</label>
                                <select class="form-select" id="audienceSelect">
                                    <option value="Developer" ${currentAudience === 'Developer' ? 'selected' : ''}>üõ†Ô∏è Developer</option>
                                    <option value="Customer" ${currentAudience === 'Customer' ? 'selected' : ''}>üë§ Customer</option>
                                    <option value="ISV" ${currentAudience === 'ISV' ? 'selected' : ''}>üè¢ ISV</option>
                                </select>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" onclick="closeAudienceModal()">Cancel</button>
                            <button type="button" class="btn btn-primary" onclick="saveAudienceChange('${feedbackId}')">Update Audience</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Close audience modal
        function closeAudienceModal() {
            const modal = document.getElementById('audienceModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Save audience change from modal with direct SQL update
        function saveAudienceChange(feedbackId) {
            const selectedAudience = document.getElementById('audienceSelect').value;
            
            console.log(`üë• Audience changing: ${feedbackId} ‚Üí ${selectedAudience}`);
            
            // Close modal immediately for better UX
            closeAudienceModal();
            
            // Update audience directly in SQL database
            fetch('/api/update_audience_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_audience: selectedAudience
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`‚úÖ Audience updated successfully: ${feedbackId} ‚Üí ${selectedAudience}`);
                    
                    // Update audience display in UI
                    const audienceElement = document.querySelector(`[data-feedback-id="${feedbackId}"] .audience-display`);
                    if (audienceElement) {
                        audienceElement.textContent = selectedAudience;
                    }
                    
                    // Show success message
                    showMessage(`Audience updated to ${selectedAudience}`, 'success');
                } else {
                    console.error(`‚ùå Audience update failed: ${data.message}`);
                    showMessage(`Failed to update audience: ${data.message}`, 'error');
                }
            })
            .catch(error => {
                console.error(`‚ùå Audience update error:`, error);
                showMessage('Error updating audience. Please try again.', 'error');
            });
            
            return false;
        }
        
        // Update notes
        function updateNotes(feedbackId, currentNotes) {
            if (!stateManagementEnabled) {
                alert('Please provide your Fabric Bearer Token first to enable state management.');
                return;
            }
            
            const notes = prompt('Enter notes for this feedback:', currentNotes) || '';
            
            // Cache the notes change
            cacheStateChange(feedbackId, { notes: notes });
            
            // Update notes display in UI
            updateNotesDisplay(feedbackId, notes);
        }

        // Update domain display in UI
        function updateDomainDisplay(feedbackId, domainName) {
            const stateBadge = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            const card = stateBadge ? stateBadge.closest('.fluent-card-body') : null;
            if (card) {
                const domainSection = card.querySelector('.category-info:has(.domain-badge)');
                if (domainSection) {
                    const domainBadge = domainSection.querySelector('.domain-badge');
                    if (domainBadge) {
                        domainBadge.textContent = domainName;
                    }
                }
            }
        }

        // --- Interactive category editor helpers ---
        let categoryDataCache = null;
        let activeCategoryFeedbackId = null;

        async function fetchCategoryData() {
            if (categoryDataCache) {
                return categoryDataCache;
            }

            try {
                const response = await fetch('/api/categories');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const payload = await response.json();
                if (payload.status === 'success' && payload.categories) {
                    categoryDataCache = payload.categories;
                    return categoryDataCache;
                }

                throw new Error(payload.message || 'Unable to load categories');
            } catch (error) {
                console.error('‚ùå Category data load error:', error);
                showMessage('Error loading categories. Please try again.', 'error');
                throw error;
            }
        }

        function showCategoryPickerFromElement(element) {
            const feedbackId = element.getAttribute('data-category-feedback-id') || element.getAttribute('data-feedback-id');
            const categoryName = element.getAttribute('data-category-name') || '';
            const subcategoryName = element.getAttribute('data-subcategory-name') || '';
            const featureArea = element.getAttribute('data-feature-area') || '';
            const domainName = element.getAttribute('data-domain-code') || element.getAttribute('data-domain-name') || '';

            showCategoryPicker(feedbackId, categoryName, subcategoryName, featureArea, domainName);
        }

        function findCategoryKeyByName(categories, displayName) {
            if (!displayName) {
                return '';
            }
            const normalized = displayName.trim().toLowerCase();
            for (const [key, details] of Object.entries(categories)) {
                const candidate = (details.name || key).trim().toLowerCase();
                if (candidate === normalized) {
                    return key;
                }
            }
            return '';
        }

        function findSubcategoryKeyByName(subcategories, displayName) {
            if (!displayName) {
                return '';
            }
            const normalized = displayName.trim().toLowerCase();
            for (const [key, details] of Object.entries(subcategories)) {
                const candidate = (details.name || key).trim().toLowerCase();
                if (candidate === normalized) {
                    return key;
                }
            }
            return '';
        }

        function populateSubcategoryOptions(selectElement, categoryId, categories, currentSubcategoryName, fallbackFeatureArea) {
            selectElement.innerHTML = '';

            const noneOption = document.createElement('option');
            noneOption.value = '';
            noneOption.textContent = 'None';
            noneOption.dataset.displayName = '';
            noneOption.dataset.featureArea = '';
            selectElement.appendChild(noneOption);

            if (!categoryId || !categories[categoryId]) {
                selectElement.disabled = true;
                return;
            }

            selectElement.disabled = false;

            const subcategories = categories[categoryId].subcategories || {};
            const currentKey = findSubcategoryKeyByName(subcategories, currentSubcategoryName);

            Object.entries(subcategories)
                .sort((a, b) => ((a[1].name || a[0]).localeCompare(b[1].name || b[0])))
                .forEach(([subKey, details]) => {
                    const option = document.createElement('option');
                    option.value = subKey;
                    option.textContent = details.name || subKey;
                    option.dataset.displayName = details.name || subKey;
                    option.dataset.featureArea = details.feature_area || '';
                    if (currentKey && subKey === currentKey) {
                        option.selected = true;
                    }
                    selectElement.appendChild(option);
                });
        }

        function updateFeatureAreaHint(selectElement, hintElement) {
            if (!hintElement) {
                return;
            }

            const selectedOption = selectElement.options[selectElement.selectedIndex];
            if (!selectedOption) {
                hintElement.textContent = '';
                return;
            }

            const featureArea = selectedOption.dataset ? (selectedOption.dataset.featureArea || '') : '';
            const name = selectedOption.dataset ? (selectedOption.dataset.displayName || '') : '';

            if (name && featureArea) {
                hintElement.textContent = `Feature Area: ${featureArea}`;
            } else if (name) {
                hintElement.textContent = '';
            } else {
                hintElement.textContent = '';
            }
        }

        async function showCategoryPicker(feedbackId, currentCategory, currentSubcategory, currentFeatureArea, currentDomainName = '') {
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            const sessionToken = '{{ stored_token or "" }}';
            const hasValidSession = sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None';

            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected && !hasValidSession) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable category updates.');
                return;
            }

            try {
                const categories = await fetchCategoryData();

                const existingModal = document.getElementById('categoryModal');
                if (existingModal) {
                    existingModal.remove();
                }

                activeCategoryFeedbackId = feedbackId;

                const modal = document.createElement('div');
                modal.id = 'categoryModal';
                modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.45); z-index: 10000; display: flex; align-items: center; justify-content: center;';
                modal.innerHTML = `
                    <div class="bg-white rounded-3 shadow-lg" style="width: min(420px, 90vw); overflow: hidden;">
                        <div class="d-flex justify-content-between align-items-center border-bottom px-4 py-3">
                            <h6 class="mb-0">Update Category</h6>
                            <button type="button" class="btn-close" aria-label="Close"></button>
                        </div>
                        <div class="px-4 py-3">
                            <label class="form-label fw-semibold small text-muted" for="categorySelect">Category &amp; Domain</label>
                            <select id="categorySelect" class="form-select form-select-sm mb-3"></select>
                            <label class="form-label fw-semibold small text-muted" for="subcategorySelect">Subcategory</label>
                            <select id="subcategorySelect" class="form-select form-select-sm mb-2"></select>
                            <label class="form-label fw-semibold small text-muted" for="domainSelect">Domain</label>
                            <select id="domainSelect" class="form-select form-select-sm mb-2"></select>
                            <div id="featureAreaDisplay" class="small text-muted"></div>
                        </div>
                        <div class="d-flex justify-content-end gap-2 border-top px-4 py-3 bg-light">
                            <button type="button" class="btn btn-outline-secondary btn-sm" id="cancelCategoryBtn">Cancel</button>
                            <button type="button" class="btn btn-primary btn-sm" id="saveCategoryBtn">Save</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                const categorySelect = modal.querySelector('#categorySelect');
                const subcategorySelect = modal.querySelector('#subcategorySelect');
                const featureAreaDisplay = modal.querySelector('#featureAreaDisplay');
                const domainSelect = modal.querySelector('#domainSelect');

                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = 'No category';
                placeholderOption.dataset.displayName = '';
                categorySelect.appendChild(placeholderOption);

                const currentCategoryKey = findCategoryKeyByName(categories, currentCategory);

                Object.entries(categories)
                    .sort((a, b) => ((a[1].name || a[0]).localeCompare(b[1].name || b[0])))
                    .forEach(([key, details]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = details.name || key;
                        option.dataset.displayName = details.name || key;
                        if (currentCategoryKey && key === currentCategoryKey) {
                            option.selected = true;
                        }
                        categorySelect.appendChild(option);
                    });

                populateSubcategoryOptions(subcategorySelect, categorySelect.value, categories, currentSubcategory, currentFeatureArea);
                updateFeatureAreaHint(subcategorySelect, featureAreaDisplay);

                categorySelect.addEventListener('change', () => {
                    populateSubcategoryOptions(subcategorySelect, categorySelect.value, categories, '', '');
                    if (subcategorySelect.disabled) {
                        featureAreaDisplay.textContent = '';
                    } else {
                        updateFeatureAreaHint(subcategorySelect, featureAreaDisplay);
                    }
                });

                subcategorySelect.addEventListener('change', () => {
                    updateFeatureAreaHint(subcategorySelect, featureAreaDisplay);
                });

                const domainOptions = {
                    'GETTING_STARTED': 'Getting Started',
                    'GOVERNANCE': 'Governance',
                    'USER_EXPERIENCE': 'User Experience',
                    'AUTHENTICATION': 'Authentication & Security',
                    'PERFORMANCE': 'Performance & Scalability',
                    'INTEGRATION': 'Integration & APIs',
                    'ANALYTICS': 'Analytics & Reporting'
                };

                const defaultDomainOption = document.createElement('option');
                defaultDomainOption.value = '';
                defaultDomainOption.textContent = 'Select domain';
                domainSelect.appendChild(defaultDomainOption);

                const currentDomainKey = Object.keys(domainOptions).find(key => domainOptions[key] === currentDomainName || key === currentDomainName);

                Object.entries(domainOptions).forEach(([code, name]) => {
                    const option = document.createElement('option');
                    option.value = code;
                    option.textContent = name;
                    if (currentDomainKey && currentDomainKey === code) {
                        option.selected = true;
                    }
                    domainSelect.appendChild(option);
                });

                modal.querySelector('.btn-close').addEventListener('click', closeCategoryModal);
                modal.querySelector('#cancelCategoryBtn').addEventListener('click', closeCategoryModal);
                modal.querySelector('#saveCategoryBtn').addEventListener('click', saveCategorySelection);

                modal.addEventListener('click', (event) => {
                    if (event.target === modal) {
                        closeCategoryModal();
                    }
                });

                document.addEventListener('keydown', handleCategoryEsc, { once: true });
            } catch (error) {
                console.error('‚ùå Unable to open category picker:', error);
            }
        }

        function handleCategoryEsc(event) {
            if (event.key === 'Escape') {
                closeCategoryModal();
            }
        }

        function closeCategoryModal() {
            const modal = document.getElementById('categoryModal');
            if (modal) {
                modal.remove();
            }
            document.removeEventListener('keydown', handleCategoryEsc);
            activeCategoryFeedbackId = null;
        }

        async function saveCategorySelection() {
            const modal = document.getElementById('categoryModal');
            if (!modal || !activeCategoryFeedbackId) {
                return;
            }

            const categorySelect = modal.querySelector('#categorySelect');
            const subcategorySelect = modal.querySelector('#subcategorySelect');
            const domainSelect = modal.querySelector('#domainSelect');

            const categoryValue = categorySelect.value;
            const categoryOption = categorySelect.options[categorySelect.selectedIndex];
            const categoryName = categoryOption ? (categoryOption.dataset.displayName || '') : '';

            const subcategoryValue = subcategorySelect.disabled ? '' : subcategorySelect.value;
            const subcategoryOption = subcategorySelect.disabled ? null : subcategorySelect.options[subcategorySelect.selectedIndex];
            const subcategoryName = subcategoryOption ? (subcategoryOption.dataset.displayName || '') : '';
            const featureArea = subcategoryOption ? (subcategoryOption.dataset.featureArea || '') : '';
            const domainValue = domainSelect.value;
            const domainName = domainSelect.options[domainSelect.selectedIndex] ? domainSelect.options[domainSelect.selectedIndex].textContent : '';

            const payload = {
                feedback_id: activeCategoryFeedbackId,
                category_id: categoryValue && categoryValue !== '__custom__' ? categoryValue : null,
                category_name: categoryName,
                subcategory_id: subcategoryValue && subcategoryValue !== '__custom__' ? subcategoryValue : null,
                subcategory_name: subcategoryName,
                feature_area: featureArea,
                domain_code: domainValue || null,
                domain_name: domainName || null
            };

            try {
                const response = await fetch('/api/update_category_sql', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                if (data.success) {
                    // Update display BEFORE closing modal (which clears activeCategoryFeedbackId)
                    updateCategoryDisplay(activeCategoryFeedbackId, categoryName, subcategoryName, featureArea, payload.domain_code, payload.domain_name);
                    closeCategoryModal();
                    showMessage(data.message || 'Category updated successfully', 'success');
                } else {
                    console.error('‚ùå Category update failed:', data.message);
                    showMessage(`Failed to update category: ${data.message}`, 'error');
                }
            } catch (error) {
                console.error('‚ùå Error updating category:', error);
                showMessage('Error updating category. Please try again.', 'error');
            }
        }

        function updateCategoryDisplay(feedbackId, categoryName, subcategoryName, featureArea, domainCode, domainName) {
            // Find ALL instances of this feedback item on the page (e.g. in list and potential duplicates)
            const stateBadges = document.querySelectorAll(`[data-feedback-id="${feedbackId}"][data-current-state]`);
            
            stateBadges.forEach(stateBadge => {
                const card = stateBadge.closest('.fluent-card, .card');
                if (!card) return;

                const categoryChip = card.querySelector('.category-chip');
                if (categoryChip) {
                    if (categoryName) {
                        categoryChip.textContent = categoryName;
                    } else {
                        categoryChip.textContent = 'Set category';
                    }
                    categoryChip.setAttribute('data-category-name', categoryName || '');
                    categoryChip.setAttribute('data-subcategory-name', subcategoryName || '');
                    categoryChip.setAttribute('data-feature-area', featureArea || '');
                    categoryChip.setAttribute('data-domain-code', domainCode || '');
                }

                const subcategoryChip = card.querySelector('.subcategory-chip');
                if (subcategoryChip) {
                    if (subcategoryName) {
                        subcategoryChip.textContent = subcategoryName;
                        subcategoryChip.classList.remove('subcategory-empty');
                    } else {
                        subcategoryChip.textContent = 'Add subcategory';
                        subcategoryChip.classList.add('subcategory-empty');
                    }
                    subcategoryChip.setAttribute('data-category-name', categoryName || '');
                    subcategoryChip.setAttribute('data-subcategory-name', subcategoryName || '');
                    subcategoryChip.setAttribute('data-feature-area', featureArea || '');
                    subcategoryChip.setAttribute('data-domain-code', domainCode || '');
                }

                const domainBadge = card.querySelector('.domain-badge');
                if (domainBadge) {
                    domainBadge.textContent = domainName || (domainCode || '‚ùì Uncategorized');
                    domainBadge.style.backgroundColor = getDomainColor(domainCode);
                    domainBadge.setAttribute('data-domain-name', domainName || '');
                    domainBadge.setAttribute('data-domain-code', domainCode || '');
                    domainBadge.setAttribute('data-category-name', categoryName || '');
                    domainBadge.setAttribute('data-subcategory-name', subcategoryName || '');
                    domainBadge.setAttribute('data-feature-area', featureArea || '');
                }
            });
        }

        function getDomainColor(domainCode) {
            const domainColors = {
                'GETTING_STARTED': '#20c997',
                'GOVERNANCE': '#6f42c1',
                'USER_EXPERIENCE': '#28a745',
                'AUTHENTICATION': '#dc3545',
                'PERFORMANCE': '#fd7e14',
                'INTEGRATION': '#17a2b8',
                'ANALYTICS': '#ffc107'
            };
            return domainColors[domainCode] || '#6c757d';
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.state-badge') && !event.target.closest('.state-dropdown') &&
                !event.target.closest('.card-actions')) {
                document.querySelectorAll('.state-dropdown').forEach(d => d.classList.remove('show'));
                document.querySelectorAll('.actions-menu').forEach(m => m.classList.remove('show'));
                document.querySelectorAll('.fluent-card').forEach(c => c.classList.remove('dropdown-open'));
            }
        });
        
        // Initialize on page load with session token check
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîë DOMContentLoaded event fired');
            
            // Check for session token first before disabling state management
            const sessionToken = '{{ stored_token or "" }}';
            
            if (sessionToken && sessionToken.trim() !== '') {
                console.log('üîë DOMContentLoaded: Session token found, enabling state management');
                stateManagementEnabled = true;
                bearerToken = sessionToken;
                if (document.body && document.body.classList) {
                    document.body.classList.remove('state-management-disabled');
                }
                const tokenBanner = document.getElementById('tokenBanner');
                if (tokenBanner && tokenBanner.classList) {
                    tokenBanner.classList.add('hidden');
                }
            } else {
                console.log('üîë DOMContentLoaded: No session token, ensuring proper disabled state');
                stateManagementEnabled = false;
                // Don't add disabled class if it might already be set in the session logic above
            }
        });
        
        // Fabric Auth and Collection Progress functionality for feedback viewer
        // Declare variables in global scope to avoid hoisting issues
        var fabricAuthDrawer = null;
        var collectionProgressDrawer = null;
        var fabricToken = null;
        var fabricConnectionStatus = 'disconnected';

        // Initialize drawers on page load using new badge state manager
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîß FEEDBACK: DOMContentLoaded - using BadgeStateManager');
            
            // Initialize drawer components
            initializeDrawers();
            
            // Use the new badge state manager for all badge operations
            // It will automatically sync badges on page load
            
            // Watch for URL changes (filtering) and resync badges
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            
            history.pushState = function() {
                originalPushState.apply(history, arguments);
                console.log('üîß FEEDBACK: URL changed (pushState) - refreshing all state...');
                
                // CRITICAL: Preserve state management status during filtering
                const wasStateManagementEnabled = stateManagementEnabled;
                const wasFabricConnected = fabricConnected;
                const hadStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
                
                console.log('üîß FEEDBACK: Preserving state before badge refresh:', {
                    stateManagementEnabled: wasStateManagementEnabled,
                    fabricConnected: wasFabricConnected,
                    hasStateData: hadStateData
                });
                
                setTimeout(() => {
                    if (window.badgeStateManager) {
                        window.badgeStateManager.forceRefresh();
                    }
                    
                    // CRITICAL: Restore state management status after badge refresh
                    if (wasStateManagementEnabled || wasFabricConnected || hadStateData) {
                        console.log('üîß FEEDBACK: Restoring state management after filtering');
                        stateManagementEnabled = true;
                        fabricConnected = true;
                        
                        // Restore UI state
                        document.body.classList.remove('state-management-disabled');
                        
                        // Update sync button to show connected state with consistent styling
                        const syncBtn = document.getElementById('fabricSyncBtn');
                        if (syncBtn) {
                            syncBtn.className = 'btn btn-primary ms-2'; // Force btn-primary styling
                            syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric <span class="badge bg-success ms-1">Connected</span>';
                        }
                    }
                    
                    // CRITICAL: Reapply cached changes after filtering
                    console.log('üîß FEEDBACK: Reapplying cached changes after filter...');
                    applyCachedChangesToUI();
                    
                    // Re-enable sync button after filtering if state management is enabled
                    if (stateManagementEnabled && hasUnsavedChanges) {
                        updateSyncButton();
                    }
                }, 200); // Increased delay to ensure DOM is updated
            };
            
            history.replaceState = function() {
                originalReplaceState.apply(history, arguments);
                console.log('üîß FEEDBACK: URL changed (replaceState) - refreshing all state...');
                
                // CRITICAL: Preserve state management status during filtering
                const wasStateManagementEnabled = stateManagementEnabled;
                const wasFabricConnected = fabricConnected;
                const hadStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
                
                console.log('üîß FEEDBACK: Preserving state before badge refresh (replaceState):', {
                    stateManagementEnabled: wasStateManagementEnabled,
                    fabricConnected: wasFabricConnected,
                    hasStateData: hadStateData
                });
                
                setTimeout(() => {
                    if (window.badgeStateManager) {
                        window.badgeStateManager.forceRefresh();
                    }
                    
                    // CRITICAL: Restore state management status after badge refresh
                    if (wasStateManagementEnabled || wasFabricConnected || hadStateData) {
                        console.log('üîß FEEDBACK: Restoring state management after filtering (replaceState)');
                        stateManagementEnabled = true;
                        fabricConnected = true;
                        
                        // Restore UI state
                        document.body.classList.remove('state-management-disabled');
                        
                        // Update sync button to show connected state with consistent styling
                        const syncBtn = document.getElementById('fabricSyncBtn');
                        if (syncBtn) {
                            syncBtn.className = 'btn btn-primary ms-2'; // Force btn-primary styling
                            syncBtn.innerHTML = '<i class="bi bi-database me-1"></i>Sync with Fabric <span class="badge bg-success ms-1">Connected</span>';
                        }
                    }
                    
                    // CRITICAL: Reapply cached changes after filtering
                    console.log('üîß FEEDBACK: Reapplying cached changes after filter...');
                    applyCachedChangesToUI();
                    
                    // Re-enable sync button after filtering if state management is enabled
                    if (stateManagementEnabled) {
                        updateSyncButton();
                    }
                }, 200); // Increased delay to ensure DOM is updated
            };
        });
        
        // Separate function to initialize drawer components
        function initializeDrawers() {
            console.log('üîß FEEDBACK: Initializing drawer components...');
            
            // Initialize Fabric Auth drawer
            const fabricAuthElement = document.getElementById('fabricAuthDrawer');
            if (fabricAuthElement) {
                if (typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        fabricAuthDrawer = new bootstrap.Offcanvas(fabricAuthElement);
                        console.log('‚úÖ FEEDBACK: Fabric Auth drawer initialized');
                    } catch (error) {
                        console.error('‚ùå FEEDBACK: Error initializing Fabric Auth drawer:', error);
                        fabricAuthDrawer = null;
                    }
                } else {
                    console.error('‚ùå FEEDBACK: Bootstrap not available');
                    fabricAuthDrawer = null;
                }
            }
            
            // Initialize Collection Progress drawer
            const collectionProgressElement = document.getElementById('collectionProgressDrawer');
            if (collectionProgressElement) {
                if (typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        collectionProgressDrawer = new bootstrap.Offcanvas(collectionProgressElement);
                        console.log('‚úÖ FEEDBACK: Collection Progress drawer initialized');
                    } catch (error) {
                        console.error('‚ùå FEEDBACK: Error initializing Collection Progress drawer:', error);
                        collectionProgressDrawer = null;
                    }
                } else {
                    console.error('‚ùå FEEDBACK: Bootstrap not available');
                    collectionProgressDrawer = null;
                }
            }
        }

        // Sync collection progress status from home page (with continuous polling)
        let feedbackPagePollInterval = null;
        let feedbackPageLastStatus = 'ready';
        
        function syncCollectionProgressStatus() {
            // Poll immediately, then every 2 seconds
            pollCollectionStatusFeedbackPage();
            if (feedbackPagePollInterval) clearInterval(feedbackPagePollInterval);
            feedbackPagePollInterval = setInterval(pollCollectionStatusFeedbackPage, 2000);
        }
        
        function pollCollectionStatusFeedbackPage() {
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    const prevStatus = feedbackPageLastStatus;
                    feedbackPageLastStatus = data.status;
                    
                    if (data.status === 'running') {
                        const progress = Math.round(data.progress || 0);
                        updateProgressBadge(`${progress}%`, 'primary');
                    } else if (data.status === 'completed') {
                        updateProgressBadge('Completed', 'success');
                        // If just transitioned, show a brief notification
                        if (prevStatus === 'running') {
                            console.log(`Collection completed with ${data.total_items || 0} items`);
                        }
                    } else if (data.status === 'error') {
                        updateProgressBadge('Error', 'danger');
                    } else {
                        if (prevStatus === 'ready') {
                            updateProgressBadge('Ready', 'secondary');
                        }
                    }
                })
                .catch(error => {
                    console.debug('Collection status poll failed:', error);
                });
        }

        // Update progress badge
        function updateProgressBadge(text, type) {
            console.log('üîß DEBUG: updateProgressBadge called with:', text, type);
            const badge = document.getElementById('progressBadge');
            console.log('üîß DEBUG: Progress badge element found:', badge);
            if (badge) {
                badge.textContent = text;
                badge.className = `badge bg-${type} ms-1`;
                console.log('üîß DEBUG: Progress badge updated successfully to:', text);
            } else {
                console.error('üîß DEBUG: Progress badge element not found!');
            }
        }

        // Fabric Auth functions (copied from index.html)
        function toggleFabricAuth() {
            console.log('üîß DEBUG: toggleFabricAuth called');
            console.log('üîß DEBUG: fabricAuthDrawer:', fabricAuthDrawer);
            
            // Try to initialize if not already done
            if (!fabricAuthDrawer || fabricAuthDrawer === undefined) {
                console.log('üîß DEBUG: Attempting to reinitialize Fabric Auth drawer...');
                const fabricAuthElement = document.getElementById('fabricAuthDrawer');
                if (fabricAuthElement && typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        fabricAuthDrawer = new bootstrap.Offcanvas(fabricAuthElement);
                        console.log('üîß DEBUG: Fabric Auth drawer reinitialized:', fabricAuthDrawer);
                    } catch (error) {
                        console.error('üîß DEBUG: Failed to reinitialize Fabric Auth drawer:', error);
                        return;
                    }
                } else {
                    console.error('üîß DEBUG: Cannot reinitialize Fabric Auth - element or Bootstrap missing');
                    console.error('üîß DEBUG: Element:', fabricAuthElement);
                    console.error('üîß DEBUG: Bootstrap available:', typeof bootstrap !== 'undefined');
                    return;
                }
            }
            
            if (fabricAuthDrawer) {
                console.log('üîß DEBUG: Attempting to show Fabric Auth drawer...');
                try {
                    fabricAuthDrawer.show();
                    console.log('üîß DEBUG: Fabric Auth drawer show() called successfully');
                } catch (error) {
                    console.error('üîß DEBUG: Error showing Fabric Auth drawer:', error);
                }
            } else {
                console.error('üîß DEBUG: fabricAuthDrawer is still null or undefined');
            }
        }

        function hideFabricAuth() {
            console.log('üîß DEBUG: hideFabricAuth called');
            if (fabricAuthDrawer) {
                fabricAuthDrawer.hide();
            }
        }

        function checkStoredFabricToken() {
            console.log('üîß DEBUG: checkStoredFabricToken called');
            fetch('/api/fabric/token/status')
                .then(response => {
                    console.log('üîß DEBUG: Fabric token status response:', response);
                    return response.json();
                })
                .then(data => {
                    console.log('üîß DEBUG: Fabric token status data:', data);
                    if (data.has_token) {
                        console.log('üîß DEBUG: Restoring full Fabric Auth drawer state...');
                        
                        // Update main UI status and badge
                        updateFabricAuthUI('connected', 'Token stored in session');
                        
                        // Restore all drawer internal elements
                        const currentTokenInfo = document.getElementById('currentTokenInfo');
                        const updateTokenBtn = document.getElementById('updateTokenBtn');
                        const clearTokenBtn = document.getElementById('clearTokenBtn');
                        const lastValidatedTime = document.getElementById('lastValidatedTime');
                        const tokenStatusBadge = document.getElementById('tokenStatusBadge');
                        
                        if (currentTokenInfo) {
                            currentTokenInfo.style.display = 'block';
                            console.log('üîß DEBUG: Restored currentTokenInfo visibility');
                        }
                        if (updateTokenBtn) {
                            updateTokenBtn.style.display = 'block';
                            console.log('üîß DEBUG: Restored updateTokenBtn visibility');
                        }
                        if (clearTokenBtn) {
                            clearTokenBtn.style.display = 'block';
                            console.log('üîß DEBUG: Restored clearTokenBtn visibility');
                        }
                        if (lastValidatedTime) {
                            lastValidatedTime.textContent = data.last_validated || 'Unknown';
                            console.log('üîß DEBUG: Restored lastValidatedTime:', data.last_validated || 'Unknown');
                        }
                        if (tokenStatusBadge) {
                            tokenStatusBadge.className = 'badge bg-success';
                            tokenStatusBadge.textContent = 'Valid';
                            console.log('üîß DEBUG: Restored tokenStatusBadge to Valid');
                        }
                        
                        // Restore token reference
                        fabricToken = 'stored';
                        
                        // Enable state management for feedback page
                        bearerToken = 'stored';
                        stateManagementEnabled = true;
                        if (document.body) {
                            document.body.classList.remove('state-management-disabled');
                        }
                        
                        // Update sync button visibility since state management is now enabled
                        updateSyncButton();
                        
                        console.log('üîß DEBUG: Enabled state management and updated sync button');
                        
                        console.log('üîß DEBUG: Full Fabric Auth drawer state restored successfully');
                    } else {
                        console.log('üîß DEBUG: Restoring disconnected drawer state...');
                        updateFabricAuthUI('disconnected', 'No token stored');
                        
                        // Hide all token management elements
                        const currentTokenInfo = document.getElementById('currentTokenInfo');
                        const updateTokenBtn = document.getElementById('updateTokenBtn');
                        const clearTokenBtn = document.getElementById('clearTokenBtn');
                        
                        if (currentTokenInfo) {
                            currentTokenInfo.style.display = 'none';
                        }
                        if (updateTokenBtn) {
                            updateTokenBtn.style.display = 'none';
                        }
                        if (clearTokenBtn) {
                            clearTokenBtn.style.display = 'none';
                        }
                        
                        // Reset state management
                        fabricToken = null;
                        if (typeof bearerToken !== 'undefined') {
                            bearerToken = null;
                        }
                        if (typeof stateManagementEnabled !== 'undefined') {
                            stateManagementEnabled = false;
                        }
                        
                        console.log('üîß DEBUG: Disconnected drawer state restored');
                    }
                })
                .catch(error => {
                    console.error('üîß DEBUG: Error checking fabric token status:', error);
                    updateFabricAuthUI('error', 'Error checking token status');
                });
        }

        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('fabricAuthToken');
            const visibilityIcon = document.getElementById('tokenVisibilityIcon');
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                visibilityIcon.className = 'bi bi-eye-slash';
            } else {
                tokenInput.type = 'password';
                visibilityIcon.className = 'bi bi-eye';
            }
        }

        function validateFabricToken() {
            const token = document.getElementById('fabricAuthToken').value.trim();
            if (!token) {
                alert('Please enter a Fabric bearer token');
                return;
            }

            updateFabricAuthUI('validating', 'Validating token...');
            addFabricLog('üîÑ Starting fast token validation...');
            
            // Fast validation - if Livy accepts session start, token is valid
            fetch('/api/fabric/token/validate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({token: token})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    fabricToken = token;
                    addFabricLog('‚úÖ Token validation successful');
                    addFabricLog('üöÄ Livy session starting in background');
                    addFabricLog('üìù Token stored in session - state management enabled');
                    
                    if (data.session_id) {
                        addFabricLog(`üîó Session ID: ${data.session_id}`);
                    }
                    
                    // Update badge using BadgeStateManager
                    if (window.badgeStateManager) {
                        window.badgeStateManager.setFabricAuthState('connected', 'Connected', data.session_id);
                    }
                    
                    // Update drawer UI
                    updateFabricAuthUI('connected', 'Token validated - Livy session starting');
                    
                    // Show token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'block';
                    document.getElementById('updateTokenBtn').style.display = 'block';
                    document.getElementById('clearTokenBtn').style.display = 'block';
                    document.getElementById('lastValidatedTime').textContent = new Date().toLocaleString();
                    
                    // Clear token input for security
                    document.getElementById('fabricAuthToken').value = '';
                    
                    // Enable state management in the feedback viewer
                    bearerToken = token;
                    stateManagementEnabled = true;
                    fabricConnected = true;  // Also set fabricConnected flag
                    document.body.classList.remove('state-management-disabled');
                    
                    // Update global connection status
                    console.log('üîß FABRIC AUTH: State management enabled after token validation');
                    console.log('üîß FABRIC AUTH: fabricConnected =', fabricConnected);
                    console.log('üîß FABRIC AUTH: stateManagementEnabled =', stateManagementEnabled);
                    
                } else {
                    updateFabricAuthUI('error', data.message || 'Token validation failed');
                    addFabricLog('‚ùå Token validation failed: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error validating token:', error);
                updateFabricAuthUI('error', 'Error validating token');
                addFabricLog('‚ùå Validation error: ' + error.message);
            });
        }

        function updateFabricToken() {
            document.getElementById('fabricAuthToken').value = '';
            document.getElementById('fabricAuthToken').focus();
            document.getElementById('currentTokenInfo').style.display = 'none';
            document.getElementById('updateTokenBtn').style.display = 'none';
            document.getElementById('clearTokenBtn').style.display = 'none';
            updateFabricAuthUI('disconnected', 'Ready to enter new token');
            addFabricLog('üîÑ Ready to update token');
        }

        function clearFabricToken() {
            if (!confirm('Are you sure you want to clear the stored Fabric token and reset connection state?')) {
                return;
            }

            fetch('/api/clear_session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Clear all state variables
                    fabricToken = null;
                    bearerToken = null;
                    stateManagementEnabled = false;
                    fabricConnected = false;
                    window.fabricConnected = false;
                    window.stateManagementEnabled = false;
                    
                    // Clear any localStorage/sessionStorage
                    localStorage.removeItem('fabricConnected');
                    localStorage.removeItem('stateManagementEnabled');
                    localStorage.removeItem('fabricDataSynced');
                    sessionStorage.removeItem('sessionMessageShown');
                    
                    updateFabricAuthUI('disconnected', 'Session cleared');
                    addFabricLog('üóëÔ∏è Session state and token cleared');
                    
                    // Hide token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'none';
                    document.getElementById('updateTokenBtn').style.display = 'none';
                    document.getElementById('clearTokenBtn').style.display = 'none';
                    
                    // Disable state management UI
                    if (document.body) {
                        document.body.classList.add('state-management-disabled');
                    }
                    
                    // Update connection UI
                    updateConnectionUI();
                    
                    // Show token banner again
                    const tokenBanner = document.getElementById('tokenBanner');
                    if (tokenBanner && tokenBanner.classList) {
                        tokenBanner.classList.remove('hidden');
                    }
                    
                    // Log state changes
                    console.log('üîß FABRIC AUTH: Session cleared, all state reset');
                    console.log('üîß FABRIC AUTH: fabricConnected =', fabricConnected);
                    console.log('üîß FABRIC AUTH: stateManagementEnabled =', stateManagementEnabled);
                    
                    // Refresh the page to fully reset state
                    setTimeout(() => {
                        window.location.href = '/feedback';
                    }, 1000);
                    
                } else {
                    addFabricLog('‚ùå Error clearing session: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error clearing session:', error);
                addFabricLog('‚ùå Error clearing session: ' + error.message);
            });
        }

        function updateFabricAuthUI(status, message) {
            console.log('üîß DEBUG: updateFabricAuthUI called with:', status, message);
            const statusBadge = document.getElementById('fabricConnectionStatus');
            const authBadge = document.getElementById('fabricAuthBadge');
            const statusAlert = document.getElementById('fabricStatusAlert');
            const statusText = document.getElementById('fabricStatusText');
            const spinner = document.getElementById('fabricAuthSpinner');
            
            console.log('üîß DEBUG: Fabric Auth badge element:', authBadge);
            console.log('üîß DEBUG: Status badge element:', statusBadge);
            
            if (statusText) statusText.textContent = message;
            if (statusAlert) statusAlert.style.display = 'block';
            
            switch (status) {
                case 'connected':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-success';
                        statusBadge.textContent = 'Connected';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-success ms-1';
                        authBadge.textContent = 'Connected';
                        console.log('üîß DEBUG: Fabric auth badge updated to Connected');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-success';
                    if (spinner) spinner.style.display = 'none';
                    break;
                case 'validating':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-warning';
                        statusBadge.textContent = 'Validating';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-warning ms-1';
                        authBadge.textContent = 'Validating';
                        console.log('üîß DEBUG: Fabric auth badge updated to Validating');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-warning';
                    if (spinner) spinner.style.display = 'block';
                    break;
                case 'error':
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-danger';
                        statusBadge.textContent = 'Error';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-danger ms-1';
                        authBadge.textContent = 'Error';
                        console.log('üîß DEBUG: Fabric auth badge updated to Error');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-danger';
                    if (spinner) spinner.style.display = 'none';
                    break;
                default: // disconnected
                    if (statusBadge) {
                        statusBadge.className = 'badge bg-secondary';
                        statusBadge.textContent = 'Not Connected';
                    }
                    if (authBadge) {
                        authBadge.className = 'badge bg-secondary ms-1';
                        authBadge.textContent = 'Not Connected';
                        console.log('üîß DEBUG: Fabric auth badge updated to Not Connected');
                    }
                    if (statusAlert) statusAlert.className = 'alert alert-secondary';
                    if (spinner) spinner.style.display = 'none';
                    break;
            }
            
            fabricConnectionStatus = status;
        }

        function addFabricLog(message) {
            const log = document.getElementById('fabricLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            log.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('fabricLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        function clearFabricLog() {
            document.getElementById('fabricLog').innerHTML = '';
        }

        // Collection Progress functions (placeholder)
        function toggleCollectionProgress() {
            console.log('üîß DEBUG: toggleCollectionProgress called');
            console.log('üîß DEBUG: collectionProgressDrawer:', collectionProgressDrawer);
            
            // Try to initialize if not already done
            if (!collectionProgressDrawer || collectionProgressDrawer === undefined) {
                console.log('üîß DEBUG: Attempting to reinitialize Collection Progress drawer...');
                const collectionProgressElement = document.getElementById('collectionProgressDrawer');
                if (collectionProgressElement && typeof bootstrap !== 'undefined' && bootstrap.Offcanvas) {
                    try {
                        collectionProgressDrawer = new bootstrap.Offcanvas(collectionProgressElement);
                        console.log('üîß DEBUG: Collection Progress drawer reinitialized:', collectionProgressDrawer);
                    } catch (error) {
                        console.error('üîß DEBUG: Failed to reinitialize Collection Progress drawer:', error);
                        return;
                    }
                } else {
                    console.error('üîß DEBUG: Cannot reinitialize - element or Bootstrap missing');
                    console.error('üîß DEBUG: Element:', collectionProgressElement);
                    console.error('üîß DEBUG: Bootstrap available:', typeof bootstrap !== 'undefined');
                    return;
                }
            }
            
            if (collectionProgressDrawer) {
                console.log('üîß DEBUG: Attempting to show drawer...');
                try {
                    collectionProgressDrawer.show();
                    console.log('üîß DEBUG: Drawer show() called successfully');
                    
                    // Refresh collection status when drawer opens
                    setTimeout(() => {
                        refreshCollectionStatus();
                    }, 100);
                    
                } catch (error) {
                    console.error('üîß DEBUG: Error showing drawer:', error);
                }
            } else {
                console.error('üîß DEBUG: collectionProgressDrawer is still null or undefined');
            }
        }

        function hideCollectionProgress() {
            console.log('üîß DEBUG: hideCollectionProgress called');
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }
        
        // Populate Collection Progress drawer with real status
        function refreshCollectionStatus() {
            console.log('üîß COLLECTION: Refreshing collection status...');
            
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    console.log('üîß COLLECTION: Status data:', data);
                    updateCollectionProgressDrawer(data);
                })
                .catch(error => {
                    console.error('‚ùå COLLECTION: Error fetching status:', error);
                    updateCollectionProgressDrawer({
                        status: 'error',
                        message: 'Error fetching collection status',
                        error_message: error.message
                    });
                });
        }
        
        // Update Collection Progress drawer content
        function updateCollectionProgressDrawer(statusData) {
            // Update status and badge
            const statusElement = document.getElementById('collectionProgressStatus');
            const badgeElement = document.getElementById('collectionStatusBadge');
            const sourceElement = document.getElementById('collectionSourceText');
            
            if (statusElement) {
                statusElement.textContent = statusData.message || 'Unknown status';
            }
            
            if (badgeElement && badgeElement.classList) {
                badgeElement.textContent = statusData.status || 'Unknown';
                
                // Update badge color based on status
                badgeElement.classList.remove('bg-secondary', 'bg-primary', 'bg-success', 'bg-warning', 'bg-danger');
                switch (statusData.status) {
                    case 'running':
                        badgeElement.classList.add('bg-primary');
                        break;
                    case 'completed':
                        badgeElement.classList.add('bg-success');
                        break;
                    case 'error':
                        badgeElement.classList.add('bg-danger');
                        break;
                    default:
                        badgeElement.classList.add('bg-secondary');
                        break;
                }
            }
            
            if (sourceElement) {
                sourceElement.textContent = statusData.current_source || 'No active collection';
            }
            
            // Show/hide progress info based on status
            const progressInfo = document.getElementById('collectionProgressInfo');
            const sourcesProgress = document.getElementById('collectionSourcesProgress');
            
            if (statusData.status === 'running' || statusData.status === 'completed') {
                // Show progress information
                if (progressInfo) {
                    progressInfo.style.display = 'block';
                    
                    const startTimeElement = document.getElementById('collectionStartTime');
                    const totalItemsElement = document.getElementById('collectionTotalItems');
                    
                    if (startTimeElement && statusData.start_time) {
                        const startTime = new Date(statusData.start_time);
                        startTimeElement.textContent = startTime.toLocaleString();
                    }
                    
                    if (totalItemsElement) {
                        totalItemsElement.textContent = statusData.total_items || '0';
                    }
                }
                
                // Show sources progress
                if (sourcesProgress && statusData.sources_completed) {
                    sourcesProgress.style.display = 'block';
                    const sourcesListElement = document.getElementById('collectionSourcesList');
                    if (sourcesListElement) {
                        if (statusData.sources_completed.length > 0) {
                            sourcesListElement.textContent = statusData.sources_completed.join(', ');
                        } else {
                            sourcesListElement.textContent = 'None';
                        }
                    }
                }
            } else {
                // Hide progress information for ready/error states
                if (progressInfo) progressInfo.style.display = 'none';
                if (sourcesProgress) sourcesProgress.style.display = 'none';
            }
            
            // Add log entry about status update
            addCollectionDrawerLog(`üìä Status: ${statusData.status} - ${statusData.message}`);
            
            if (statusData.error_message) {
                addCollectionDrawerLog(`‚ùå Error: ${statusData.error_message}`);
            }
        }
        
        // Add log entry to collection drawer
        function addCollectionDrawerLog(message) {
            const logContainer = document.getElementById('collectionLog');
            if (logContainer) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
                logContainer.appendChild(logEntry);
                
                // Auto-scroll to bottom
                const container = document.getElementById('collectionLogContainer');
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            }
        }
        
        // Clear collection log
        function clearCollectionLog() {
            const logContainer = document.getElementById('collectionLog');
            if (logContainer) {
                logContainer.innerHTML = '';
            }
        }
        
        // Client-side filtering to preserve cached state changes
        function applyClientFilter(filterType, filterValue) {
            console.log(`üîß CLIENT FILTER: Applying ${filterType} = ${filterValue}`);
            
            // Get all feedback cards
            const feedbackCards = document.querySelectorAll('.fluent-card');
            let visibleCount = 0;
            
            feedbackCards.forEach(card => {
                let shouldShow = true;
                
                // Apply audience filter
                if (filterType === 'audience' && filterValue !== 'All') {
                    const audienceBadge = card.querySelector('.audience-badge');
                    if (audienceBadge) {
                        const cardAudience = audienceBadge.textContent.trim();
                        // Extract audience name from badge text (remove emojis)
                        const cleanAudience = cardAudience.replace(/[üõ†Ô∏èüë§üè¢]/g, '').trim();
                        shouldShow = cleanAudience === filterValue;
                    }
                }
                
                // Apply state filter
                if (filterType === 'state' && filterValue !== 'All') {
                    const stateBadge = card.querySelector('.state-badge');
                    if (stateBadge) {
                        const cardState = stateBadge.getAttribute('data-current-state');
                        shouldShow = cardState === filterValue;
                    }
                }
                
                // Apply source filter
                if (filterType === 'source' && filterValue !== 'All') {
                    const sourceText = card.querySelector('h6')?.textContent || '';
                    shouldShow = sourceText.includes(filterValue);
                }
                
                // Show/hide card
                if (shouldShow) {
                    card.parentElement.style.display = 'block'; // Hide the col wrapper
                    visibleCount++;
                } else {
                    card.parentElement.style.display = 'none';
                }
            });
            
            // Update filter button states
            updateFilterButtonStates(filterType, filterValue);
            
            // Update URL without page reload
            const url = new URL(window.location);
            if (filterValue === 'All') {
                url.searchParams.delete(filterType);
            } else {
                url.searchParams.set(filterType, filterValue);
            }
            
            // Preserve Fabric connection state in URL to prevent state loss
            if (fabricConnected || stateManagementEnabled) {
                url.searchParams.set('fabric_connected', 'true');
                console.log('üîß CLIENT FILTER: Preserving Fabric connection state in URL');
            }
            
            // Store current state management status before URL change
            const currentStateManagement = stateManagementEnabled;
            const currentFabricConnection = fabricConnected;
            const currentStateData = window.fabricStateData;
            
            window.history.pushState({}, '', url);
            
            // Immediately restore state management status after URL change
            stateManagementEnabled = currentStateManagement;
            fabricConnected = currentFabricConnection;
            window.fabricStateData = currentStateData;
            
            console.log('üîß CLIENT FILTER: State preserved after URL update:', {
                stateManagementEnabled,
                fabricConnected,
                hasStateData: !!(currentStateData && Object.keys(currentStateData).length > 0)
            });
            
            // Ensure cached changes are preserved and sync button is maintained
            if (stateManagementEnabled && hasUnsavedChanges) {
                updateSyncButton();
            }
            
            // Preserve Fabric connection UI state after filtering
            if (fabricConnected) {
                preserveFabricConnectionUI();
            }
            
            console.log(`‚úÖ CLIENT FILTER: Showing ${visibleCount} cards for ${filterType} = ${filterValue}`);
            console.log(`‚úÖ CLIENT FILTER: Cached changes preserved: ${Object.keys(cachedStateChanges).length} items`);
        }
        
        // Update filter button visual states
        function updateFilterButtonStates(activeFilterType, activeValue) {
            // Update audience buttons
            if (activeFilterType === 'audience') {
                document.querySelectorAll('[data-filter-type="audience"]').forEach(btn => {
                    const value = btn.getAttribute('data-filter-value');
                    btn.className = btn.className.replace(/btn-(primary|secondary|success|info|outline-primary|outline-secondary|outline-success|outline-info)/g, '');
                    
                    if (value === activeValue) {
                        if (value === 'Developer') btn.classList.add('btn-primary');
                        else if (value === 'Customer') btn.classList.add('btn-success');
                        else if (value === 'ISV') btn.classList.add('btn-info');
                        else btn.classList.add('btn-secondary');
                    } else {
                        if (value === 'Developer') btn.classList.add('btn-outline-primary');
                        else if (value === 'Customer') btn.classList.add('btn-outline-success');
                        else if (value === 'ISV') btn.classList.add('btn-outline-info');
                        else btn.classList.add('btn-outline-secondary');
                    }
                });
            }
        }
        
        // Global domain dropdown positioning
        let globalDomainDropdown = null;
        
        // Update domain function
        function updateDomain(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${currentDomain}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            // Create domain dropdown
            showDomainDropdown(feedbackId, currentDomain);
        }
        
        function showDomainDropdown(feedbackId, currentDomain) {
            // Store current scroll position to prevent scroll changes
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Remove any existing dropdown
            if (globalDomainDropdown) {
                globalDomainDropdown.remove();
                globalDomainDropdown = null;
            }
            
            // Find the actions button for positioning
            const actionsBtn = document.querySelector(`[data-feedback-id="${feedbackId}"][onclick*="toggleActionsMenu"]`);
            if (!actionsBtn) {
                console.error('Could not find actions button for positioning');
                return;
            }
            
            // Calculate position relative to viewport (no scrolling)
            const rect = actionsBtn.getBoundingClientRect();
            
            // Create dropdown with event delegation to prevent scroll events
            globalDomainDropdown = document.createElement('div');
            globalDomainDropdown.className = 'global-domain-dropdown';
            globalDomainDropdown.innerHTML = `
                <div class="dropdown-header">Select Domain:</div>
                <div class="dropdown-item" data-domain="GETTING_STARTED">üöÄ Getting Started</div>
                <div class="dropdown-item" data-domain="GOVERNANCE">üèõÔ∏è Governance</div>
                <div class="dropdown-item" data-domain="USER_EXPERIENCE">üë§ User Experience</div>
                <div class="dropdown-item" data-domain="AUTHENTICATION">üîê Authentication & Security</div>
                <div class="dropdown-item" data-domain="PERFORMANCE">‚ö° Performance & Scalability</div>
                <div class="dropdown-item" data-domain="INTEGRATION">üîó Integration & APIs</div>
                <div class="dropdown-item" data-domain="ANALYTICS">üìä Analytics & Reporting</div>
                <div class="dropdown-divider"></div>
                <div class="dropdown-item text-danger" data-action="cancel">Cancel</div>
            `;
            
            // Add event delegation to prevent scroll issues
            globalDomainDropdown.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const item = e.target.closest('.dropdown-item');
                if (item) {
                    const domain = item.getAttribute('data-domain');
                    const action = item.getAttribute('data-action');
                    
                    if (action === 'cancel') {
                        hideGlobalDropdown();
                    } else if (domain) {
                        saveDomainChange(feedbackId, domain);
                    }
                }
                
                // Restore scroll position after any action
                setTimeout(() => {
                    window.scrollTo(currentScrollLeft, currentScrollTop);
                }, 0);
                
                return false;
            });
            
            // Position relative to viewport (fixed positioning)
            globalDomainDropdown.style.position = 'fixed';
            globalDomainDropdown.style.left = rect.left + 'px';
            globalDomainDropdown.style.top = (rect.bottom + 5) + 'px';
            globalDomainDropdown.style.backgroundColor = 'white';
            globalDomainDropdown.style.border = '1px solid #ddd';
            globalDomainDropdown.style.borderRadius = '4px';
            globalDomainDropdown.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            globalDomainDropdown.style.zIndex = '10000';
            globalDomainDropdown.style.minWidth = '250px';
            
            document.body.appendChild(globalDomainDropdown);
            
            console.log(`‚úÖ Global dropdown positioned at: ${globalDomainDropdown.style.left} ${globalDomainDropdown.style.top}`);
            console.log(`üìç Scroll position preserved: ${currentScrollLeft}, ${currentScrollTop}`);
            
            // Add click outside to close with scroll preservation
            setTimeout(() => {
                document.addEventListener('click', function hideGlobalDropdownOutsidePreserveScroll(event) {
                    if (globalDomainDropdown && !globalDomainDropdown.contains(event.target)) {
                        hideGlobalDropdown();
                        // Restore scroll position
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        document.removeEventListener('click', hideGlobalDropdownOutsidePreserveScroll);
                    }
                });
            }, 100);
        }
        
        function hideGlobalDropdown() {
            if (globalDomainDropdown) {
                globalDomainDropdown.remove();
                globalDomainDropdown = null;
                document.removeEventListener('click', hideGlobalDropdownOutside);
            }
        }
        
        function hideGlobalDropdownOutside(event) {
            if (globalDomainDropdown && !globalDomainDropdown.contains(event.target)) {
                hideGlobalDropdown();
            }
        }
        
        function saveDomainChange(feedbackId, newDomain) {
            console.log(`üè∑Ô∏è Domain changing: ${feedbackId} ‚Üí ${newDomain}`);
            
            // Store current scroll position before any operations
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            hideGlobalDropdown();
            
            // Map internal domain codes to display names
            const domainNames = {
                'GETTING_STARTED': 'Getting Started',
                'GOVERNANCE': 'Governance',
                'USER_EXPERIENCE': 'User Experience',
                'AUTHENTICATION': 'Authentication & Security',
                'PERFORMANCE': 'Performance & Scalability',
                'INTEGRATION': 'Integration & APIs',
                'ANALYTICS': 'Analytics & Reporting'
            };
            
            // Map domain codes to colors
            const domainColors = {
                'GETTING_STARTED': '#20c997',
                'GOVERNANCE': '#6f42c1',
                'USER_EXPERIENCE': '#28a745',
                'AUTHENTICATION': '#dc3545',
                'PERFORMANCE': '#fd7e14',
                'INTEGRATION': '#17a2b8',
                'ANALYTICS': '#ffc107'
            };
            
            // Send to server using the correct SQL endpoint for Fabric updates
            fetch('/api/update_domain_sql', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    feedback_id: feedbackId,
                    new_domain: newDomain
                })
            })
            .then(response => {
                // Handle authentication errors
                if (response.status === 403) {
                    window.scrollTo(currentScrollLeft, currentScrollTop);
                    console.error('‚ùå Domain update denied: Not connected to Fabric');
                    alert('‚ùå Not connected to Fabric. Please sync with Fabric first to enable domain updates.');
                    return;
                }
                return response.json();
            })
            .then(data => {
                // Only proceed if data exists (not undefined from 403 response)
                if (!data) return;
                
                // Restore scroll position immediately
                window.scrollTo(currentScrollLeft, currentScrollTop);
                
                if (data.success) {
                    console.log(`‚úÖ Domain updated successfully: ${newDomain}`);
                    
                    // Update the UI immediately
                    const badgeElement = document.querySelector(`[data-feedback-id="${feedbackId}"][data-current-state]`);
                    const parentCard = badgeElement ? badgeElement.closest('.fluent-card, .card') : null;
                    if (parentCard) {
                        const domainBadge = parentCard.querySelector('.domain-badge');
                        if (domainBadge) {
                            domainBadge.textContent = domainNames[newDomain] || newDomain;
                            domainBadge.style.backgroundColor = domainColors[newDomain] || '#6c757d';
                            domainBadge.setAttribute('data-domain-code', newDomain);
                        }
                    }
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success alert-dismissible fade show';
                    successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
                    successMsg.innerHTML = `
                        ‚úÖ Domain updated successfully: ${domainNames[newDomain] || newDomain}
                        <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
                    `;
                    document.body.appendChild(successMsg);
                    setTimeout(() => {
                        if (successMsg.parentElement) {
                            successMsg.remove();
                        }
                    }, 3000);
                } else {
                    console.error('‚ùå Domain update failed:', data.message);
                    alert('‚ùå Domain update failed: ' + data.message);
                }
            })
            .catch(error => {
                // Restore scroll position on error too
                window.scrollTo(currentScrollLeft, currentScrollTop);
                console.error('‚ùå Domain update error:', error);
                alert('‚ùå Domain update failed: ' + error.message);
            });
        }
        
        // Add CSS for domain dropdown
        const style = document.createElement('style');
        style.textContent = `
            .global-domain-dropdown {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            }
            .global-domain-dropdown .dropdown-header {
                padding: 8px 16px;
                font-weight: bold;
                color: #6c757d;
                border-bottom: 1px solid #eee;
                background-color: #f8f9fa;
                font-size: 0.875rem;
            }
            .global-domain-dropdown .dropdown-item {
                padding: 8px 16px;
                cursor: pointer;
                font-size: 0.875rem;
                border-bottom: 1px solid #f0f0f0;
            }
            .global-domain-dropdown .dropdown-item:hover {
                background-color: #f8f9fa;
            }
            .global-domain-dropdown .dropdown-divider {
                height: 1px;
                background-color: #ddd;
                margin: 4px 0;
            }
            .global-domain-dropdown .text-danger {
                color: #dc3545 !important;
            }
        `;
        document.head.appendChild(style);
        
        // FINAL OVERRIDE - This will definitely take precedence with scroll preservation
        window.updateDomain = function(feedbackId, currentDomain) {
            console.log(`üè∑Ô∏è FINAL OVERRIDE - Domain update requested: ${feedbackId} ‚Üí current: ${currentDomain}`);
            
            // IMMEDIATELY capture and preserve scroll position
            const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const currentScrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            console.log(`üìç FINAL OVERRIDE - Captured scroll position: ${currentScrollLeft}, ${currentScrollTop}`);
            
            // Check if state management is enabled (allow if we have state data or URL parameter indicates connection)
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            
            console.log('üîç FINAL OVERRIDE - Connection check:', {
                stateManagementEnabled,
                hasStateData: !!hasStateData,
                urlIndicatesConnection,
                fabricConnected,
                sessionToken: '{{ stored_token or "" }}' ? 'present' : 'absent'
            });
            
            // Check session token instead of localStorage for connection validation
            const sessionToken = '{{ stored_token or "" }}';
            const hasValidSession = sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None';
            
            // Allow if ANY valid connection indicator is present
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected && !hasValidSession) {
                console.log('‚ùå FINAL OVERRIDE - No connection indicators found - showing alert');
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                // Restore scroll position after alert
                setTimeout(() => {
                    window.scrollTo(currentScrollLeft, currentScrollTop);
                    console.log(`üìç FINAL OVERRIDE - Scroll restored after alert: ${currentScrollLeft}, ${currentScrollTop}`);
                }, 0);
                return;
            }
            
            console.log('‚úÖ FINAL OVERRIDE - Connection check passed - showing domain dropdown');
            
            // Wrap the showDomainDropdown call to ensure scroll preservation
            setTimeout(() => {
                // Create domain dropdown
                if (typeof showDomainDropdown === 'function') {
                    showDomainDropdown(feedbackId, currentDomain);
                    // Force scroll restoration immediately after dropdown creation
                    setTimeout(() => {
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        console.log(`üìç FINAL OVERRIDE - Scroll forcibly restored after dropdown: ${currentScrollLeft}, ${currentScrollTop}`);
                    }, 0);
                } else {
                    console.log('üîß FINAL OVERRIDE - showDomainDropdown not found, creating inline dropdown');
                    // Fallback: create a simple dropdown inline
                    const newDomain = prompt('Select new domain:\n1. GOVERNANCE\n2. USER_EXPERIENCE\n3. AUTHENTICATION\n4. PERFORMANCE\n5. INTEGRATION\n6. ANALYTICS\n\nEnter domain name:', currentDomain);
                    if (newDomain && newDomain.trim()) {
                        if (typeof saveDomainChange === 'function') {
                            saveDomainChange(feedbackId, newDomain.trim().toUpperCase());
                        } else {
                            console.log('üîß FINAL OVERRIDE - saveDomainChange not found either, calling API directly');
                            // Direct API call with scroll preservation
                            fetch('/api/update_domain_sql', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    feedback_id: feedbackId,
                                    new_domain: newDomain.trim().toUpperCase()
                                })
                            })
                            .then(response => {
                                // Restore scroll immediately on response
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                                return response.json();
                            })
                            .then(data => {
                                if (data.success) {
                                    alert('‚úÖ Domain updated successfully!');
                                } else {
                                    alert('‚ùå Domain update failed: ' + data.message);
                                }
                                // Restore scroll after alert
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                            })
                            .catch(error => {
                                alert('‚ùå Domain update error: ' + error.message);
                                // Restore scroll after error
                                window.scrollTo(currentScrollLeft, currentScrollTop);
                            });
                        }
                    }
                    // Restore scroll after prompt regardless
                    setTimeout(() => {
                        window.scrollTo(currentScrollLeft, currentScrollTop);
                        console.log(`üìç FINAL OVERRIDE - Scroll restored after prompt: ${currentScrollLeft}, ${currentScrollTop}`);
                    }, 0);
                }
            }, 0);
        };
        
        // Also override updateNotes
        window.updateNotes = function(feedbackId, currentNotes) {
            console.log(`üìù FINAL OVERRIDE - Notes update requested: ${feedbackId}`);
            
            // Same connection check as domain update
            const urlParams = new URLSearchParams(window.location.search);
            const hasStateData = window.fabricStateData && Object.keys(window.fabricStateData).length > 0;
            const urlIndicatesConnection = urlParams.get('fabric_connected') === 'true';
            const sessionToken = '{{ stored_token or "" }}';
            const hasValidSession = sessionToken && sessionToken.trim() !== '' && sessionToken !== 'None';
            
            if (!stateManagementEnabled && !hasStateData && !urlIndicatesConnection && !fabricConnected && !hasValidSession) {
                alert('Please click "Sync with Fabric" first to connect to the SQL database and enable state management.');
                return;
            }
            
            console.log('‚úÖ FINAL OVERRIDE - Notes update allowed');
            const newNotes = prompt('Enter notes for this feedback:', currentNotes || '');
            if (newNotes !== null) {
                console.log(`üíæ FINAL OVERRIDE - Saving notes for ${feedbackId}: ${newNotes}`);
                // TODO: Implement notes API call
                alert('Notes functionality to be implemented');
            }
        };
        
        console.log('üîß FINAL OVERRIDE - Functions registered on window object');
        
        // ALSO OVERRIDE toggleActionsMenu - this is where the early check is happening
    </script>

    <!-- Fabric Auth Drawer -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="fabricAuthDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-shield-check me-2"></i>Fabric Authentication
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" onclick="hideFabricAuth()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Current Token Status -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Connection Status</span>
                    <span id="fabricConnectionStatus" class="badge bg-secondary">Not Connected</span>
                </div>
                <div class="alert" id="fabricStatusAlert" role="alert" style="display: none;">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status" id="fabricAuthSpinner" style="display: none;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span id="fabricStatusText">Ready to connect</span>
                    </div>
                </div>
            </div>

            <!-- Token Input -->
            <div class="mb-4">
                <h6 class="text-muted mb-3">Fabric Bearer Token</h6>
                <div class="mb-3">
                    <label for="fabricAuthToken" class="form-label">Bearer Token</label>
                    <div class="input-group">
                        <input type="password" class="form-control" id="fabricAuthToken" placeholder="Paste your Fabric bearer token here...">
                        <button class="btn btn-outline-secondary" type="button" onclick="toggleTokenVisibility()">
                            <i class="bi bi-eye" id="tokenVisibilityIcon"></i>
                        </button>
                    </div>
                    <div class="form-text">
                        This token enables state management and Fabric Lakehouse operations.
                    </div>
                </div>
            </div>

            <!-- Current Token Info -->
            <div class="mb-4" id="currentTokenInfo" style="display: none;">
                <h6 class="text-muted mb-2">Current Token</h6>
                <div class="card">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="small text-muted">Last Validated</span>
                            <span class="badge bg-success" id="lastValidatedTime">Never</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-primary" id="validateTokenBtn" onclick="validateFabricToken()">
                    <i class="bi bi-check-circle me-1"></i>Validate & Connect
                </button>
                <button class="btn btn-outline-warning" id="updateTokenBtn" onclick="updateFabricToken()" style="display: none;">
                    <i class="bi bi-arrow-clockwise me-1"></i>Update Token
                </button>
                <button class="btn btn-outline-danger" id="clearTokenBtn" onclick="clearFabricToken()" style="display: none;">
                    <i class="bi bi-x-circle me-1"></i>Clear Token
                </button>
            </div>

            <!-- Validation Log -->
            <div class="mt-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Validation Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearFabricLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="fabricLogContainer" style="height: 200px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="fabricLog" class="font-monospace small"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Collection Progress Drawer (simplified for feedback viewer) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="collectionProgressDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-activity me-2"></i>Collection Progress
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" onclick="hideCollectionProgress()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Collection Status Display -->
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span id="collectionProgressStatus">Ready to start...</span>
                    <span class="badge bg-secondary" id="collectionStatusBadge">Ready</span>
                </div>
                <div class="card-body">
                    <div id="collectionSourceText">No active collection</div>
                    
                    <!-- Progress Information -->
                    <div class="row mt-3" id="collectionProgressInfo" style="display: none;">
                        <div class="col-md-6">
                            <small class="text-muted">Started</small>
                            <div id="collectionStartTime">-</div>
                        </div>
                        <div class="col-md-6">
                            <small class="text-muted">Total Items</small>
                            <div id="collectionTotalItems">0</div>
                        </div>
                    </div>
                    
                    <!-- Sources Progress -->
                    <div class="mt-3" id="collectionSourcesProgress" style="display: none;">
                        <small class="text-muted">Sources Completed</small>
                        <div id="collectionSourcesList">None</div>
                    </div>
                </div>
            </div>
            
            <!-- Collection Log -->
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>Collection Log</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearCollectionLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="collectionLogContainer" style="height: 250px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="collectionLog" class="font-monospace small"></div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mt-3 d-flex gap-2">
                <a href="/" class="btn btn-primary">
                    <i class="bi bi-plus-circle me-1"></i>Start New Collection
                </a>
                <button class="btn btn-outline-secondary" onclick="refreshCollectionStatus()">
                    <i class="bi bi-arrow-clockwise me-1"></i>Refresh Status
                </button>
            </div>
        </div>
    </div>

    <script>
        // Domain sync function for the domain sync button
        async function syncDomainsFromState() {
            const domainSyncBtn = document.getElementById('domainSyncBtn');
            const originalContent = domainSyncBtn.innerHTML;
            
            try {
                // Show loading state
                domainSyncBtn.innerHTML = '<i class="bi bi-arrow-repeat me-1 spin"></i>Syncing...';
                domainSyncBtn.disabled = true;
                
                console.log('üîÑ Starting domain sync from FeedbackState to Feedback table...');
                
                const response = await fetch('/api/fabric/domains/sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    console.log('‚úÖ Domain sync completed successfully:', result);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.className = 'alert alert-success alert-dismissible fade show';
                    successMsg.innerHTML = `
                        ‚úÖ <strong>Domain Sync Complete!</strong> ${result.message}
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    `;
                    document.querySelector('.fluent-container').insertBefore(successMsg, document.querySelector('#filter-section-container'));
                    setTimeout(() => successMsg.remove(), 8000);
                    
                    // Refresh the page to show updated domains
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                    
                } else {
                    console.error('‚ùå Domain sync failed:', result);
                    alert('Domain sync failed: ' + result.message);
                }
                
            } catch (error) {
                console.error('‚ùå Error during domain sync:', error);
                alert('Error during domain sync: ' + error.message);
            } finally {
                // Restore button state
                domainSyncBtn.innerHTML = originalContent;
                domainSyncBtn.disabled = false;
            }
        }
        
        // CSS for spinning animation
        const spinStyle = document.createElement('style');
        spinStyle.textContent = `
            .spin {
                animation: spin 1s linear infinite;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(spinStyle);

        // Feedback Detail Modal
        function showFeedbackDetail(element) {
            const fullText = element.textContent.trim();
            
            // Create modal if it doesn't exist
            let modal = document.getElementById('feedbackDetailModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'feedbackDetailModal';
                modal.className = 'modal fade';
                modal.setAttribute('tabindex', '-1');
                modal.setAttribute('aria-hidden', 'true');
                modal.innerHTML = `
                    <div class="modal-dialog modal-dialog-centered modal-lg">
                        <div class="modal-content" style="height: 70vh;">
                            <div class="modal-header">
                                <h5 class="modal-title">Feedback Details</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body" style="overflow-y: auto;">
                                <p id="feedbackDetailText" style="white-space: pre-wrap; font-size: 1rem; line-height: 1.6;"></p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            // Set content
            document.getElementById('feedbackDetailText').textContent = fullText;
            
            // Show modal
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }
    </script>

</body>
</html>
