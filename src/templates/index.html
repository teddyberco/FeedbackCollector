<!DOCTYPE html>
<html>
<head>
    <title>Feedback Collector</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .keyword-list {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 1em;
        }
        .keyword-actions button {
            margin-right: 0.5em;
        }
        .status-message {
            margin-top: 1em;
            display: none; /* Hidden by default */
        }
        /* NO iframe-container CSS here */
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1>Feedback Collector</h1>
        <p>
            <a href="/feedback" class="btn btn-info mt-2">View Collected Feedback</a>
            <button class="btn btn-outline-primary mt-2" id="collectionProgressBtn" onclick="toggleCollectionProgress()">
                <i class="bi bi-activity me-1"></i>Collection Progress
                <span class="badge bg-secondary ms-1" id="progressBadge">Ready</span>
            </button>
            <a href="/insights" class="btn btn-secondary mt-2">View Feedback Insights</a>
        </p>
        
        <div class="row mt-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Keywords Management</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <input type="text" id="newKeyword" class="form-control" placeholder="Enter new keyword">
                        </div>
                        <button class="btn btn-primary mb-3" onclick="addKeyword()">Add Keyword</button>
                        <div class="keyword-list">
                            <ul id="keywordList" class="list-group">
                                <!-- Keywords will be populated by JavaScript on load and updates -->
                            </ul>
                        </div>
                        <div class="keyword-actions mt-3">
                            <button class="btn btn-success" onclick="saveKeywords()">Save Keywords</button>
                            <button class="btn btn-warning" onclick="restoreDefaultKeywords()">Restore Defaults</button>
                        </div>
                        <div id="keywordsStatus" class="status-message"></div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Actions</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="adoWorkItemId" class="form-label">ADO Parent Work Item ID (optional)</label>
                            <input type="text" class="form-control" id="adoWorkItemId" placeholder="e.g., 1319103" value="1319103">
                            <div class="form-text">Leave empty to use default work item from configuration</div>
                        </div>
                        <button class="btn btn-primary" onclick="collectFeedback()">Collect Feedback (to CSV & Memory)</button>
                        <div id="results" class="mt-3"></div>

                        <hr class="my-4">
                        <h5>Optional: Write to Fabric Lakehouse</h5>
                        <div class="mb-3">
                            <label for="fabricToken" class="form-label">Fabric Access Token (Bearer)</label>
                            <input type="password" class="form-control" id="fabricToken" placeholder="Paste your Fabric token here">
                            <div class="form-text">This token will be used to authenticate with Fabric. It is not stored.</div>
                        </div>
                        <button class="btn btn-success" onclick="writeToFabric()">Write Last Collected to Fabric</button>
                        <div id="fabricResults" class="mt-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </div> <!-- End of main collector container -->

    <!-- Collection Progress Drawer (hidden initially) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="collectionProgressDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-activity me-2"></i>Collection Progress
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="closeCollectionDrawer" onclick="hideCollectionProgress()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Progress Overview -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Overall Progress</span>
                    <span id="collectionProgressPercentage" class="badge bg-primary">0%</span>
                </div>
                <div class="progress mb-2">
                    <div class="progress-bar" role="progressbar" id="collectionProgressBar" style="width: 0%"></div>
                </div>
                <div class="d-flex justify-content-between">
                    <small class="text-muted" id="collectionProgressStatus">Initializing...</small>
                    <small class="text-muted" id="collectionProgressETA">ETA: --</small>
                </div>
            </div>

            <!-- Current Source -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Current Source</h6>
                <div class="alert alert-secondary d-flex align-items-center" id="currentCollectionSource">
                    <div class="spinner-border spinner-border-sm me-2" role="status" id="collectionSpinner" style="display: none;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span id="collectionSourceText">Not started</span>
                </div>
            </div>

            <!-- Source Progress -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Source Progress</h6>
                <div class="row">
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="redditCount">0</div>
                                <small class="text-muted">Reddit</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-warning" id="redditProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="fabricCount">0</div>
                                <small class="text-muted">Fabric</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-info" id="fabricProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="githubCount">0</div>
                                <small class="text-muted">GitHub</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-success" id="githubProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="adoCount">0</div>
                                <small class="text-muted">ADO</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-primary" id="adoProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Log -->
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Collection Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearCollectionLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="collectionLogContainer" style="height: 250px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="collectionLog" class="font-monospace small"></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-outline-danger" id="cancelOperation" onclick="cancelOperation()" disabled>
                    <i class="bi bi-x-circle me-1"></i>Cancel Operation
                </button>
            </div>
        </div>
    </div>

    <script>
        let lastCollectionHadData = false; // Flag to track if collection yielded data
        let currentKeywords = []; // Local cache of keywords for the UI
        let collectionProgressDrawer = null;
        let collectionProgressInterval = null;
        let collectionStartTime = null;
        let collectionOperationId = null;

        // Function to render the keyword list in the UI
        function renderKeywordList(keywords) {
            const list = document.getElementById('keywordList');
            list.innerHTML = ''; // Clear existing list
            keywords.forEach(keyword => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.textContent = keyword;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'btn btn-danger btn-sm';
                removeButton.textContent = 'Remove';
                removeButton.onclick = function() { removeKeyword(keyword); };
                
                li.appendChild(removeButton);
                list.appendChild(li);
            });
            currentKeywords = [...keywords]; // Update local cache
        }

        // Function to display status messages for keyword operations
        function showKeywordsStatus(message, isError = false) {
            const statusDiv = document.getElementById('keywordsStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message alert ${isError ? 'alert-danger' : 'alert-success'}`;
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000); // Hide after 5 seconds
        }

        // Load initial keywords when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/api/keywords')
                .then(response => response.json())
                .then(data => {
                    renderKeywordList(data);
                })
                .catch(error => {
                    console.error('Error fetching initial keywords:', error);
                    showKeywordsStatus('Error loading initial keywords.', true);
                });
        });

        function addKeyword() {
            const input = document.getElementById('newKeyword');
            const keyword = input.value.trim();
            if (keyword && !currentKeywords.includes(keyword)) {
                currentKeywords.push(keyword);
                renderKeywordList(currentKeywords); // Re-render the list
                input.value = '';
            } else if (currentKeywords.includes(keyword)) {
                showKeywordsStatus(`Keyword "${keyword}" already exists.`, true);
            }
        }

        function removeKeyword(keywordToRemove) {
            currentKeywords = currentKeywords.filter(k => k !== keywordToRemove);
            renderKeywordList(currentKeywords); // Re-render the list
        }
        
        function saveKeywords() {
            fetch('/api/keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ keywords: currentKeywords }), 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus('Keywords saved successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error saving keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error saving keywords.', true);
            });
        }

        function restoreDefaultKeywords() {
            if (!confirm('Are you sure you want to restore default keywords? This will replace your current list.')) {
                return;
            }
            fetch('/api/keywords/restore_default', {
                method: 'POST', 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus(data.message || 'Default keywords restored successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error restoring default keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error restoring default keywords.', true);
            });
        }

        // Toggle the collection progress drawer
        function toggleCollectionProgress() {
            const drawer = document.getElementById('collectionProgressDrawer');
            
            if (!collectionProgressDrawer) {
                collectionProgressDrawer = new bootstrap.Offcanvas(drawer);
            }
            collectionProgressDrawer.show();
        }

        // Hide the collection progress drawer
        function hideCollectionProgress() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Initialize Collection progress (button is always visible)
        function showCollectionProgressDrawer() {
            resetCollectionDrawer();
            collectionStartTime = Date.now();
            
            // Update progress badge to show active state
            const progressBadge = document.getElementById('progressBadge');
            progressBadge.textContent = '0%';
            progressBadge.className = 'badge bg-primary ms-1'; // Change to primary blue when active
        }

        // Reset collection drawer to initial state
        function resetCollectionDrawer() {
            document.getElementById('collectionProgressBar').style.width = '0%';
            document.getElementById('collectionProgressPercentage').textContent = '0%';
            document.getElementById('collectionProgressStatus').textContent = 'Ready to start...';
            document.getElementById('collectionProgressETA').textContent = 'ETA: --';
            document.getElementById('collectionSourceText').textContent = 'Not started';
            // Hide spinner initially
            document.getElementById('collectionSpinner').style.display = 'none';
            // Set initial alert color to neutral
            document.getElementById('currentCollectionSource').className = 'alert alert-secondary d-flex align-items-center';
            document.getElementById('collectionLog').innerHTML = '';
            
            // Ensure cancel button is enabled and properly styled
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = false;
            cancelButton.classList.remove('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            // Reset source counts and progress
            ['reddit', 'fabric', 'github', 'ado'].forEach(source => {
                document.getElementById(`${source}Count`).textContent = '0';
                document.getElementById(`${source}Progress`).style.width = '0%';
            });
            
            // Don't add log until collection starts
        }

        // Add log entry to collection drawer
        function addCollectionLog(message, type = 'info') {
            const logContainer = document.getElementById('collectionLog');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `mb-1 text-${type}`;
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            
            logContainer.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('collectionLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Update collection progress
        function updateCollectionProgress(progress, status, currentSource, sourceCounts = {}) {
            // Update main progress bar in drawer
            const mainProgressBar = document.getElementById('collectionProgressBar');
            if (mainProgressBar) {
                mainProgressBar.style.width = `${progress}%`;
                document.getElementById('collectionProgressPercentage').textContent = `${Math.round(progress)}%`;
                document.getElementById('collectionProgressStatus').textContent = status;
                document.getElementById('collectionSourceText').textContent = currentSource;
            }
            
            // Update progress button badge
            const progressBadge = document.getElementById('progressBadge');
            if (progressBadge) {
                progressBadge.textContent = `${Math.round(progress)}%`;
            }
            
            // Save progress state for persistence
            saveProgressState();
            
            // Show spinner when collection is active and change alert color
            const spinner = document.getElementById('collectionSpinner');
            const currentSourceDiv = document.getElementById('currentCollectionSource');
            if (spinner && progress > 0 && progress < 100) {
                spinner.style.display = 'inline-block';
                currentSourceDiv.className = 'alert alert-info d-flex align-items-center';
            } else if (spinner && progress >= 100) {
                spinner.style.display = 'none';
                currentSourceDiv.className = 'alert alert-success d-flex align-items-center';
            }
            
            // Update source counts and progress
            Object.keys(sourceCounts).forEach(source => {
                const countElement = document.getElementById(`${source}Count`);
                const progressElement = document.getElementById(`${source}Progress`);
                if (countElement && progressElement) {
                    const count = sourceCounts[source] || 0;
                    countElement.textContent = count;
                    // Set progress to 100% if this source is complete, 50% if in progress, 0% if not started
                    if (currentSource.toLowerCase().includes(source)) {
                        progressElement.style.width = '50%';
                    } else if (count > 0) {
                        progressElement.style.width = '100%';
                    }
                }
            });
            
            // Calculate ETA
            if (progress > 0 && progress < 100 && collectionStartTime) {
                const elapsed = Date.now() - collectionStartTime;
                const estimatedTotal = (elapsed / progress) * 100;
                const remaining = Math.max(0, estimatedTotal - elapsed);
                const etaMinutes = Math.floor(remaining / 60000);
                const etaSeconds = Math.floor((remaining % 60000) / 1000);
                const etaElement = document.getElementById('collectionProgressETA');
                if (etaElement) {
                    etaElement.textContent = `ETA: ${etaMinutes}m ${etaSeconds}s`;
                }
            }
        }

        // Complete collection operation
        function completeCollectionOperation(success, message, results = {}) {
            document.getElementById('collectionSpinner').style.display = 'none';
            
            // Disable cancel button when collection is complete - ensure visual feedback
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = true;
            cancelButton.classList.add('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            const progressBadge = document.getElementById('progressBadge');
            
            if (success) {
                updateCollectionProgress(100, 'Collection completed successfully', 'All sources processed');
                addCollectionLog(`✅ ${message}`, 'success');
                
                // Update final counts
                Object.keys(results).forEach(source => {
                    if (source !== 'total') {
                        document.getElementById(`${source}Count`).textContent = results[source] || 0;
                        document.getElementById(`${source}Progress`).style.width = '100%';
                    }
                });
                
                // Update badge to show completion
                progressBadge.textContent = 'Complete';
                progressBadge.className = 'badge bg-success ms-1';
            } else {
                addCollectionLog(`❌ ${message}`, 'danger');
                // Update badge to show error
                progressBadge.textContent = 'Error';
                progressBadge.className = 'badge bg-danger ms-1';
            }
            
            // Save progress state
            saveProgressState();
        }

        // Close collection drawer
        function closeCollectionDrawer() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Cancel current operation (collection or Fabric write)
        function cancelOperation() {
            const currentSource = document.getElementById('collectionSourceText').textContent;
            
            if (currentSource.includes('Fabric') || currentSource.includes('Writing')) {
                addCollectionLog('🛑 Fabric write cancellation requested...', 'warning');
                // TODO: Implement actual Fabric write cancellation via API
            } else {
                addCollectionLog('🛑 Collection cancellation requested...', 'warning');
                // TODO: Implement actual collection cancellation
            }
            
            document.getElementById('cancelOperation').disabled = true;
        }

        // Clear collection log
        function clearCollectionLog() {
            document.getElementById('collectionLog').innerHTML = '';
        }

        // Start Fabric write progress (reuse collection drawer for Fabric writing)
        function startFabricWriteProgress() {
            // Update drawer to show Fabric writing state
            document.getElementById('collectionProgressStatus').textContent = 'Initializing Fabric write operation...';
            document.getElementById('collectionSourceText').textContent = 'Preparing to write to Fabric Lakehouse';
            document.getElementById('collectionSpinner').style.display = 'inline-block';
            document.getElementById('currentCollectionSource').className = 'alert alert-warning d-flex align-items-center';
            
            // Re-enable cancel button for Fabric operation - ensure visual feedback
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = false;
            cancelButton.classList.remove('disabled');
            
            // Add initial logging only
            addCollectionLog('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'secondary');
            addCollectionLog('🏗️ Preparing Fabric Lakehouse write operation...', 'info');
            
            // Save progress state
            saveProgressState();
        }
        
        // Progressive Fabric logging that happens during actual API calls
        function addFabricProgressLogs() {
            // Simulate realistic timing for actual Fabric operations
            setTimeout(() => {
                addCollectionLog('📋 Validating Bearer token and permissions...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Validating authentication';
            }, 100);
            
            setTimeout(() => {
                addCollectionLog('🌐 Establishing connection to Fabric API endpoints...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Connecting to Fabric services';
            }, 800);
            
            setTimeout(() => {
                addCollectionLog('📊 Preparing feedback data for Lakehouse ingestion...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Preparing data payload';
            }, 1500);
            
            setTimeout(() => {
                addCollectionLog('🔐 Authenticating with Microsoft Fabric services...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Authenticating with Fabric';
            }, 2200);
            
            setTimeout(() => {
                addCollectionLog('📁 Targeting Lakehouse table for data ingestion...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Initiating data transfer';
            }, 3000);
        }

        // Poll for Fabric completion (reuse collection drawer)
        function pollForFabricCompletion(operationId, resultDiv) {
            const pollInterval = setInterval(() => {
                fetch(`/api/fabric_progress/${operationId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.completed) {
                            clearInterval(pollInterval);
                            
                            const progressBadge = document.getElementById('progressBadge');
                            const spinner = document.getElementById('collectionSpinner');
                            const currentSourceDiv = document.getElementById('currentCollectionSource');
                            const cancelButton = document.getElementById('cancelOperation');
                            
                            // Disable cancel button when Fabric operation completes - ensure visual feedback
                            cancelButton.disabled = true;
                            cancelButton.classList.add('disabled');
                            
                            if (data.success) {
                                // Enhanced success logging
                                addCollectionLog('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'secondary');
                                addCollectionLog('🎉 Fabric write operation completed successfully!', 'success');
                                addCollectionLog('📊 All feedback data has been written to Lakehouse', 'success');
                                addCollectionLog('💾 Data is now available for analytics and reporting', 'success');
                                addCollectionLog('🔍 You can query the data using Fabric SQL endpoints', 'info');
                                addCollectionLog('📈 Data ingestion pipeline completed without errors', 'success');
                                
                                progressBadge.textContent = 'Complete';
                                progressBadge.className = 'badge bg-success ms-1';
                                spinner.style.display = 'none';
                                currentSourceDiv.className = 'alert alert-success d-flex align-items-center';
                                document.getElementById('collectionSourceText').textContent = 'Fabric write completed successfully';
                                document.getElementById('collectionProgressStatus').textContent = 'All operations completed - data available in Lakehouse';
                                
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <strong>🎉 Fabric Lakehouse Write Successful!</strong><br>
                                        <small><strong>Status:</strong> ${data.message}</small><br>
                                        <small><strong>Result:</strong> Data successfully ingested to Lakehouse</small><br>
                                        <small><strong>Next:</strong> Data is now available for analytics</small>
                                    </div>
                                `;
                            } else {
                                // Enhanced error logging
                                addCollectionLog('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'secondary');
                                addCollectionLog('❌ Fabric write operation failed', 'danger');
                                addCollectionLog(`🔍 Failure reason: ${data.message}`, 'danger');
                                addCollectionLog('🛠️ Troubleshooting suggestions:', 'warning');
                                addCollectionLog('   • Verify Bearer token is still valid', 'warning');
                                addCollectionLog('   • Check Fabric workspace permissions', 'warning');
                                addCollectionLog('   • Ensure Lakehouse table exists and is accessible', 'warning');
                                addCollectionLog('   • Retry operation if issue was temporary', 'warning');
                                
                                progressBadge.textContent = 'Error';
                                progressBadge.className = 'badge bg-danger ms-1';
                                spinner.style.display = 'none';
                                currentSourceDiv.className = 'alert alert-danger d-flex align-items-center';
                                document.getElementById('collectionSourceText').textContent = 'Fabric write failed';
                                document.getElementById('collectionProgressStatus').textContent = 'Operation failed - see logs for details';
                                
                                resultDiv.innerHTML = `
                                    <div class="alert alert-danger">
                                        <strong>❌ Fabric Write Operation Failed</strong><br>
                                        <small><strong>Error:</strong> ${data.message}</small><br>
                                        <small><strong>Action:</strong> Check logs for troubleshooting steps</small>
                                    </div>
                                `;
                            }
                        } else {
                            // Enhanced progress monitoring
                            if (data.stats && data.stats.items !== undefined) {
                                const processedItems = data.stats.items;
                                addCollectionLog(`📊 Progress update: ${processedItems} items processed so far...`, 'info');
                            }
                            
                            if (data.progress !== undefined) {
                                addCollectionLog(`⚡ Operation progress: ${Math.round(data.progress)}% complete`, 'info');
                            }
                            
                            if (data.operation) {
                                addCollectionLog(`🔄 Current operation: ${data.operation}`, 'info');
                            }
                            
                            // Update progress if available
                            if (data.logs && data.logs.length > 0) {
                                data.logs.forEach(log => {
                                    addCollectionLog(log.message, log.type || 'info');
                                });
                            } else {
                                // Default progress heartbeat if no specific logs
                                addCollectionLog('💓 Fabric write operation is progressing...', 'info');
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error polling Fabric progress:', error);
                        clearInterval(pollInterval);
                        addCollectionLog(`❌ Error monitoring Fabric progress: ${error.message}`, 'danger');
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 600000);
        }

        let collectionInProgress = false;

        function collectFeedback() {
            const resultsDiv = document.getElementById('results');
            const adoWorkItemId = document.getElementById('adoWorkItemId').value.trim();
            resultsDiv.innerHTML = '<div class="alert alert-info">Starting feedback collection...</div>';

            // Mark collection as in progress
            collectionInProgress = true;
            collectionStartTime = Date.now();
            localStorage.setItem('collectionInProgress', 'true');
            localStorage.setItem('collectionStartTime', collectionStartTime.toString());

            // Show progress button and initialize drawer
            showCollectionProgressDrawer();
            
            const requestBody = {};
            if (adoWorkItemId) {
                requestBody.ado_work_item_id = adoWorkItemId;
            }
            
            // Start actual collection process
            addCollectionLog('🚀 Starting feedback collection process...', 'info');
            addCollectionLog('📋 Preparing collection request...', 'info');
            updateCollectionProgress(5, 'Sending request to server...', 'Initializing collection...');
            
            // Start progress simulation that's resilient to navigation
            startCollectionProgressSimulation();
            
            fetch('/api/collect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            })
            .then(response => response.json())
            .then(data => {
                // Mark collection as complete
                collectionInProgress = false;
                localStorage.removeItem('collectionInProgress');
                localStorage.removeItem('collectionStartTime');
                
                // Update progress with final results
                updateCollectionProgress(100, 'Collection completed successfully', 'All sources processed', {
                    reddit: data.reddit,
                    fabric: data.fabric,
                    github: data.github,
                    ado: data.ado
                });
                
                addCollectionLog(`✅ Collection completed! Total: ${data.total} items`, 'success');
                addCollectionLog(`📊 Reddit: ${data.reddit}, Fabric: ${data.fabric}, GitHub: ${data.github}, ADO: ${data.ado}`, 'info');
                
                resultsDiv.innerHTML = `
                    <div class="alert alert-success">
                        <h5>🎉 Collection Complete!</h5>
                        <ul>
                            <li>Reddit: ${data.reddit} items</li>
                            <li>Fabric Community: ${data.fabric} items</li>
                            <li>GitHub Discussions: ${data.github} items</li>
                            <li>ADO Child Tasks: ${data.ado} items</li>
                            <li><strong>Total: ${data.total} items</strong></li>
                        </ul>
                        <small class="text-muted">Click "Collection Progress" to see detailed logs.</small>
                    </div>
                `;
                lastCollectionHadData = data.total > 0;
                
                completeCollectionOperation(true, `Successfully collected ${data.total} feedback items`, data);
            })
            .catch(error => {
                console.error('Error:', error);
                collectionInProgress = false;
                localStorage.removeItem('collectionInProgress');
                localStorage.removeItem('collectionStartTime');
                
                resultsDiv.innerHTML = '<div class="alert alert-danger">❌ Error collecting feedback</div>';
                lastCollectionHadData = false;
                
                addCollectionLog(`❌ Collection failed: ${error.message}`, 'danger');
                completeCollectionOperation(false, `Collection failed: ${error.message}`);
            });
        }

        // Progress simulation that continues even after navigation
        function startCollectionProgressSimulation() {
            const progressSteps = [
                { time: 500, progress: 15, message: '🔗 Starting Reddit collection...', status: 'Collecting from Reddit...', source: 'Searching Reddit posts...' },
                { time: 2000, progress: 35, message: '🌐 Starting Fabric Community collection...', status: 'Collecting from Fabric Community...', source: 'Scraping community forums...' },
                { time: 4000, progress: 55, message: '📊 Starting GitHub Discussions collection...', status: 'Collecting from GitHub...', source: 'Fetching GitHub discussions...' },
                { time: 6000, progress: 75, message: '🏢 Starting Azure DevOps collection...', status: 'Collecting from Azure DevOps...', source: 'Querying ADO work items...' }
            ];

            progressSteps.forEach(step => {
                setTimeout(() => {
                    // Only continue if collection is still in progress
                    if (collectionInProgress || localStorage.getItem('collectionInProgress') === 'true') {
                        addCollectionLog(step.message, 'info');
                        updateCollectionProgress(step.progress, step.status, step.source);
                    }
                }, step.time);
            });
        }

        // Resume collection progress if returning to page during collection
        function resumeCollectionProgress() {
            const inProgress = localStorage.getItem('collectionInProgress') === 'true';
            const startTime = localStorage.getItem('collectionStartTime');
            
            if (inProgress && startTime) {
                collectionInProgress = true;
                collectionStartTime = parseInt(startTime);
                
                const elapsed = Date.now() - collectionStartTime;
                
                // Show progress button
                document.getElementById('collectionProgressBtn').style.display = 'inline-block';
                
                // Check if collection might have completed by polling the server
                checkCollectionStatus(elapsed);
            }
        }
        
        // Check actual collection status from server
        function checkCollectionStatus(elapsed) {
            // First, update UI based on elapsed time
            let currentProgress = 5;
            let currentStatus = 'Checking collection status...';
            let currentSource = 'Verifying operation state...';
            
            if (elapsed > 500) currentProgress = 15;
            if (elapsed > 2000) currentProgress = 35;
            if (elapsed > 4000) currentProgress = 55;
            if (elapsed > 6000) currentProgress = 75;
            if (elapsed > 8000) currentProgress = 90; // Most collections should be done by now
            
            updateCollectionProgress(currentProgress, currentStatus, currentSource);
            addCollectionLog('🔄 Resuming collection progress tracking...', 'info');
            addCollectionLog('🔍 Checking if collection completed while away...', 'info');
            
            // Try to fetch recent collection data to see if it's done
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    if (data.completed) {
                        // Collection is actually done, update to completion
                        addCollectionLog('✅ Collection was completed while you were away!', 'success');
                        completeCollectionOperation(true, `Collection completed with ${data.total || 'unknown'} items`, data);
                    } else {
                        // Collection still in progress, continue simulation
                        addCollectionLog('⚡ Collection still in progress, continuing monitoring...', 'info');
                        startCollectionProgressSimulation();
                    }
                })
                .catch(error => {
                    // If we can't check status, assume it's still running and continue simulation
                    addCollectionLog('⚠️ Could not verify collection status, assuming still in progress...', 'warning');
                    startCollectionProgressSimulation();
                });
        }

        function writeToFabric() {
            const tokenInput = document.getElementById('fabricToken');
            const fabricToken = tokenInput.value.trim();
            const fabricResultsDiv = document.getElementById('fabricResults');

            if (!fabricToken) {
                fabricResultsDiv.innerHTML = '<div class="alert alert-warning">Please provide a Fabric Access Token.</div>';
                return;
            }

            if (!lastCollectionHadData) {
                 fabricResultsDiv.innerHTML = '<div class="alert alert-warning">No data from last collection, or last collection failed/yielded no items. Please collect feedback first.</div>';
                 return;
            }

            // Update progress drawer to show Fabric writing state
            startFabricWriteProgress();

            // Show initial progress message
            fabricResultsDiv.innerHTML = `
                <div class="alert alert-info">
                    <strong>🚀 Initiating Fabric Lakehouse Write...</strong><br>
                    <small>Detailed progress available in Collection Progress drawer</small>
                </div>
            `;

            // Start progressive logging that simulates realistic timing
            addFabricProgressLogs();

            // Add a delayed log before the actual API call
            setTimeout(() => {
                addCollectionLog('📤 Sending write request to Fabric API...', 'info');
                addCollectionLog('⏱️ Request timeout: 10 minutes maximum', 'info');
            }, 3500);

            // Use the async endpoint for better progress tracking
            fetch('/api/write_to_fabric_async', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fabric_token: fabricToken }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Enhanced success logging
                    addCollectionLog(`✅ Fabric write operation initiated successfully!`, 'success');
                    addCollectionLog(`🆔 Operation ID: ${data.operation_id}`, 'info');
                    addCollectionLog(`📊 Total items to process: ${data.total_items}`, 'info');
                    addCollectionLog(`🏗️ Target: Microsoft Fabric Lakehouse`, 'info');
                    addCollectionLog(`⚡ Processing mode: Asynchronous batch upload`, 'info');
                    addCollectionLog(`📈 Starting progress monitoring...`, 'info');
                    
                    // Update progress badge for Fabric writing
                    const progressBadge = document.getElementById('progressBadge');
                    progressBadge.textContent = 'Writing';
                    progressBadge.className = 'badge bg-warning ms-1';
                    
                    // Update current source display
                    document.getElementById('collectionSourceText').textContent = 'Writing to Fabric Lakehouse';
                    document.getElementById('collectionProgressStatus').textContent = 'Fabric write operation in progress...';
                    
                    fabricResultsDiv.innerHTML = `
                        <div class="alert alert-success">
                            <strong>✅ Fabric Write Operation Started!</strong><br>
                            <small><strong>Operation ID:</strong> ${data.operation_id}</small><br>
                            <small><strong>Items to Process:</strong> ${data.total_items}</small><br>
                            <small><strong>Status:</strong> Processing in background</small>
                        </div>
                    `;
                    
                    // Poll for completion
                    pollForFabricCompletion(data.operation_id, fabricResultsDiv);
                } else {
                    // Enhanced error logging
                    addCollectionLog(`❌ Fabric write operation failed to start`, 'danger');
                    addCollectionLog(`🔍 Error details: ${data.message}`, 'danger');
                    addCollectionLog(`💡 Suggestion: Verify Bearer token validity`, 'warning');
                    
                    fabricResultsDiv.innerHTML = `<div class="alert alert-danger">
                        <strong>❌ Failed to Start Fabric Write</strong><br>
                        <small>${data.message}</small>
                    </div>`;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                // Enhanced network error logging
                addCollectionLog(`❌ Network error during Fabric write request`, 'danger');
                addCollectionLog(`🔍 Error details: ${error.message}`, 'danger');
                addCollectionLog(`🌐 Check network connection and API availability`, 'warning');
                
                fabricResultsDiv.innerHTML = '<div class="alert alert-danger">An unexpected network error occurred while trying to start Fabric write.</div>';
            });
        }

        // Poll for operation completion and show final result
        function pollForCompletion(operationId, resultDiv) {
            const pollInterval = setInterval(() => {
                fetch(`/api/fabric_progress/${operationId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.completed) {
                            clearInterval(pollInterval);
                            
                            if (data.success) {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <strong>🎉 Fabric Write Completed Successfully!</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            } else {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-danger">
                                        <strong>❌ Fabric Write Failed</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error polling progress:', error);
                        clearInterval(pollInterval);
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 600000);
        }
    </script>
    
    <!-- Load Bootstrap JavaScript after DOM content -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Ensure Bootstrap is loaded before initializing any components
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, Bootstrap available:', typeof bootstrap !== 'undefined');
            if (typeof bootstrap !== 'undefined') {
                console.log('Bootstrap Offcanvas available:', typeof bootstrap.Offcanvas !== 'undefined');
            }
            
            // Load saved token from localStorage
            const savedToken = localStorage.getItem('fabricToken');
            if (savedToken) {
                document.getElementById('fabricToken').value = savedToken;
                console.log('Loaded saved token from localStorage');
            }
            
            // Restore progress state from localStorage
            restoreProgressState();
            
            // Resume collection progress if it was in progress
            resumeCollectionProgress();
        });
        
        // Save progress state to localStorage
        function saveProgressState() {
            const progressState = {
                badge: document.getElementById('progressBadge').textContent,
                badgeClass: document.getElementById('progressBadge').className,
                sourceText: document.getElementById('collectionSourceText').textContent,
                progressStatus: document.getElementById('collectionProgressStatus').textContent,
                progressBarWidth: document.getElementById('collectionProgressBar').style.width,
                progressPercentage: document.getElementById('collectionProgressPercentage').textContent,
                currentSourceClass: document.getElementById('currentCollectionSource').className,
                spinnerDisplay: document.getElementById('collectionSpinner').style.display,
                cancelButtonDisabled: document.getElementById('cancelOperation').disabled,
                // Save source counts
                redditCount: document.getElementById('redditCount').textContent,
                fabricCount: document.getElementById('fabricCount').textContent,
                githubCount: document.getElementById('githubCount').textContent,
                adoCount: document.getElementById('adoCount').textContent,
                // Save logs
                logs: document.getElementById('collectionLog').innerHTML,
                timestamp: Date.now()
            };
            localStorage.setItem('progressState', JSON.stringify(progressState));
        }
        
        // Restore progress state from localStorage
        function restoreProgressState() {
            const savedState = localStorage.getItem('progressState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Only restore if state is recent (within 1 hour)
                    if (Date.now() - state.timestamp < 3600000) {
                        // Restore badge
                        document.getElementById('progressBadge').textContent = state.badge;
                        document.getElementById('progressBadge').className = state.badgeClass;
                        
                        // Restore drawer content
                        document.getElementById('collectionSourceText').textContent = state.sourceText;
                        document.getElementById('collectionProgressStatus').textContent = state.progressStatus;
                        document.getElementById('collectionProgressBar').style.width = state.progressBarWidth || '0%';
                        document.getElementById('collectionProgressPercentage').textContent = state.progressPercentage || '0%';
                        document.getElementById('currentCollectionSource').className = state.currentSourceClass || 'alert alert-secondary d-flex align-items-center';
                        document.getElementById('collectionSpinner').style.display = state.spinnerDisplay || 'none';
                        document.getElementById('cancelOperation').disabled = state.cancelButtonDisabled || false;
                        
                        // Restore source counts
                        document.getElementById('redditCount').textContent = state.redditCount || '0';
                        document.getElementById('fabricCount').textContent = state.fabricCount || '0';
                        document.getElementById('githubCount').textContent = state.githubCount || '0';
                        document.getElementById('adoCount').textContent = state.adoCount || '0';
                        
                        // Restore logs
                        if (state.logs) {
                            document.getElementById('collectionLog').innerHTML = state.logs;
                        }
                        
                        // Show progress button if there's an active state
                        if (state.badge !== 'Ready') {
                            document.getElementById('collectionProgressBtn').style.display = 'inline-block';
                        }
                        
                        console.log('Restored complete progress state:', state.badge);
                    } else {
                        // Clear expired state
                        localStorage.removeItem('progressState');
                        console.log('Cleared expired progress state');
                    }
                } catch (e) {
                    console.error('Error restoring progress state:', e);
                    localStorage.removeItem('progressState');
                }
            }
        }
    </script>
</body>
</html>
