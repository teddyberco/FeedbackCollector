<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feedback Collector</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Fluent Design CSS -->
    <link href="{{ url_for('static', filename='css/fluent-design.css') }}" rel="stylesheet">
    
    <!-- Legacy scripts -->
    <script src="{{ url_for('static', filename='js/badge-state-manager.js') }}"></script>
    
    <!-- New enhanced scripts -->
    <script src="{{ url_for('static', filename='js/source-configuration.js') }}"></script>
    <script src="{{ url_for('static', filename='js/collection-manager.js') }}"></script>
</head>
<body>
    <div class="fluent-container">
        <!-- Header -->
        <header>
            <h1 class="fluent-title">Feedback Collector</h1>
            
            <!-- Navigation -->
            <nav class="fluent-nav">
                <div class="fluent-nav-items">
                    <a href="/feedback" class="fluent-nav-item">
                        <i class="bi bi-table"></i> View Feedback
                    </a>
                    <a href="/insights" class="fluent-nav-item">
                        <i class="bi bi-graph-up"></i> View Insights
                    </a>
                    <button class="fluent-nav-item" id="collectionProgressBtn" onclick="toggleCollectionProgress()">
                        <i class="bi bi-activity"></i> Collection Progress
                        <span class="fluent-badge fluent-badge-secondary" id="progressBadge">Ready</span>
                    </button>
                    <a href="#" class="fluent-nav-item" onclick="showHelp()">
                        <i class="bi bi-question-circle"></i> Help
                    </a>
                </div>
            </nav>
        </header>

        <!-- Main Action -->
        <section class="main-action-container">
            <button class="main-action-button" id="collectFeedbackBtn">
                <i class="bi bi-search"></i>
                Collect Feedback Now
            </button>
            <div id="results" class="mt-3"></div>
        </section>
        <!-- Data Sources -->
        <section class="fluent-card">
            <div class="fluent-card-header">
                <h2 class="fluent-section-title">
                    <i class="bi bi-database"></i>
                    Data Sources
                </h2>
            </div>
            <div class="fluent-card-body">
                <div id="dataSources">
                    <!-- Source cards will be populated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Collection Settings -->
        <section class="fluent-card">
            <div class="fluent-card-header">
                <h2 class="fluent-section-title">
                    <i class="bi bi-gear"></i>
                    Collection Settings
                </h2>
            </div>
            <div class="fluent-card-body">
                <div id="collectionSettings">
                    <!-- Settings will be populated by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Keywords Management -->
        <section class="fluent-card">
            <div class="fluent-card-header">
                <h2 class="fluent-section-title">
                    <i class="bi bi-tags"></i>
                    Keywords Management
                </h2>
            </div>
            <div class="fluent-card-body">
                <div class="config-field">
                    <label class="fluent-label">Add New Keyword:</label>
                    <div class="config-field-row">
                        <input type="text" id="newKeyword" class="fluent-input" placeholder="Enter new keyword">
                        <button class="fluent-button fluent-button-primary" onclick="addKeyword()">
                            <i class="bi bi-plus"></i> Add
                        </button>
                    </div>
                </div>
                
                <div class="config-field">
                    <label class="fluent-label">Current Keywords:</label>
                    <div class="keyword-list-container">
                        <ul id="keywordList" class="list-group list-group-flush">
                            <!-- Keywords will be populated by JavaScript -->
                        </ul>
                    </div>
                </div>
                
                <div class="config-field-row">
                    <button class="fluent-button fluent-button-success" onclick="saveKeywords()">
                        <i class="bi bi-check"></i> Save Keywords
                    </button>
                    <button class="fluent-button fluent-button-warning" onclick="restoreDefaultKeywords()">
                        <i class="bi bi-arrow-clockwise"></i> Restore Defaults
                    </button>
                </div>
                
                <div id="keywordsStatus" class="status-message"></div>
            </div>
        </section>

        <!-- Storage Options -->
        <section class="fluent-card">
            <div class="fluent-card-header">
                <h2 class="fluent-section-title">
                    <i class="bi bi-hdd"></i>
                    Storage Options
                    <span class="fluent-badge fluent-badge-secondary">Optional</span>
                </h2>
            </div>
            <div class="fluent-card-body">
                <!-- Local Storage -->
                <div class="config-field">
                    <h3 class="fluent-subtitle">
                        <i class="bi bi-folder"></i>
                        Local Storage
                    </h3>
                    <div class="fluent-alert fluent-alert-success">
                        <i class="bi bi-check-circle"></i>
                        <div>
                            <strong>CSV Export</strong> - Always enabled<br>
                            All collected feedback is automatically saved to CSV format in the data folder.
                        </div>
                    </div>
                </div>

                <!-- Fabric Lakehouse -->
                <div class="config-field">
                    <h3 class="fluent-subtitle">
                        <i class="bi bi-cloud"></i>
                        Microsoft Fabric Lakehouse
                    </h3>
                    <div class="fluent-alert fluent-alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        <div>
                            <strong>Status:</strong> Not configured<br>
                            Use the "Configure Authentication" button in the navigation to configure authentication.
                        </div>
                    </div>
                    <div class="config-field-row">
                        <button class="fluent-button fluent-button-primary" onclick="toggleFabricAuth()">
                            <i class="bi bi-shield-check"></i> Configure Authentication
                        </button>
                        <button class="fluent-button fluent-button-success" id="writeToFabricBtn" disabled>
                            <i class="bi bi-upload"></i> Write to Lakehouse
                        </button>
                    </div>
                    <div id="fabricResults" class="mt-3"></div>
                </div>
            </div>
        </section>

    <!-- Collection Progress Drawer (hidden initially) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="collectionProgressDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-activity me-2"></i>Collection Progress
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="closeCollectionDrawer" onclick="hideCollectionProgress()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Progress Overview -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Overall Progress</span>
                    <span id="collectionProgressPercentage" class="badge bg-primary">0%</span>
                </div>
                <div class="progress mb-2">
                    <div class="progress-bar" role="progressbar" id="collectionProgressBar" style="width: 0%"></div>
                </div>
                <div class="d-flex justify-content-between">
                    <small class="text-muted" id="collectionProgressStatus">Initializing...</small>
                    <small class="text-muted" id="collectionProgressETA">ETA: --</small>
                </div>
            </div>

            <!-- Current Source -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Current Source</h6>
                <div class="alert alert-secondary d-flex align-items-center" id="currentCollectionSource">
                    <div class="spinner-border spinner-border-sm me-2" role="status" id="collectionSpinner" style="display: none;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span id="collectionSourceText">Not started</span>
                </div>
            </div>

            <!-- Source Progress -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Source Progress</h6>
                <div class="row">
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="redditCount">0</div>
                                <small class="text-muted">Reddit</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-warning" id="redditProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="fabricCount">0</div>
                                <small class="text-muted">Fabric</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-info" id="fabricProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="githubCount">0</div>
                                <small class="text-muted">GitHub</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-success" id="githubProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="adoCount">0</div>
                                <small class="text-muted">ADO</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-primary" id="adoProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Log -->
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Collection Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearCollectionLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="collectionLogContainer" style="height: 250px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="collectionLog" class="font-monospace small"></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-outline-danger" id="cancelOperation" onclick="cancelOperation()" disabled>
                    <i class="bi bi-x-circle me-1"></i>Cancel Operation
                </button>
            </div>
        </div>
    </div>

    <!-- Fabric Auth Drawer (hidden initially) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="fabricAuthDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-shield-check me-2"></i>Fabric Authentication
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="closeFabricAuthDrawer" onclick="hideFabricAuth()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Current Token Status -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Connection Status</span>
                    <span id="fabricConnectionStatus" class="badge bg-secondary">Not Connected</span>
                </div>
                <div class="alert" id="fabricStatusAlert" role="alert" style="display: none;">
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status" id="fabricAuthSpinner" style="display: none;">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span id="fabricStatusText">Ready to connect</span>
                    </div>
                </div>
            </div>

            <!-- Token Input -->
            <div class="mb-4">
                <h6 class="text-muted mb-3">Fabric Bearer Token</h6>
                <div class="mb-3">
                    <label for="fabricAuthToken" class="form-label">Bearer Token</label>
                    <div class="input-group">
                        <input type="password" class="form-control" id="fabricAuthToken" placeholder="Paste your Fabric bearer token here...">
                        <button class="btn btn-outline-secondary" type="button" onclick="toggleTokenVisibility()">
                            <i class="bi bi-eye" id="tokenVisibilityIcon"></i>
                        </button>
                    </div>
                    <div class="form-text">
                        This token is used to authenticate with Microsoft Fabric Lakehouse.
                        <br><strong>Your token is securely stored in your browser session only.</strong>
                    </div>
                </div>
                
                <!-- Token Help -->
                <div class="card bg-light mb-3">
                    <div class="card-body py-2">
                        <h6 class="card-title mb-1">How to get your token:</h6>
                        <ol class="mb-0 small">
                            <li>Open browser Developer Tools (F12)</li>
                            <li>Go to Network tab and reload Fabric page</li>
                            <li>Find any API request to fabric.microsoft.com</li>
                            <li>Copy the Authorization header value (without "Bearer ")</li>
                        </ol>
                    </div>
                </div>
            </div>

            <!-- Current Token Info -->
            <div class="mb-4" id="currentTokenInfo" style="display: none;">
                <h6 class="text-muted mb-2">Current Token</h6>
                <div class="card">
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span class="small text-muted">Last Validated</span>
                            <span class="badge bg-success" id="lastValidatedTime">Never</span>
                        </div>
                        <div class="d-flex justify-content-between align-items-center mt-1">
                            <span class="small text-muted">Token Status</span>
                            <span class="badge" id="tokenStatusBadge">Unknown</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-primary" id="validateTokenBtn" onclick="validateFabricToken()">
                    <i class="bi bi-check-circle me-1"></i>Validate & Connect
                </button>
                <button class="btn btn-outline-warning" id="updateTokenBtn" onclick="updateFabricToken()" style="display: none;">
                    <i class="bi bi-arrow-clockwise me-1"></i>Update Token
                </button>
                <button class="btn btn-outline-danger" id="clearTokenBtn" onclick="clearFabricToken()" style="display: none;">
                    <i class="bi bi-x-circle me-1"></i>Clear Token
                </button>
            </div>

            <!-- Validation Log -->
            <div class="mt-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Validation Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearFabricLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="fabricLogContainer" style="height: 200px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="fabricLog" class="font-monospace small"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let lastCollectionHadData = false; // Flag to track if collection yielded data
        let currentKeywords = []; // Local cache of keywords for the UI
        let collectionProgressDrawer = null;
        let collectionProgressInterval = null;
        let collectionStartTime = null;
        let collectionOperationId = null;
        
        // Fabric Auth variables
        let fabricAuthDrawer = null;
        let fabricToken = null;
        let fabricConnectionStatus = 'disconnected';

        // Initialize Fabric Auth drawer on page load
        document.addEventListener('DOMContentLoaded', function() {
            fabricAuthDrawer = new bootstrap.Offcanvas(document.getElementById('fabricAuthDrawer'));
            checkStoredFabricToken();
        });

        // Toggle Fabric Auth drawer
        function toggleFabricAuth() {
            if (fabricAuthDrawer) {
                fabricAuthDrawer.show();
            }
        }

        // Hide Fabric Auth drawer
        function hideFabricAuth() {
            if (fabricAuthDrawer) {
                fabricAuthDrawer.hide();
            }
        }

        // Check for stored token on page load
        function checkStoredFabricToken() {
            fetch('/api/fabric/token/status')
                .then(response => response.json())
                .then(data => {
                    if (data.has_token) {
                        updateFabricAuthUI('connected', 'Token stored in session');
                        document.getElementById('currentTokenInfo').style.display = 'block';
                        document.getElementById('updateTokenBtn').style.display = 'block';
                        document.getElementById('clearTokenBtn').style.display = 'block';
                        document.getElementById('lastValidatedTime').textContent = data.last_validated || 'Unknown';
                        fabricToken = 'stored';
                    } else {
                        updateFabricAuthUI('disconnected', 'No token stored');
                    }
                })
                .catch(error => {
                    console.error('Error checking token status:', error);
                    updateFabricAuthUI('error', 'Error checking token status');
                });
        }

        // Toggle token visibility
        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('fabricAuthToken');
            const visibilityIcon = document.getElementById('tokenVisibilityIcon');
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                visibilityIcon.className = 'bi bi-eye-slash';
            } else {
                tokenInput.type = 'password';
                visibilityIcon.className = 'bi bi-eye';
            }
        }

        // Validate Fabric token
        function validateFabricToken() {
            const token = document.getElementById('fabricAuthToken').value.trim();
            if (!token) {
                alert('Please enter a Fabric bearer token');
                return;
            }

            updateFabricAuthUI('validating', 'Validating token...');
            addFabricLog('üîÑ Starting fast token validation...');
            
            fetch('/api/fabric/token/validate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({token: token})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    fabricToken = token;
                    addFabricLog('‚úÖ Token validation successful');
                    addFabricLog('üöÄ Livy session starting in background');
                    addFabricLog('üìù Token stored in session');
                    
                    if (data.session_id) {
                        addFabricLog(`üîó Session ID: ${data.session_id}`);
                    }
                    
                    // Update badge using BadgeStateManager
                    if (window.badgeStateManager) {
                        window.badgeStateManager.setFabricAuthState('connected', 'Connected', data.session_id);
                    }
                    
                    // Update drawer UI
                    updateFabricAuthUI('connected', 'Token validated - Livy session starting');
                    
                    // Show token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'block';
                    document.getElementById('updateTokenBtn').style.display = 'block';
                    document.getElementById('clearTokenBtn').style.display = 'block';
                    document.getElementById('lastValidatedTime').textContent = new Date().toLocaleString();
                    
                    // Clear token input for security
                    document.getElementById('fabricAuthToken').value = '';
                } else {
                    // Update badge using BadgeStateManager for error state
                    if (window.badgeStateManager) {
                        window.badgeStateManager.setFabricAuthState('error', 'Error');
                    }
                    
                    updateFabricAuthUI('error', data.message || 'Token validation failed');
                    addFabricLog('‚ùå Token validation failed: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error validating token:', error);
                updateFabricAuthUI('error', 'Error validating token');
                addFabricLog('‚ùå Validation error: ' + error.message);
            });
        }

        // Update existing token
        function updateFabricToken() {
            document.getElementById('fabricAuthToken').value = '';
            document.getElementById('fabricAuthToken').focus();
            document.getElementById('currentTokenInfo').style.display = 'none';
            document.getElementById('updateTokenBtn').style.display = 'none';
            document.getElementById('clearTokenBtn').style.display = 'none';
            updateFabricAuthUI('disconnected', 'Ready to enter new token');
            addFabricLog('üîÑ Ready to update token');
        }

        // Clear stored token
        function clearFabricToken() {
            if (!confirm('Are you sure you want to clear the stored Fabric token?')) {
                return;
            }

            fetch('/api/fabric/token/clear', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    fabricToken = null;
                    updateFabricAuthUI('disconnected', 'Token cleared');
                    addFabricLog('üóëÔ∏è Token cleared from session');
                    
                    // Hide token management buttons
                    document.getElementById('currentTokenInfo').style.display = 'none';
                    document.getElementById('updateTokenBtn').style.display = 'none';
                    document.getElementById('clearTokenBtn').style.display = 'none';
                } else {
                    addFabricLog('‚ùå Error clearing token: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error clearing token:', error);
                addFabricLog('‚ùå Clear error: ' + error.message);
            });
        }

        // Update Fabric Auth UI
        function updateFabricAuthUI(status, message) {
            const statusBadge = document.getElementById('fabricConnectionStatus');
            const authBadge = document.getElementById('fabricAuthBadge'); // May be null if removed from nav
            const statusAlert = document.getElementById('fabricStatusAlert');
            const statusText = document.getElementById('fabricStatusText');
            const spinner = document.getElementById('fabricAuthSpinner');
            
            statusText.textContent = message;
            statusAlert.style.display = 'block';
            
            switch (status) {
                case 'connected':
                    statusBadge.className = 'badge bg-success';
                    statusBadge.textContent = 'Connected';
                    if (authBadge) {
                        authBadge.className = 'badge bg-success ms-1';
                        authBadge.textContent = 'Connected';
                    }
                    statusAlert.className = 'alert alert-success';
                    spinner.style.display = 'none';
                    break;
                case 'validating':
                    statusBadge.className = 'badge bg-warning';
                    statusBadge.textContent = 'Validating';
                    if (authBadge) {
                        authBadge.className = 'badge bg-warning ms-1';
                        authBadge.textContent = 'Validating';
                    }
                    statusAlert.className = 'alert alert-warning';
                    spinner.style.display = 'block';
                    break;
                case 'error':
                    statusBadge.className = 'badge bg-danger';
                    statusBadge.textContent = 'Error';
                    if (authBadge) {
                        authBadge.className = 'badge bg-danger ms-1';
                        authBadge.textContent = 'Error';
                    }
                    statusAlert.className = 'alert alert-danger';
                    spinner.style.display = 'none';
                    break;
                default: // disconnected
                    statusBadge.className = 'badge bg-secondary';
                    statusBadge.textContent = 'Not Connected';
                    if (authBadge) {
                        authBadge.className = 'badge bg-secondary ms-1';
                        authBadge.textContent = 'Not Connected';
                    }
                    statusAlert.className = 'alert alert-secondary';
                    spinner.style.display = 'none';
                    break;
            }
            
            fabricConnectionStatus = status;
        }

        // Add log entry to Fabric log
        function addFabricLog(message) {
            const log = document.getElementById('fabricLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            log.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('fabricLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Clear Fabric log
        function clearFabricLog() {
            document.getElementById('fabricLog').innerHTML = '';
        }

        // Function to render the keyword list in the UI
        function renderKeywordList(keywords) {
            const list = document.getElementById('keywordList');
            list.innerHTML = ''; // Clear existing list
            keywords.forEach(keyword => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.textContent = keyword;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'btn btn-danger btn-sm';
                removeButton.textContent = 'Remove';
                removeButton.onclick = function() { removeKeyword(keyword); };
                
                li.appendChild(removeButton);
                list.appendChild(li);
            });
            currentKeywords = [...keywords]; // Update local cache
        }

        // Function to display status messages for keyword operations
        function showKeywordsStatus(message, isError = false) {
            const statusDiv = document.getElementById('keywordsStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message alert ${isError ? 'alert-danger' : 'alert-success'}`;
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000); // Hide after 5 seconds
        }

        // Load initial keywords when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/api/keywords')
                .then(response => response.json())
                .then(data => {
                    renderKeywordList(data);
                })
                .catch(error => {
                    console.error('Error fetching initial keywords:', error);
                    showKeywordsStatus('Error loading initial keywords.', true);
                });
        });

        function addKeyword() {
            const input = document.getElementById('newKeyword');
            const keyword = input.value.trim();
            if (keyword && !currentKeywords.includes(keyword)) {
                currentKeywords.push(keyword);
                renderKeywordList(currentKeywords); // Re-render the list
                input.value = '';
            } else if (currentKeywords.includes(keyword)) {
                showKeywordsStatus(`Keyword "${keyword}" already exists.`, true);
            }
        }

        function removeKeyword(keywordToRemove) {
            currentKeywords = currentKeywords.filter(k => k !== keywordToRemove);
            renderKeywordList(currentKeywords); // Re-render the list
        }
        
        function saveKeywords() {
            fetch('/api/keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ keywords: currentKeywords }), 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus('Keywords saved successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error saving keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error saving keywords.', true);
            });
        }

        function restoreDefaultKeywords() {
            if (!confirm('Are you sure you want to restore default keywords? This will replace your current list.')) {
                return;
            }
            fetch('/api/keywords/restore_default', {
                method: 'POST', 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus(data.message || 'Default keywords restored successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error restoring default keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error restoring default keywords.', true);
            });
        }

        // Toggle the collection progress drawer
        function toggleCollectionProgress() {
            const drawer = document.getElementById('collectionProgressDrawer');
            
            if (!collectionProgressDrawer) {
                collectionProgressDrawer = new bootstrap.Offcanvas(drawer);
            }
            collectionProgressDrawer.show();
        }

        // Hide the collection progress drawer
        function hideCollectionProgress() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Initialize Collection progress (button is always visible)
        function showCollectionProgressDrawer() {
            resetCollectionDrawer();
            collectionStartTime = Date.now();
            
            // Update progress badge to show active state
            const progressBadge = document.getElementById('progressBadge');
            progressBadge.textContent = '0%';
            progressBadge.className = 'badge bg-primary ms-1'; // Change to primary blue when active
        }

        // Reset collection drawer to initial state
        function resetCollectionDrawer() {
            document.getElementById('collectionProgressBar').style.width = '0%';
            document.getElementById('collectionProgressPercentage').textContent = '0%';
            document.getElementById('collectionProgressStatus').textContent = 'Ready to start...';
            document.getElementById('collectionProgressETA').textContent = 'ETA: --';
            document.getElementById('collectionSourceText').textContent = 'Not started';
            // Hide spinner initially
            document.getElementById('collectionSpinner').style.display = 'none';
            // Set initial alert color to neutral
            document.getElementById('currentCollectionSource').className = 'alert alert-secondary d-flex align-items-center';
            document.getElementById('collectionLog').innerHTML = '';
            
            // Ensure cancel button is enabled and properly styled
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = false;
            cancelButton.classList.remove('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            // Reset source counts and progress
            ['reddit', 'fabric', 'github', 'ado'].forEach(source => {
                document.getElementById(`${source}Count`).textContent = '0';
                document.getElementById(`${source}Progress`).style.width = '0%';
            });
            
            // Don't add log until collection starts
        }

        // Add log entry to collection drawer
        function addCollectionLog(message, type = 'info') {
            const logContainer = document.getElementById('collectionLog');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `mb-1 text-${type}`;
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            
            logContainer.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('collectionLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Update collection progress
        function updateCollectionProgress(progress, status, currentSource, sourceCounts = {}) {
            // Update main progress bar in drawer
            const mainProgressBar = document.getElementById('collectionProgressBar');
            if (mainProgressBar) {
                mainProgressBar.style.width = `${progress}%`;
                document.getElementById('collectionProgressPercentage').textContent = `${Math.round(progress)}%`;
                document.getElementById('collectionProgressStatus').textContent = status;
                document.getElementById('collectionSourceText').textContent = currentSource;
            }
            
            // Update progress button badge
            const progressBadge = document.getElementById('progressBadge');
            if (progressBadge) {
                progressBadge.textContent = `${Math.round(progress)}%`;
            }
            
            // Save progress state for persistence
            saveProgressState();
            
            // Show spinner when collection is active and change alert color
            const spinner = document.getElementById('collectionSpinner');
            const currentSourceDiv = document.getElementById('currentCollectionSource');
            if (spinner && progress > 0 && progress < 100) {
                spinner.style.display = 'inline-block';
                currentSourceDiv.className = 'alert alert-info d-flex align-items-center';
            } else if (spinner && progress >= 100) {
                spinner.style.display = 'none';
                currentSourceDiv.className = 'alert alert-success d-flex align-items-center';
            }
            
            // Update source counts and progress
            Object.keys(sourceCounts).forEach(source => {
                const countElement = document.getElementById(`${source}Count`);
                const progressElement = document.getElementById(`${source}Progress`);
                if (countElement && progressElement) {
                    const count = sourceCounts[source] || 0;
                    countElement.textContent = count;
                    // Set progress to 100% if this source is complete, 50% if in progress, 0% if not started
                    if (currentSource.toLowerCase().includes(source)) {
                        progressElement.style.width = '50%';
                    } else if (count > 0) {
                        progressElement.style.width = '100%';
                    }
                }
            });
            
            // Calculate ETA
            if (progress > 0 && progress < 100 && collectionStartTime) {
                const elapsed = Date.now() - collectionStartTime;
                const estimatedTotal = (elapsed / progress) * 100;
                const remaining = Math.max(0, estimatedTotal - elapsed);
                const etaMinutes = Math.floor(remaining / 60000);
                const etaSeconds = Math.floor((remaining % 60000) / 1000);
                const etaElement = document.getElementById('collectionProgressETA');
                if (etaElement) {
                    etaElement.textContent = `ETA: ${etaMinutes}m ${etaSeconds}s`;
                }
            }
        }

        // Complete collection operation
        function completeCollectionOperation(success, message, results = {}) {
            document.getElementById('collectionSpinner').style.display = 'none';
            
            // Update collection source text to show completion
            const sourceTextElement = document.getElementById('collectionSourceText');
            if (sourceTextElement) {
                sourceTextElement.textContent = success ? 'Completed' : 'Error';
                console.log(`[COMPLETION FIX] Updated collectionSourceText to: "${success ? 'Completed' : 'Error'}"`);
            }
            
            // Disable cancel button when collection is complete - ensure visual feedback
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = true;
            cancelButton.classList.add('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            const progressBadge = document.getElementById('progressBadge');
            
            if (success) {
                updateCollectionProgress(100, 'Collection completed successfully', 'Completed');
                addCollectionLog(`‚úÖ ${message}`, 'success');
                
                // Update final counts
                Object.keys(results).forEach(source => {
                    if (source !== 'total') {
                        document.getElementById(`${source}Count`).textContent = results[source] || 0;
                        document.getElementById(`${source}Progress`).style.width = '100%';
                    }
                });
                
                // Update badge to show completion
                progressBadge.textContent = 'Complete';
                progressBadge.className = 'badge bg-success ms-1';
            } else {
                addCollectionLog(`‚ùå ${message}`, 'danger');
                // Update badge to show error
                progressBadge.textContent = 'Error';
                progressBadge.className = 'badge bg-danger ms-1';
            }
            
            // Save progress state
            saveProgressState();
        }

        // Close collection drawer
        function closeCollectionDrawer() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Cancel current operation (collection or Fabric write)
        function cancelOperation() {
            const currentSource = document.getElementById('collectionSourceText').textContent;
            
            if (currentSource.includes('Fabric') || currentSource.includes('Writing')) {
                addCollectionLog('üõë Fabric write cancellation requested...', 'warning');
                // TODO: Implement actual Fabric write cancellation via API
            } else {
                addCollectionLog('üõë Collection cancellation requested...', 'warning');
                // TODO: Implement actual collection cancellation
            }
            
            document.getElementById('cancelOperation').disabled = true;
        }

        // Clear collection log
        function clearCollectionLog() {
            document.getElementById('collectionLog').innerHTML = '';
        }

        // Start Fabric write progress (reuse collection drawer for Fabric writing)
        function startFabricWriteProgress() {
            // Update drawer to show Fabric writing state
            document.getElementById('collectionProgressStatus').textContent = 'Initializing Fabric write operation...';
            document.getElementById('collectionSourceText').textContent = 'Preparing to write to Fabric Lakehouse';
            document.getElementById('collectionSpinner').style.display = 'inline-block';
            document.getElementById('currentCollectionSource').className = 'alert alert-warning d-flex align-items-center';
            
            // Re-enable cancel button for Fabric operation - ensure visual feedback
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = false;
            cancelButton.classList.remove('disabled');
            
            // Add initial logging only
            addCollectionLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'secondary');
            addCollectionLog('üèóÔ∏è Preparing Fabric Lakehouse write operation...', 'info');
            
            // Save progress state
            saveProgressState();
        }
        
        // Progressive Fabric logging that happens during actual API calls
        function addFabricProgressLogs() {
            // Simulate realistic timing for actual Fabric operations
            setTimeout(() => {
                addCollectionLog('üìã Validating Bearer token and permissions...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Validating authentication';
            }, 100);
            
            setTimeout(() => {
                addCollectionLog('üåê Establishing connection to Fabric API endpoints...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Connecting to Fabric services';
            }, 800);
            
            setTimeout(() => {
                addCollectionLog('üìä Preparing feedback data for Lakehouse ingestion...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Preparing data payload';
            }, 1500);
            
            setTimeout(() => {
                addCollectionLog('üîê Authenticating with Microsoft Fabric services...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Authenticating with Fabric';
            }, 2200);
            
            setTimeout(() => {
                addCollectionLog('üìÅ Targeting Lakehouse table for data ingestion...', 'info');
                document.getElementById('collectionSourceText').textContent = 'Initiating data transfer';
            }, 3000);
        }

        // Poll for Fabric completion (reuse collection drawer)
        function pollForFabricCompletion(operationId, resultDiv) {
            const pollInterval = setInterval(() => {
                fetch(`/api/fabric_progress/${operationId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.completed) {
                            clearInterval(pollInterval);
                            
                            const progressBadge = document.getElementById('progressBadge');
                            const spinner = document.getElementById('collectionSpinner');
                            const currentSourceDiv = document.getElementById('currentCollectionSource');
                            const cancelButton = document.getElementById('cancelOperation');
                            
                            // Disable cancel button when Fabric operation completes - ensure visual feedback
                            cancelButton.disabled = true;
                            cancelButton.classList.add('disabled');
                            
                            if (data.success) {
                                // Enhanced success logging
                                addCollectionLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'secondary');
                                addCollectionLog('üéâ Fabric write operation completed successfully!', 'success');
                                addCollectionLog('üìä All feedback data has been written to Lakehouse', 'success');
                                addCollectionLog('üíæ Data is now available for analytics and reporting', 'success');
                                addCollectionLog('üîç You can query the data using Fabric SQL endpoints', 'info');
                                addCollectionLog('üìà Data ingestion pipeline completed without errors', 'success');
                                
                                progressBadge.textContent = 'Complete';
                                progressBadge.className = 'badge bg-success ms-1';
                                spinner.style.display = 'none';
                                currentSourceDiv.className = 'alert alert-success d-flex align-items-center';
                                document.getElementById('collectionSourceText').textContent = 'Fabric write completed successfully';
                                document.getElementById('collectionProgressStatus').textContent = 'All operations completed - data available in Lakehouse';
                                
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <strong>üéâ Fabric Lakehouse Write Successful!</strong><br>
                                        <small><strong>Status:</strong> ${data.message}</small><br>
                                        <small><strong>Result:</strong> Data successfully ingested to Lakehouse</small><br>
                                        <small><strong>Next:</strong> Visit <a href="/feedback" target="_blank">Feedback Viewer</a> to manage items</small>
                                    </div>
                                `;
                                
                                // Set global flag to hide duplicates when viewing feedback
                                if (data.hide_duplicates) {
                                    addCollectionLog('üîÑ Setting up duplicate filtering for feedback viewer...', 'info');
                                    localStorage.setItem('hideDuplicatesAfterSync', 'true');
                                    localStorage.setItem('syncTimestamp', Date.now().toString());
                                }
                            } else {
                                // Enhanced error logging
                                addCollectionLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'secondary');
                                addCollectionLog('‚ùå Fabric write operation failed', 'danger');
                                addCollectionLog(`üîç Failure reason: ${data.message}`, 'danger');
                                addCollectionLog('üõ†Ô∏è Troubleshooting suggestions:', 'warning');
                                addCollectionLog('   ‚Ä¢ Verify Bearer token is still valid', 'warning');
                                addCollectionLog('   ‚Ä¢ Check Fabric workspace permissions', 'warning');
                                addCollectionLog('   ‚Ä¢ Ensure Lakehouse table exists and is accessible', 'warning');
                                addCollectionLog('   ‚Ä¢ Retry operation if issue was temporary', 'warning');
                                
                                progressBadge.textContent = 'Error';
                                progressBadge.className = 'badge bg-danger ms-1';
                                spinner.style.display = 'none';
                                currentSourceDiv.className = 'alert alert-danger d-flex align-items-center';
                                document.getElementById('collectionSourceText').textContent = 'Fabric write failed';
                                document.getElementById('collectionProgressStatus').textContent = 'Operation failed - see logs for details';
                                
                                resultDiv.innerHTML = `
                                    <div class="alert alert-danger">
                                        <strong>‚ùå Fabric Write Operation Failed</strong><br>
                                        <small><strong>Error:</strong> ${data.message}</small><br>
                                        <small><strong>Action:</strong> Check logs for troubleshooting steps</small>
                                    </div>
                                `;
                            }
                        } else {
                            // Enhanced progress monitoring
                            if (data.stats && data.stats.items !== undefined) {
                                const processedItems = data.stats.items;
                                addCollectionLog(`üìä Progress update: ${processedItems} items processed so far...`, 'info');
                            }
                            
                            if (data.progress !== undefined) {
                                addCollectionLog(`‚ö° Operation progress: ${Math.round(data.progress)}% complete`, 'info');
                            }
                            
                            if (data.operation) {
                                addCollectionLog(`üîÑ Current operation: ${data.operation}`, 'info');
                            }
                            
                            // Update progress if available
                            if (data.logs && data.logs.length > 0) {
                                data.logs.forEach(log => {
                                    addCollectionLog(log.message, log.type || 'info');
                                });
                            } else {
                                // Default progress heartbeat if no specific logs
                                addCollectionLog('üíì Fabric write operation is progressing...', 'info');
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error polling Fabric progress:', error);
                        clearInterval(pollInterval);
                        addCollectionLog(`‚ùå Error monitoring Fabric progress: ${error.message}`, 'danger');
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 600000);
        }

        let collectionInProgress = false;

        function collectFeedback() {
            // Use the new enhanced collection manager
            if (window.enhancedCollectionManager) {
                window.enhancedCollectionManager.startCollection();
            } else {
                // Fallback to legacy implementation
                const resultsDiv = document.getElementById('results');
                const adoWorkItemId = document.getElementById('adoWorkItemId')?.value?.trim();
                resultsDiv.innerHTML = '<div class="alert alert-info">Starting feedback collection...</div>';

                // Mark collection as in progress
                collectionInProgress = true;
                collectionStartTime = Date.now();
                localStorage.setItem('collectionInProgress', 'true');
                localStorage.setItem('collectionStartTime', collectionStartTime.toString());

                // Show progress button and initialize drawer
                showCollectionProgressDrawer();
                
                const requestBody = {};
                if (adoWorkItemId) {
                    requestBody.ado_work_item_id = adoWorkItemId;
                }
                
                // Start actual collection process
                addCollectionLog('üöÄ Starting feedback collection process...', 'info');
                addCollectionLog('üìã Preparing collection request...', 'info');
                updateCollectionProgress(5, 'Sending request to server...', 'Initializing collection...');
                
                // Start progress simulation that's resilient to navigation
                startCollectionProgressSimulation();
                
                fetch('/api/collect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                })
                .then(response => response.json())
                .then(data => {
                    // Mark collection as complete
                    collectionInProgress = false;
                    localStorage.removeItem('collectionInProgress');
                    localStorage.removeItem('collectionStartTime');
                    
                    // Update progress with final results
                    updateCollectionProgress(100, 'Collection completed successfully', 'Completed', {
                        reddit: data.reddit,
                        fabric: data.fabric,
                        github: data.github,
                        ado: data.ado
                    });
                    
                    addCollectionLog(`‚úÖ Collection completed! Total: ${data.total} items`, 'success');
                    addCollectionLog(`üìä Reddit: ${data.reddit}, Fabric: ${data.fabric}, GitHub: ${data.github}, ADO: ${data.ado}`, 'info');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-success">
                            <h5>üéâ Collection Complete!</h5>
                            <ul>
                                <li>Reddit: ${data.reddit} items</li>
                                <li>Fabric Community: ${data.fabric} items</li>
                                <li>GitHub Discussions: ${data.github} items</li>
                                <li>ADO Child Tasks: ${data.ado} items</li>
                                <li><strong>Total: ${data.total} items</strong></li>
                            </ul>
                            <small class="text-muted">Click "Collection Progress" to see detailed logs.</small>
                        </div>
                    `;
                    lastCollectionHadData = data.total > 0;
                    
                    completeCollectionOperation(true, `Successfully collected ${data.total} feedback items`, data);
                })
                .catch(error => {
                    console.error('Collection error:', error);
                    collectionInProgress = false;
                    localStorage.removeItem('collectionInProgress');
                    localStorage.removeItem('collectionStartTime');
                    updateCollectionProgress(0, 'Collection failed', 'Error: ' + error.message);
                    
                    resultsDiv.innerHTML = '<div class="alert alert-danger">‚ùå Error collecting feedback</div>';
                    lastCollectionHadData = false;
                    
                    addCollectionLog(`‚ùå Collection failed: ${error.message}`, 'danger');
                    completeCollectionOperation(false, `Collection failed: ${error.message}`);
                });
            }
        }

        // Progress simulation that continues even after navigation
        function startCollectionProgressSimulation() {
            const progressSteps = [
                { time: 500, progress: 15, message: 'üîó Starting Reddit collection...', status: 'Collecting from Reddit...', source: 'Searching Reddit posts...' },
                { time: 2000, progress: 35, message: 'üåê Starting Fabric Community collection...', status: 'Collecting from Fabric Community...', source: 'Scraping community forums...' },
                { time: 4000, progress: 55, message: 'üìä Starting GitHub Discussions collection...', status: 'Collecting from GitHub...', source: 'Fetching GitHub discussions...' },
                { time: 6000, progress: 75, message: 'üè¢ Starting Azure DevOps collection...', status: 'Collecting from Azure DevOps...', source: 'Querying ADO work items...' }
            ];

            progressSteps.forEach(step => {
                setTimeout(() => {
                    // Only continue if collection is still in progress
                    if (collectionInProgress || localStorage.getItem('collectionInProgress') === 'true') {
                        addCollectionLog(step.message, 'info');
                        updateCollectionProgress(step.progress, step.status, step.source);
                    }
                }, step.time);
            });
        }

        function showHelp() {
            const helpModal = document.createElement('div');
            helpModal.className = 'modal fade';
            helpModal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-question-circle"></i>
                                Feedback Collector Help
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <h6>How to Use</h6>
                            <ol>
                                <li><strong>Configure Data Sources:</strong> Enable/disable sources and customize their settings</li>
                                <li><strong>Adjust Collection Settings:</strong> Set time ranges, limits, and filters</li>
                                <li><strong>Manage Keywords:</strong> Add or remove keywords to filter relevant feedback</li>
                                <li><strong>Collect Feedback:</strong> Click the main button to start collection</li>
                                <li><strong>View Results:</strong> Use the navigation to view collected feedback and insights</li>
                            </ol>
                            
                            <h6>Data Sources</h6>
                            <ul>
                                <li><strong>Reddit:</strong> Collects from specified subreddits</li>
                                <li><strong>GitHub:</strong> Collects from repository discussions and issues</li>
                                <li><strong>Fabric Community:</strong> Collects from Microsoft Fabric forums</li>
                                <li><strong>Azure DevOps:</strong> Collects from work items</li>
                            </ul>
                            
                            <h6>Storage Options</h6>
                            <ul>
                                <li><strong>CSV Export:</strong> Always enabled - creates local CSV files</li>
                                <li><strong>Fabric Lakehouse:</strong> Optional - requires authentication</li>
                            </ul>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(helpModal);
            const modal = new bootstrap.Modal(helpModal);
            modal.show();
            
            // Remove modal from DOM when closed
            helpModal.addEventListener('hidden.bs.modal', () => {
                helpModal.remove();
            });
        }

        // Resume collection progress if returning to page during collection
        function resumeCollectionProgress() {
            const inProgress = localStorage.getItem('collectionInProgress') === 'true';
            const startTime = localStorage.getItem('collectionStartTime');
            
            if (inProgress && startTime) {
                collectionInProgress = true;
                collectionStartTime = parseInt(startTime);
                
                const elapsed = Date.now() - collectionStartTime;
                
                // Show progress button
                document.getElementById('collectionProgressBtn').style.display = 'inline-block';
                
                // Check if collection might have completed by polling the server
                checkCollectionStatus(elapsed);
            }
        }
        
        // Check actual collection status from server
        function checkCollectionStatus(elapsed) {
            // First, update UI based on elapsed time
            let currentProgress = 5;
            let currentStatus = 'Checking collection status...';
            let currentSource = 'Verifying operation state...';
            
            if (elapsed > 500) currentProgress = 15;
            if (elapsed > 2000) currentProgress = 35;
            if (elapsed > 4000) currentProgress = 55;
            if (elapsed > 6000) currentProgress = 75;
            if (elapsed > 8000) currentProgress = 90; // Most collections should be done by now
            
            updateCollectionProgress(currentProgress, currentStatus, currentSource);
            addCollectionLog('üîÑ Resuming collection progress tracking...', 'info');
            addCollectionLog('üîç Checking if collection completed while away...', 'info');
            
            // Try to fetch recent collection data to see if it's done
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    if (data.completed) {
                        // Collection is actually done, update to completion
                        addCollectionLog('‚úÖ Collection was completed while you were away!', 'success');
                        completeCollectionOperation(true, `Collection completed with ${data.total || 'unknown'} items`, data);
                    } else {
                        // Collection still in progress, continue simulation
                        addCollectionLog('‚ö° Collection still in progress, continuing monitoring...', 'info');
                        startCollectionProgressSimulation();
                    }
                })
                .catch(error => {
                    // If we can't check status, assume it's still running and continue simulation
                    addCollectionLog('‚ö†Ô∏è Could not verify collection status, assuming still in progress...', 'warning');
                    startCollectionProgressSimulation();
                });
        }

        function writeToFabric() {
            const fabricResultsDiv = document.getElementById('fabricResults');
            
            // Check if we have a stored token from Fabric Auth
            if (!fabricToken || fabricToken === null) {
                fabricResultsDiv.innerHTML = `
                    <div class="alert alert-warning">
                        <strong>No Fabric token available!</strong><br>
                        Please use the <strong>"Fabric Auth"</strong> button above to configure your authentication token first.
                        <button class="btn btn-outline-primary btn-sm ms-2" onclick="toggleFabricAuth()">
                            <i class="bi bi-shield-check me-1"></i>Open Fabric Auth
                        </button>
                    </div>
                `;
                return;
            }
            
            // Use the stored token
            const fabricTokenToUse = fabricToken === 'stored' ? 'stored' : fabricToken;

            if (!lastCollectionHadData) {
                 fabricResultsDiv.innerHTML = '<div class="alert alert-warning">No data from last collection, or last collection failed/yielded no items. Please collect feedback first.</div>';
                 return;
            }

            // Update progress drawer to show Fabric writing state
            startFabricWriteProgress();

            // Show initial progress message
            fabricResultsDiv.innerHTML = `
                <div class="alert alert-info">
                    <strong>üöÄ Initiating Fabric Lakehouse Write...</strong><br>
                    <small>Detailed progress available in Collection Progress drawer</small>
                </div>
            `;

            // Start progressive logging that simulates realistic timing
            addFabricProgressLogs();

            // Add a delayed log before the actual API call
            setTimeout(() => {
                addCollectionLog('üì§ Sending write request to Fabric API...', 'info');
                addCollectionLog('‚è±Ô∏è Request timeout: 10 minutes maximum', 'info');
            }, 3500);

            // Use the async endpoint for better progress tracking
            fetch('/api/write_to_fabric_async', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ fabric_token: fabricTokenToUse }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Enhanced success logging
                    addCollectionLog(`‚úÖ Fabric write operation initiated successfully!`, 'success');
                    addCollectionLog(`üÜî Operation ID: ${data.operation_id}`, 'info');
                    addCollectionLog(`üìä Total items to process: ${data.total_items}`, 'info');
                    addCollectionLog(`üèóÔ∏è Target: Microsoft Fabric Lakehouse`, 'info');
                    addCollectionLog(`‚ö° Processing mode: Asynchronous batch upload`, 'info');
                    addCollectionLog(`üìà Starting progress monitoring...`, 'info');
                    
                    // Update progress badge for Fabric writing
                    const progressBadge = document.getElementById('progressBadge');
                    progressBadge.textContent = 'Writing';
                    progressBadge.className = 'badge bg-warning ms-1';
                    
                    // Update current source display
                    document.getElementById('collectionSourceText').textContent = 'Writing to Fabric Lakehouse';
                    document.getElementById('collectionProgressStatus').textContent = 'Fabric write operation in progress...';
                    
                    fabricResultsDiv.innerHTML = `
                        <div class="alert alert-success">
                            <strong>‚úÖ Fabric Write Operation Started!</strong><br>
                            <small><strong>Operation ID:</strong> ${data.operation_id}</small><br>
                            <small><strong>Items to Process:</strong> ${data.total_items}</small><br>
                            <small><strong>Status:</strong> Processing in background</small>
                        </div>
                    `;
                    
                    // Poll for completion
                    pollForFabricCompletion(data.operation_id, fabricResultsDiv);
                } else {
                    // Enhanced error logging
                    addCollectionLog(`‚ùå Fabric write operation failed to start`, 'danger');
                    addCollectionLog(`üîç Error details: ${data.message}`, 'danger');
                    addCollectionLog(`üí° Suggestion: Verify Bearer token validity`, 'warning');
                    
                    fabricResultsDiv.innerHTML = `<div class="alert alert-danger">
                        <strong>‚ùå Failed to Start Fabric Write</strong><br>
                        <small>${data.message}</small>
                    </div>`;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                // Enhanced network error logging
                addCollectionLog(`‚ùå Network error during Fabric write request`, 'danger');
                addCollectionLog(`üîç Error details: ${error.message}`, 'danger');
                addCollectionLog(`üåê Check network connection and API availability`, 'warning');
                
                fabricResultsDiv.innerHTML = '<div class="alert alert-danger">An unexpected network error occurred while trying to start Fabric write.</div>';
            });
        }

        // Poll for operation completion and show final result
        function pollForCompletion(operationId, resultDiv) {
            const pollInterval = setInterval(() => {
                fetch(`/api/fabric_progress/${operationId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.completed) {
                            clearInterval(pollInterval);
                            
                            if (data.success) {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <strong>üéâ Fabric Write Completed Successfully!</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            } else {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-danger">
                                        <strong>‚ùå Fabric Write Failed</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error polling progress:', error);
                        clearInterval(pollInterval);
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 600000);
        }
    </script>
    
    <!-- Load Bootstrap JavaScript after DOM content -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Ensure Bootstrap is loaded before initializing any components
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, Bootstrap available:', typeof bootstrap !== 'undefined');
            if (typeof bootstrap !== 'undefined') {
                console.log('Bootstrap Offcanvas available:', typeof bootstrap.Offcanvas !== 'undefined');
            }
            
            // Load saved token from localStorage
            const savedToken = localStorage.getItem('fabricToken');
            if (savedToken) {
                const fabricTokenElement = document.getElementById('fabricAuthToken');
                if (fabricTokenElement) {
                    fabricTokenElement.value = savedToken;
                    console.log('Loaded saved token from localStorage');
                } else {
                    console.warn('fabricAuthToken element not found - token not restored');
                }
            }
            
            // Restore progress state from localStorage
            restoreProgressState();
            
            // Resume collection progress if it was in progress
            resumeCollectionProgress();
        });
        
        // Save progress state to localStorage
        function saveProgressState() {
            const progressState = {
                badge: document.getElementById('progressBadge').textContent,
                badgeClass: document.getElementById('progressBadge').className,
                sourceText: document.getElementById('collectionSourceText').textContent,
                progressStatus: document.getElementById('collectionProgressStatus').textContent,
                progressBarWidth: document.getElementById('collectionProgressBar').style.width,
                progressPercentage: document.getElementById('collectionProgressPercentage').textContent,
                currentSourceClass: document.getElementById('currentCollectionSource').className,
                spinnerDisplay: document.getElementById('collectionSpinner').style.display,
                cancelButtonDisabled: document.getElementById('cancelOperation').disabled,
                // Save source counts
                redditCount: document.getElementById('redditCount').textContent,
                fabricCount: document.getElementById('fabricCount').textContent,
                githubCount: document.getElementById('githubCount').textContent,
                adoCount: document.getElementById('adoCount').textContent,
                // Save logs
                logs: document.getElementById('collectionLog').innerHTML,
                timestamp: Date.now()
            };
            localStorage.setItem('progressState', JSON.stringify(progressState));
        }
        
        // Restore progress state from localStorage
        function restoreProgressState() {
            const savedState = localStorage.getItem('progressState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Only restore if state is recent (within 1 hour)
                    if (Date.now() - state.timestamp < 3600000) {
                        // Restore badge
                        document.getElementById('progressBadge').textContent = state.badge;
                        document.getElementById('progressBadge').className = state.badgeClass;
                        
                        // Restore drawer content
                        document.getElementById('collectionSourceText').textContent = state.sourceText;
                        document.getElementById('collectionProgressStatus').textContent = state.progressStatus;
                        document.getElementById('collectionProgressBar').style.width = state.progressBarWidth || '0%';
                        document.getElementById('collectionProgressPercentage').textContent = state.progressPercentage || '0%';
                        document.getElementById('currentCollectionSource').className = state.currentSourceClass || 'alert alert-secondary d-flex align-items-center';
                        document.getElementById('collectionSpinner').style.display = state.spinnerDisplay || 'none';
                        document.getElementById('cancelOperation').disabled = state.cancelButtonDisabled || false;
                        
                        // Restore source counts
                        document.getElementById('redditCount').textContent = state.redditCount || '0';
                        document.getElementById('fabricCount').textContent = state.fabricCount || '0';
                        document.getElementById('githubCount').textContent = state.githubCount || '0';
                        document.getElementById('adoCount').textContent = state.adoCount || '0';
                        
                        // Restore logs
                        if (state.logs) {
                            document.getElementById('collectionLog').innerHTML = state.logs;
                        }
                        
                        // Show progress button if there's an active state
                        if (state.badge !== 'Ready') {
                            document.getElementById('collectionProgressBtn').style.display = 'inline-block';
                        }
                        
                        console.log('Restored complete progress state:', state.badge);
                    } else {
                        // Clear expired state
                        localStorage.removeItem('progressState');
                        console.log('Cleared expired progress state');
                    }
                } catch (e) {
                    console.error('Error restoring progress state:', e);
                    localStorage.removeItem('progressState');
                }
            }
        }
    </script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Initialize application -->
    <script>
        // Source configuration is already initialized in source-configuration.js
        // No additional initialization needed here
    </script>

</body>
</html>
