<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feedback Collector</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" rel="stylesheet">
    
    <!-- Fluent Design CSS -->
    <link href="{{ url_for('static', filename='css/fluent-design.css') }}" rel="stylesheet">
    
    <!-- Legacy scripts -->
    <script src="{{ url_for('static', filename='js/badge-state-manager.js') }}"></script>
    
    <!-- New enhanced scripts -->
    <script src="{{ url_for('static', filename='js/source-configuration.js') }}"></script>
    <script src="{{ url_for('static', filename='js/collection-manager.js') }}"></script>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="app-sidebar">
            <div class="sidebar-header">
                <a href="#" class="sidebar-brand">
                    <i class="bi bi-layers-fill"></i>
                    Feedback Collector
                </a>
            </div>
            
            <nav class="sidebar-nav">
                <div class="nav-section-label">Overview</div>
                <a href="#" class="nav-item active" onclick="switchView('view-dashboard', this)">
                    <i class="bi bi-speedometer2"></i>
                    Dashboard
                </a>
                <a href="/feedback" class="nav-item">
                    <i class="bi bi-table"></i>
                    View Feedback
                </a>
                <a href="/insights" class="nav-item">
                    <i class="bi bi-graph-up"></i>
                    View Insights
                </a>

                <div class="nav-section-label">Configuration</div>
                <a href="#" class="nav-item" onclick="switchView('view-sources', this)">
                    <i class="bi bi-sliders"></i>
                    Sources & Settings
                </a>
                <a href="#" class="nav-item" onclick="switchView('view-taxonomy', this)">
                    <i class="bi bi-tags"></i>
                    Taxonomy
                </a>
                
                <div class="nav-section-label">System</div>
                <a href="#" class="nav-item" onclick="toggleCollectionProgress()">
                    <i class="bi bi-activity"></i>
                    Progress
                    <span class="fluent-badge fluent-badge-secondary ms-auto" id="progressBadge">Ready</span>
                </a>
                <a href="#" class="nav-item" onclick="showHelp()">
                    <i class="bi bi-question-circle"></i>
                    Help
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="app-main">
            
            <!-- Dashboard View -->
            <div id="view-dashboard" class="tab-content active">
                <div class="page-header">
                    <div>
                        <h1 class="page-title">Dashboard</h1>
                        <p class="page-subtitle">Overview of your feedback collection status</p>
                    </div>
                    <button class="fluent-button fluent-button-primary fluent-button-large" id="collectFeedbackBtn">
                        <i class="bi bi-search"></i>
                        Collect Feedback Now
                    </button>
                </div>

                <div id="results" class="mb-4"></div>

                <div class="dashboard-grid">
                    <div class="stat-card">
                        <i class="bi bi-chat-square-text stat-icon"></i>
                        <div class="stat-value" id="statTotalFeedback">--</div>
                        <div class="stat-label">Total Feedback Items</div>
                    </div>
                    <div class="stat-card">
                        <i class="bi bi-clock-history stat-icon"></i>
                        <div class="stat-value" id="statLastCollection">Never</div>
                        <div class="stat-label">Last Collection</div>
                    </div>
                    <div class="stat-card">
                        <i class="bi bi-check-circle stat-icon"></i>
                        <div class="stat-value" id="statActiveSources">4</div>
                        <div class="stat-label">Active Sources</div>
                    </div>
                </div>

                <!-- Quick Status of Sources -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-database"></i>
                            Data Sources Status
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <div id="dataSourcesSummary">
                            <!-- Simplified view of sources will go here -->
                            <div class="alert alert-info">
                                <i class="bi bi-info-circle"></i> Go to <strong>Sources & Settings</strong> to configure your data connectors.
                            </div>
                        </div>
                    </div>
                </section>
            </div>

            <!-- Sources & Settings View -->
            <div id="view-sources" class="tab-content">
                <div class="page-header">
                    <div>
                        <h1 class="page-title">Sources & Settings</h1>
                        <p class="page-subtitle">Configure where and how feedback is collected</p>
                    </div>
                </div>

                <!-- Data Sources -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-database"></i>
                            Data Sources
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <div id="dataSources">
                            <!-- Source cards will be populated by JavaScript -->
                        </div>
                    </div>
                </section>

                <!-- Collection Settings -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-gear"></i>
                            Collection Settings
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <div id="collectionSettings">
                            <!-- Settings will be populated by JavaScript -->
                        </div>
                    </div>
                </section>

                <!-- Storage Options -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-hdd"></i>
                            Storage Options
                            <span class="fluent-badge fluent-badge-secondary">Optional</span>
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <!-- Local Storage -->
                        <div class="config-field">
                            <h3 class="fluent-subtitle">
                                <i class="bi bi-folder"></i>
                                Local Storage
                            </h3>
                            <div class="fluent-alert fluent-alert-success">
                                <i class="bi bi-check-circle"></i>
                                <div>
                                    <strong>CSV Export</strong> - Always enabled<br>
                                    All collected feedback is automatically saved to CSV format in the data folder.
                                </div>
                            </div>
                        </div>

                        <!-- Fabric Storage -->
                        <div class="config-field mt-4">
                            <h3 class="fluent-subtitle">
                                <i class="bi bi-cloud"></i>
                                Microsoft Fabric
                            </h3>
                            <div class="config-field">
                                <label class="fluent-label">Authentication Token:</label>
                                <div class="input-group">
                                    <input type="password" id="fabricAuthToken" class="fluent-input" placeholder="Enter Fabric API Token">
                                    <button class="fluent-button fluent-button-secondary" id="toggleTokenVisibility" onclick="toggleTokenVisibility()">
                                        <i class="bi bi-eye"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="config-field-row">
                                <button class="fluent-button fluent-button-primary" id="connectFabricBtn">
                                    <i class="bi bi-plug"></i> Connect
                                </button>
                                <button class="fluent-button fluent-button-secondary" id="writeToFabricBtn">
                                    <i class="bi bi-upload"></i> Write to Fabric
                                </button>
                            </div>
                            <div id="fabricStatus" class="mt-2">
                                <span class="fluent-badge fluent-badge-secondary" id="fabricAuthBadge">Not Connected</span>
                            </div>
                            <div id="fabricResults" class="mt-2"></div>
                        </div>
                    </div>
                </section>
            </div>

            <!-- Taxonomy View -->
            <div id="view-taxonomy" class="tab-content">
                <div class="page-header">
                    <div>
                        <h1 class="page-title">Taxonomy</h1>
                        <p class="page-subtitle">Manage keywords, categories, and impact types</p>
                    </div>
                </div>

                <!-- Keywords Management -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-tags"></i>
                            Keywords Management
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <div class="config-field">
                            <label class="fluent-label">Add New Keyword:</label>
                            <div class="config-field-row">
                                <input type="text" id="newKeyword" class="fluent-input" placeholder="Enter new keyword">
                                <button class="fluent-button fluent-button-secondary" onclick="addKeyword()">
                                    <i class="bi bi-plus"></i> Add
                                </button>
                            </div>
                        </div>
                        
                        <div class="config-field">
                            <label class="fluent-label">Current Keywords:</label>
                            <div class="keyword-list-container">
                                <ul id="keywordList" class="list-group list-group-flush">
                                    <!-- Keywords will be populated by JavaScript -->
                                </ul>
                            </div>
                        </div>
                        
                        <div class="config-field-row">
                            <button class="fluent-button fluent-button-primary" onclick="saveKeywords()">
                                <i class="bi bi-save"></i> Save Keywords
                            </button>
                            <button class="fluent-button fluent-button-secondary" onclick="restoreDefaultKeywords()">
                                <i class="bi bi-arrow-clockwise"></i> Restore Defaults
                            </button>
                        </div>
                        
                        <div id="keywordsStatus" class="status-message"></div>
                    </div>
                </section>

                <!-- Category Management -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-diagram-3"></i>
                            Category Management
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <div class="alert alert-info mb-3">
                            <i class="bi bi-lightbulb"></i>
                            <strong>How it works:</strong> Each subcategory contains keywords. When feedback arrives, the system scans for these keywords to automatically categorize it.
                            <br><small>Example: A subcategory "Performance Issues" with keywords ["slow", "lag", "performance"] will catch feedback mentioning those words.</small>
                        </div>
                        
                        <div id="categoryTree" class="category-tree">
                            <!-- Category tree will be populated by JavaScript -->
                        </div>
                        
                        <div class="config-field-row mt-3">
                            <button class="fluent-button fluent-button-secondary" onclick="addCategory()">
                                <i class="bi bi-plus-circle"></i> Add Category
                            </button>
                            <button class="fluent-button fluent-button-primary" onclick="saveCategories()">
                                <i class="bi bi-save"></i> Save Categories
                            </button>
                            <button class="fluent-button fluent-button-secondary" onclick="restoreDefaultCategories()">
                                <i class="bi bi-arrow-clockwise"></i> Restore Defaults
                            </button>
                            <button class="fluent-button fluent-button-warning" onclick="recategorizeAll()" id="recategorizeBtn" title="Re-categorize all feedback in the SQL database using current category definitions">
                                <i class="bi bi-arrow-repeat"></i> Re-categorize All
                            </button>
                        </div>
                        
                        <div id="categoriesStatus" class="status-message"></div>
                    </div>
                </section>

                <!-- Impact Type Management -->
                <section class="fluent-card">
                    <div class="fluent-card-header">
                        <h2 class="fluent-section-title">
                            <i class="bi bi-exclamation-triangle"></i>
                            Impact Type Management
                        </h2>
                    </div>
                    <div class="fluent-card-body">
                        <p class="text-muted mb-3">
                            Configure impact types (BUG, FEATURE_REQUEST, etc.) to classify feedback based on keywords.
                        </p>
                        
                        <div id="impactTypeList" class="impact-type-list">
                            <!-- Impact types will be populated by JavaScript -->
                        </div>
                        
                        <div class="config-field-row mt-3">
                            <button class="fluent-button fluent-button-secondary" onclick="addImpactType()">
                                <i class="bi bi-plus-circle"></i> Add Impact Type
                            </button>
                            <button class="fluent-button fluent-button-primary" onclick="saveImpactTypes()">
                                <i class="bi bi-save"></i> Save Impact Types
                            </button>
                            <button class="fluent-button fluent-button-secondary" onclick="restoreDefaultImpactTypes()">
                                <i class="bi bi-arrow-clockwise"></i> Restore Defaults
                            </button>
                        </div>
                        
                        <div id="impactTypesStatus" class="status-message"></div>
                    </div>
                </section>
            </div>

        </main>
    </div>

    <!-- Subcategory Edit Modal -->
    <div id="subcategoryModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>Edit Subcategory</h3>
                <button class="modal-close" onclick="closeSubcategoryModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="config-field">
                    <label for="subName">Subcategory Name:</label>
                    <input type="text" id="subName" class="fluent-input" />
                </div>
                <div class="config-field">
                    <label for="subPriority">Priority:</label>
                    <select id="subPriority" class="fluent-input">
                        <option value="critical">Critical</option>
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="config-field">
                    <label for="subFeatureArea">Feature Area:</label>
                    <input type="text" id="subFeatureArea" class="fluent-input" placeholder="Optional" />
                </div>
                <div class="config-field">
                    <label>Keywords:</label>
                    <div class="keyword-manager">
                        <div class="keyword-input-row">
                            <input type="text" id="newSubcategoryKeyword" class="fluent-input" placeholder="Enter keyword and click Add" />
                            <button type="button" class="fluent-button fluent-button-primary" onclick="addKeywordToSubcategory()">
                                <i class="bi bi-plus-circle"></i> Add
                            </button>
                        </div>
                        <div id="subcategoryKeywordsList" class="keywords-list mt-2">
                            <!-- Keywords will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="fluent-button fluent-button-success" onclick="saveSubcategoryEdit()">
                    <i class="bi bi-check"></i> Save
                </button>
                <button type="button" class="fluent-button fluent-button-secondary" onclick="closeSubcategoryModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Collection Progress Drawer (hidden initially) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="collectionProgressDrawer" data-bs-backdrop="false" data-bs-keyboard="false">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-activity me-2"></i>Collection Progress
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="closeCollectionDrawer" onclick="hideCollectionProgress()"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Progress Overview -->
            <div class="mb-4">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="text-muted">Overall Progress</span>
                    <span id="collectionProgressPercentage" class="badge bg-primary">0%</span>
                </div>
                <div class="progress mb-2">
                    <div class="progress-bar" role="progressbar" id="collectionProgressBar" style="width: 0%"></div>
                </div>
                <div class="d-flex justify-content-between">
                    <small class="text-muted" id="collectionProgressStatus">Initializing...</small>
                    <small class="text-muted" id="collectionProgressETA">ETA: --</small>
                </div>
            </div>

            <!-- Current Source -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Current Source</h6>
                <div class="alert alert-secondary d-flex align-items-center" id="currentCollectionSource">
                    <div class="spinner-border spinner-border-sm me-2" role="status" id="collectionSpinner" style="display: none;">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span id="collectionSourceText">Not started</span>
                </div>
            </div>

            <!-- Source Progress -->
            <div class="mb-4">
                <h6 class="text-muted mb-2">Source Progress</h6>
                <div class="row">
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="redditCount">0</div>
                                <small class="text-muted">Reddit</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-warning" id="redditProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="fabricCount">0</div>
                                <small class="text-muted">Fabric</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-info" id="fabricProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="githubCount">0</div>
                                <small class="text-muted">GitHub</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-success" id="githubProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-6 mb-2">
                        <div class="card text-center">
                            <div class="card-body py-2">
                                <div class="h6 mb-0" id="adoCount">0</div>
                                <small class="text-muted">ADO</small>
                                <div class="progress mt-1" style="height: 4px;">
                                    <div class="progress-bar bg-primary" id="adoProgress" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Log -->
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h6 class="text-muted mb-0">Collection Log</h6>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearCollectionLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
                <div class="border rounded p-2" id="collectionLogContainer" style="height: 250px; overflow-y: auto; background-color: #f8f9fa;">
                    <div id="collectionLog" class="font-monospace small"></div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="d-grid gap-2">
                <button class="btn btn-outline-danger" id="cancelOperation" onclick="cancelOperation()" disabled>
                    <i class="bi bi-x-circle me-1"></i>Cancel Operation
                </button>
            </div>
        </div>
    </div>

    <script>
        // View Switching Logic
        function switchView(viewId, navItem) {
            // Hide all views
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            
            // Show selected view
            document.getElementById(viewId).classList.add('active');
            
            // Update nav state
            if (navItem) {
                document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                navItem.classList.add('active');
            }
        }

        // ...existing code...
        let lastCollectionHadData = false; // Flag to track if collection yielded data
        let currentKeywords = []; // Local cache of keywords for the UI
        let collectionProgressDrawer = null;
        let collectionProgressInterval = null;
        let collectionStartTime = null;
        let collectionOperationId = null;

        // Function to render the keyword list in the UI
        function renderKeywordList(keywords) {

            const list = document.getElementById('keywordList');
            list.innerHTML = ''; // Clear existing list
            keywords.forEach(keyword => {
                const li = document.createElement('li');
                li.className = 'list-group-item d-flex justify-content-between align-items-center';
                li.style.border = '1px solid var(--fabric-gray-40)';
                li.style.marginBottom = '4px';
                li.style.borderRadius = '4px';
                li.textContent = keyword;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'fluent-button-icon';
                removeButton.title = 'Remove keyword';
                removeButton.innerHTML = '<i class="bi bi-trash"></i>';
                removeButton.onclick = function() { removeKeyword(keyword); };
                
                li.appendChild(removeButton);
                list.appendChild(li);
            });
            currentKeywords = [...keywords]; // Update local cache
        }

        // Function to display status messages for keyword operations
        function showKeywordsStatus(message, isError = false) {
            const statusDiv = document.getElementById('keywordsStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message fluent-alert ${isError ? 'fluent-alert-error' : 'fluent-alert-success'}`;
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000); // Hide after 5 seconds
        }

        // Load initial keywords when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            fetch('/api/keywords')
                .then(response => response.json())
                .then(data => {
                    renderKeywordList(data);
                })
                .catch(error => {
                    console.error('Error fetching initial keywords:', error);
                    showKeywordsStatus('Error loading initial keywords.', true);
                });
            
            // Load categories and impact types
            loadCategories();
            loadImpactTypes();
        });

        function addKeyword() {
            const input = document.getElementById('newKeyword');
            const keyword = input.value.trim();
            if (keyword && !currentKeywords.includes(keyword)) {
                currentKeywords.push(keyword);
                renderKeywordList(currentKeywords); // Re-render the list
                input.value = '';
            } else if (currentKeywords.includes(keyword)) {
                showKeywordsStatus(`Keyword "${keyword}" already exists.`, true);
            }
        }

        function removeKeyword(keywordToRemove) {
            currentKeywords = currentKeywords.filter(k => k !== keywordToRemove);
            renderKeywordList(currentKeywords); // Re-render the list
        }
        
        function saveKeywords() {
            fetch('/api/keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ keywords: currentKeywords }), 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus('Keywords saved successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error saving keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error saving keywords.', true);
            });
        }

        function restoreDefaultKeywords() {
            if (!confirm('Are you sure you want to restore default keywords? This will replace your current list.')) {
                return;
            }
            fetch('/api/keywords/restore_default', {
                method: 'POST', 
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    renderKeywordList(data.keywords); 
                    showKeywordsStatus(data.message || 'Default keywords restored successfully!');
                } else {
                    showKeywordsStatus(data.message || 'Error restoring default keywords.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showKeywordsStatus('Error restoring default keywords.', true);
            });
        }

        // ==================== Category Management ====================
        let currentCategories = {};
        
        // Load and render categories
        function loadCategories() {
            fetch('/api/categories')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        currentCategories = data.categories;
                        renderCategoryTree(currentCategories);
                    }
                })
                .catch(error => {
                    console.error('Error loading categories:', error);
                    showCategoriesStatus('Error loading categories.', true);
                });
        }
        
        // Render category tree
        function renderCategoryTree(categories) {
            const treeContainer = document.getElementById('categoryTree');
            treeContainer.innerHTML = '';
            
            Object.keys(categories).forEach(categoryKey => {
                const category = categories[categoryKey];
                const categoryDiv = createCategoryNode(categoryKey, category);
                treeContainer.appendChild(categoryDiv);
            });
        }
        
        // Create category node with subcategories
        function createCategoryNode(key, category) {
            const div = document.createElement('div');
            div.className = 'category-node';
            div.innerHTML = `
                <div class="category-header">
                    <button class="expand-btn" onclick="toggleCategory(this)">
                        <i class="bi bi-chevron-right"></i>
                    </button>
                    <strong>${category.name || key}</strong>
                    <div class="category-actions">
                        <button class="fluent-button-icon" onclick="editCategory('${key}')" title="Edit category">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="fluent-button-icon" onclick="addSubcategory('${key}')" title="Add subcategory">
                            <i class="bi bi-plus-circle"></i>
                        </button>
                        <button class="fluent-button-icon" onclick="deleteCategory('${key}')" title="Delete category">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
                <div class="category-content" style="display: none;">
                    <div class="subcategories-container">
                        ${renderSubcategories(key, category.subcategories || {})}
                    </div>
                </div>
            `;
            return div;
        }
        
        // Render subcategories
        function renderSubcategories(categoryKey, subcategories) {
            let html = '';
            Object.keys(subcategories).forEach(subKey => {
                const sub = subcategories[subKey];
                const keywordCount = (sub.keywords || []).length;
                const keywordPreview = keywordCount > 0 ? 
                    `<span class="keyword-count" title="${(sub.keywords || []).join(', ')}">${keywordCount} keyword${keywordCount !== 1 ? 's' : ''}</span>` : 
                    '<span class="text-muted">No keywords</span>';
                
                html += `
                    <div class="subcategory-node">
                        <div class="subcategory-header">
                            <button class="expand-btn" onclick="toggleSubcategory(this)">
                                <i class="bi bi-chevron-right"></i>
                            </button>
                            <div class="subcategory-info">
                                <span class="subcategory-name">${sub.name || subKey}</span>
                                <div class="subcategory-meta">
                                    <span class="fluent-badge fluent-badge-${getPriorityBadgeClass(sub.priority)}">${sub.priority || 'medium'}</span>
                                    ${keywordPreview}
                                </div>
                            </div>
                            <div class="subcategory-actions">
                                <button class="fluent-button-icon" onclick="editSubcategory('${categoryKey}', '${subKey}')" title="Edit subcategory">
                                    <i class="bi bi-pencil"></i>
                                </button>
                                <button class="fluent-button-icon" onclick="deleteSubcategory('${categoryKey}', '${subKey}')" title="Delete subcategory">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="subcategory-content" style="display: none;">
                            ${renderSubcategoryDetails(sub)}
                        </div>
                    </div>
                `;
            });
            return html || '<p class="text-muted ms-4">No subcategories</p>';
        }
        
        // Helper function for priority badge colors
        function getPriorityBadgeClass(priority) {
            const classes = {
                'critical': 'error',
                'high': 'warning',
                'medium': 'primary',
                'low': 'secondary'
            };
            return classes[priority?.toLowerCase()] || 'secondary';
        }
        
        // Render subcategory details
        function renderSubcategoryDetails(subcategory) {
            return `
                <div class="subcategory-details">
                    ${subcategory.feature_area ? `<div class="mb-2"><strong>Feature Area:</strong> <span class="text-primary">${subcategory.feature_area}</span></div>` : ''}
                    <div class="mb-2">
                        <strong>Keywords that trigger this category:</strong>
                        <div class="keywords-list mt-2">
                            ${subcategory.keywords && subcategory.keywords.length > 0 ? 
                                subcategory.keywords.map(kw => `<span class="keyword-tag">${kw}</span>`).join('') :
                                '<span class="text-muted">No keywords configured - this subcategory won\'t be auto-detected</span>'
                            }
                        </div>
                    </div>
                    <div class="text-muted small">
                        <i class="bi bi-info-circle"></i> Feedback containing any of these keywords will be automatically categorized here
                    </div>
                </div>
            `;
        }
        
        // Toggle category expansion
        function toggleCategory(button) {
            const content = button.closest('.category-header').nextElementSibling;
            const icon = button.querySelector('i');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.className = 'bi bi-chevron-down';
            } else {
                content.style.display = 'none';
                icon.className = 'bi bi-chevron-right';
            }
        }
        
        // Toggle subcategory expansion
        function toggleSubcategory(button) {
            const content = button.closest('.subcategory-header').nextElementSibling;
            const icon = button.querySelector('i');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.className = 'bi bi-chevron-down';
            } else {
                content.style.display = 'none';
                icon.className = 'bi bi-chevron-right';
            }
        }
        
        // Add new category
        function addCategory() {
            const name = prompt('Enter category name:');
            if (!name) return;
            
            const key = name.toUpperCase().replace(/\s+/g, '_');
            if (currentCategories[key]) {
                alert('Category already exists!');
                return;
            }
            
            currentCategories[key] = {
                name: name,
                subcategories: {}
            };
            renderCategoryTree(currentCategories);
        }
        
        // Edit category
        function editCategory(key) {
            const category = currentCategories[key];
            const newName = prompt('Edit category name:', category.name);
            if (newName && newName !== category.name) {
                category.name = newName;
                renderCategoryTree(currentCategories);
            }
        }
        
        // Delete category
        function deleteCategory(key) {
            if (!confirm(`Delete category "${currentCategories[key].name}"?`)) return;
            delete currentCategories[key];
            renderCategoryTree(currentCategories);
        }
        
        // Add subcategory
        function addSubcategory(categoryKey) {
            const name = prompt('Enter subcategory name:');
            if (!name) return;
            
            const subKey = name.toUpperCase().replace(/\s+/g, '_');
            if (currentCategories[categoryKey].subcategories[subKey]) {
                alert('Subcategory already exists!');
                return;
            }
            
            currentCategories[categoryKey].subcategories[subKey] = {
                name: name,
                keywords: [],
                priority: 'medium',
                feature_area: ''
            };
            renderCategoryTree(currentCategories);
        }
        
        // Edit subcategory (opens modal)
        let editingCategoryKey = null;
        let editingSubKey = null;
        let tempKeywords = [];
        
        function editSubcategory(categoryKey, subKey) {
            const sub = currentCategories[categoryKey].subcategories[subKey];
            
            editingCategoryKey = categoryKey;
            editingSubKey = subKey;
            tempKeywords = [...(sub.keywords || [])];
            
            document.getElementById('subName').value = sub.name;
            document.getElementById('subPriority').value = sub.priority || 'medium';
            document.getElementById('subFeatureArea').value = sub.feature_area || '';
            
            renderSubcategoryKeywordsList();
            document.getElementById('subcategoryModal').style.display = 'flex';
        }
        
        function renderSubcategoryKeywordsList() {
            const container = document.getElementById('subcategoryKeywordsList');
            if (tempKeywords.length === 0) {
                container.innerHTML = '<span class="text-muted">No keywords added yet</span>';
                return;
            }
            
            container.innerHTML = tempKeywords.map((kw, idx) => `
                <span class="keyword-tag">
                    ${kw}
                    <button class="keyword-remove" onclick="removeKeywordFromSubcategory(${idx})" title="Remove keyword">
                        <i class="bi bi-x"></i>
                    </button>
                </span>
            `).join('');
        }
        
        function addKeywordToSubcategory() {
            console.log('addKeywordToSubcategory called');
            const input = document.getElementById('newSubcategoryKeyword');
            if (!input) {
                console.error('newSubcategoryKeyword input not found');
                return;
            }
            
            console.log('Input element:', input);
            console.log('Input value before trim:', input.value);
            const keyword = input.value.trim();
            console.log('Keyword after trim:', keyword);
            
            if (!keyword) {
                console.log('Empty keyword, returning');
                alert('Please enter a keyword before clicking Add');
                return;
            }
            
            if (tempKeywords.includes(keyword)) {
                alert('Keyword already exists!');
                return;
            }
            
            tempKeywords.push(keyword);
            console.log('Keywords after adding:', tempKeywords);
            input.value = '';
            renderSubcategoryKeywordsList();
        }
        
        // Make function globally accessible
        window.addKeywordToSubcategory = addKeywordToSubcategory;
        
        function removeKeywordFromSubcategory(index) {
            tempKeywords.splice(index, 1);
            renderSubcategoryKeywordsList();
        }
        
        function saveSubcategoryEdit() {
            const sub = currentCategories[editingCategoryKey].subcategories[editingSubKey];
            
            sub.name = document.getElementById('subName').value.trim();
            sub.priority = document.getElementById('subPriority').value;
            sub.feature_area = document.getElementById('subFeatureArea').value.trim();
            sub.keywords = [...tempKeywords];
            
            closeSubcategoryModal();
            renderCategoryTree(currentCategories);
        }
        
        function closeSubcategoryModal() {
            document.getElementById('subcategoryModal').style.display = 'none';
            editingCategoryKey = null;
            editingSubKey = null;
            tempKeywords = [];
        }
        
        // Make functions globally accessible
        window.removeKeywordFromSubcategory = removeKeywordFromSubcategory;
        window.saveSubcategoryEdit = saveSubcategoryEdit;
        window.closeSubcategoryModal = closeSubcategoryModal;
        
        // Allow Enter key to add keyword in subcategory modal
        document.addEventListener('DOMContentLoaded', function() {
            const newKeywordInput = document.getElementById('newSubcategoryKeyword');
            if (newKeywordInput) {
                newKeywordInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addKeywordToSubcategory();
                    }
                });
            }
        });
        
        // Delete subcategory
        function deleteSubcategory(categoryKey, subKey) {
            if (!confirm(`Delete subcategory "${currentCategories[categoryKey].subcategories[subKey].name}"?`)) return;
            delete currentCategories[categoryKey].subcategories[subKey];
            renderCategoryTree(currentCategories);
        }
        
        // Save categories
        function saveCategories() {
            fetch('/api/categories', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(currentCategories)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showCategoriesStatus('Categories saved successfully!');
                } else {
                    showCategoriesStatus(data.message || 'Error saving categories.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showCategoriesStatus('Error saving categories.', true);
            });
        }
        
        // Restore default categories
        function restoreDefaultCategories() {
            if (!confirm('Restore default categories? This will replace your current configuration.')) return;
            
            fetch('/api/categories/restore_default', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    currentCategories = data.categories;
                    renderCategoryTree(currentCategories);
                    showCategoriesStatus('Default categories restored!');
                } else {
                    showCategoriesStatus(data.message || 'Error restoring defaults.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showCategoriesStatus('Error restoring defaults.', true);
            });
        }
        
        // Show categories status message
        function showCategoriesStatus(message, isError = false) {
            const statusDiv = document.getElementById('categoriesStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message fluent-alert ${isError ? 'fluent-alert-error' : 'fluent-alert-success'}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        // Re-categorize all feedback in SQL using current categories
        function recategorizeAll() {
            // First check if connected to SQL
            fetch('/api/session_state')
                .then(response => response.json())
                .then(state => {
                    if (!state.fabric_sql_connected) {
                        showCategoriesStatus('Not connected to Fabric SQL. Please authenticate first via Sources & Settings.', true);
                        return;
                    }
                    
                    if (!confirm('This will re-categorize ALL feedback in the SQL database using the current category definitions.\n\nItems you manually categorized will be skipped.\n\nContinue?')) {
                        return;
                    }
                    
                    const btn = document.getElementById('recategorizeBtn');
                    btn.disabled = true;
                    btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Re-categorizing...';
                    showCategoriesStatus('Re-categorizing feedback... This may take a moment.');
                    
                    fetch('/api/categories/recategorize', { method: 'POST' })
                        .then(response => response.json())
                        .then(data => {
                            btn.disabled = false;
                            btn.innerHTML = '<i class="bi bi-arrow-repeat"></i> Re-categorize All';
                            if (data.status === 'success') {
                                showCategoriesStatus(data.message);
                            } else {
                                showCategoriesStatus(data.message || 'Error during re-categorization.', true);
                            }
                        })
                        .catch(error => {
                            btn.disabled = false;
                            btn.innerHTML = '<i class="bi bi-arrow-repeat"></i> Re-categorize All';
                            console.error('Error:', error);
                            showCategoriesStatus('Error during re-categorization.', true);
                        });
                })
                .catch(error => {
                    console.error('Error checking session state:', error);
                    showCategoriesStatus('Could not verify SQL connection status.', true);
                });
        }

        // ==================== Impact Type Management ====================
        let currentImpactTypes = {};
        
        // Load and render impact types
        function loadImpactTypes() {
            fetch('/api/impact-types')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        currentImpactTypes = data.impact_types;
                        renderImpactTypeList(currentImpactTypes);
                    }
                })
                .catch(error => {
                    console.error('Error loading impact types:', error);
                    showImpactTypesStatus('Error loading impact types.', true);
                });
        }
        
        // Render impact type list
        function renderImpactTypeList(impactTypes) {
            const container = document.getElementById('impactTypeList');
            container.innerHTML = '';
            
            Object.keys(impactTypes).forEach(key => {
                const type = impactTypes[key];
                const typeCard = createImpactTypeCard(key, type);
                container.appendChild(typeCard);
            });
        }
        
        // Create impact type card
        function createImpactTypeCard(key, type) {
            const div = document.createElement('div');
            div.className = 'impact-type-card';
            div.style.borderLeft = `4px solid ${type.color || '#666'}`;
            
            div.innerHTML = `
                <div class="impact-type-header">
                    <div class="impact-type-info">
                        <span class="impact-type-name" style="color: ${type.color || '#666'}">
                            <strong>${key}</strong>
                        </span>
                        <span class="impact-type-priority fluent-badge fluent-badge-${getPriorityClass(type.priority)}">
                            ${type.priority}
                        </span>
                    </div>
                    <div class="impact-type-actions">
                        <button class="fluent-button-icon" onclick="editImpactType('${key}')" title="Edit impact type">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="fluent-button-icon" onclick="deleteImpactType('${key}')" title="Delete impact type">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
                <div class="impact-type-details">
                    ${type.description ? `<p class="text-muted">${type.description}</p>` : ''}
                    <div class="keywords-list">
                        ${(type.keywords || []).map(kw => `<span class="keyword-tag">${kw}</span>`).join('')}
                    </div>
                </div>
            `;
            return div;
        }
        
        // Helper function for priority badge color
        function getPriorityClass(priority) {
            const classes = {
                'critical': 'error',
                'high': 'warning',
                'medium': 'primary',
                'low': 'secondary'
            };
            return classes[priority?.toLowerCase()] || 'secondary';
        }
        
        // Add new impact type
        function addImpactType() {
            const key = prompt('Enter impact type key (e.g., BUG, FEATURE_REQUEST):');
            if (!key) return;
            
            const upperKey = key.toUpperCase().replace(/\s+/g, '_');
            if (currentImpactTypes[upperKey]) {
                alert('Impact type already exists!');
                return;
            }
            
            const description = prompt('Description:') || '';
            const priority = prompt('Priority (critical/high/medium/low):', 'medium') || 'medium';
            const color = prompt('Color (hex code):', '#666') || '#666';
            const keywordsStr = prompt('Keywords (comma-separated):') || '';
            
            currentImpactTypes[upperKey] = {
                description: description,
                priority: priority.toLowerCase(),
                color: color,
                keywords: keywordsStr ? keywordsStr.split(',').map(k => k.trim()).filter(k => k) : []
            };
            renderImpactTypeList(currentImpactTypes);
        }
        
        // Edit impact type
        function editImpactType(key) {
            const type = currentImpactTypes[key];
            
            const description = prompt('Description:', type.description) || '';
            const priority = prompt('Priority (critical/high/medium/low):', type.priority) || 'medium';
            const color = prompt('Color (hex code):', type.color) || '#666';
            const keywordsStr = prompt('Keywords (comma-separated):', (type.keywords || []).join(', '));
            
            type.description = description;
            type.priority = priority.toLowerCase();
            type.color = color;
            type.keywords = keywordsStr ? keywordsStr.split(',').map(k => k.trim()).filter(k => k) : [];
            
            renderImpactTypeList(currentImpactTypes);
        }
        
        // Delete impact type
        function deleteImpactType(key) {
            if (!confirm(`Delete impact type "${key}"?`)) return;
            delete currentImpactTypes[key];
            renderImpactTypeList(currentImpactTypes);
        }
        
        // Save impact types
        function saveImpactTypes() {
            fetch('/api/impact-types', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ impact_types: currentImpactTypes })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showImpactTypesStatus('Impact types saved successfully!');
                } else {
                    showImpactTypesStatus(data.message || 'Error saving impact types.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showImpactTypesStatus('Error saving impact types.', true);
            });
        }
        
        // Restore default impact types
        function restoreDefaultImpactTypes() {
            if (!confirm('Restore default impact types? This will replace your current configuration.')) return;
            
            fetch('/api/impact-types/restore_default', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    currentImpactTypes = data.impact_types;
                    renderImpactTypeList(currentImpactTypes);
                    showImpactTypesStatus('Default impact types restored!');
                } else {
                    showImpactTypesStatus(data.message || 'Error restoring defaults.', true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showImpactTypesStatus('Error restoring defaults.', true);
            });
        }
        
        // Show impact types status message
        function showImpactTypesStatus(message, isError = false) {
            const statusDiv = document.getElementById('impactTypesStatus');
            statusDiv.textContent = message;
            statusDiv.className = `status-message fluent-alert ${isError ? 'fluent-alert-error' : 'fluent-alert-success'}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // Toggle the collection progress drawer
        function toggleCollectionProgress() {
            const drawer = document.getElementById('collectionProgressDrawer');
            
            if (!collectionProgressDrawer) {
                collectionProgressDrawer = new bootstrap.Offcanvas(drawer);
            }
            collectionProgressDrawer.show();
        }

        // Hide the collection progress drawer
        function hideCollectionProgress() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Initialize Collection progress (button is always visible)
        function showCollectionProgressDrawer() {
            resetCollectionDrawer();
            collectionStartTime = Date.now();
            
            // Update progress badge to show active state
            const progressBadge = document.getElementById('progressBadge');
            progressBadge.textContent = '0%';
            progressBadge.className = 'fluent-badge fluent-badge-primary ms-auto'; // Change to primary blue when active
        }

        // Reset collection drawer to initial state
        function resetCollectionDrawer() {
            document.getElementById('collectionProgressBar').style.width = '0%';
            document.getElementById('collectionProgressPercentage').textContent = '0%';
            document.getElementById('collectionProgressStatus').textContent = 'Ready to start...';
            document.getElementById('collectionProgressETA').textContent = 'ETA: --';
            document.getElementById('collectionSourceText').textContent = 'Not started';
            // Hide spinner initially
            document.getElementById('collectionSpinner').style.display = 'none';
            // Set initial alert color to neutral
            document.getElementById('currentCollectionSource').className = 'alert alert-secondary d-flex align-items-center';
            document.getElementById('collectionLog').innerHTML = '';
            
            // Ensure cancel button is enabled and properly styled
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = false;
            cancelButton.classList.remove('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            // Reset source counts and progress
            ['reddit', 'fabric', 'github', 'ado'].forEach(source => {
                document.getElementById(`${source}Count`).textContent = '0';
                document.getElementById(`${source}Progress`).style.width = '0%';
            });
            
            // Don't add log until collection starts
        }

        // Add log entry to collection drawer
        function addCollectionLog(message, type = 'info') {
            const logContainer = document.getElementById('collectionLog');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `mb-1 text-${type}`;
            logEntry.innerHTML = `<span class="text-muted">[${timestamp}]</span> ${message}`;
            
            logContainer.appendChild(logEntry);
            
            // Auto-scroll to bottom
            const container = document.getElementById('collectionLogContainer');
            container.scrollTop = container.scrollHeight;
        }

        // Update collection progress
        function updateCollectionProgress(progress, status, currentSource, sourceCounts = {}) {
            // Update main progress bar in drawer
            const mainProgressBar = document.getElementById('collectionProgressBar');
            if (mainProgressBar) {
                mainProgressBar.style.width = `${progress}%`;
                document.getElementById('collectionProgressPercentage').textContent = `${Math.round(progress)}%`;
                document.getElementById('collectionProgressStatus').textContent = status;
                document.getElementById('collectionSourceText').textContent = currentSource;
            }
            
            // Update progress button badge
            const progressBadge = document.getElementById('progressBadge');
            if (progressBadge) {
                progressBadge.textContent = `${Math.round(progress)}%`;
            }
            
            // Save progress state for persistence
            saveProgressState();
            
            // Show spinner when collection is active and change alert color
            const spinner = document.getElementById('collectionSpinner');
            const currentSourceDiv = document.getElementById('currentCollectionSource');
            if (spinner && progress > 0 && progress < 100) {
                spinner.style.display = 'inline-block';
                currentSourceDiv.className = 'alert alert-info d-flex align-items-center';
            } else if (spinner && progress >= 100) {
                spinner.style.display = 'none';
                currentSourceDiv.className = 'alert alert-success d-flex align-items-center';
            }
            
            // Update source counts and progress
            Object.keys(sourceCounts).forEach(source => {
                const countElement = document.getElementById(`${source}Count`);
                const progressElement = document.getElementById(`${source}Progress`);
                if (countElement && progressElement) {
                    const count = sourceCounts[source] || 0;
                    countElement.textContent = count;
                    // Set progress to 100% if this source is complete, 50% if in progress, 0% if not started
                    if (currentSource.toLowerCase().includes(source)) {
                        progressElement.style.width = '50%';
                    } else if (count > 0) {
                        progressElement.style.width = '100%';
                    }
                }
            });
            
            // Calculate ETA
            if (progress > 0 && progress < 100 && collectionStartTime) {
                const elapsed = Date.now() - collectionStartTime;
                const estimatedTotal = (elapsed / progress) * 100;
                const remaining = Math.max(0, estimatedTotal - elapsed);
                const etaMinutes = Math.floor(remaining / 60000);
                const etaSeconds = Math.floor((remaining % 60000) / 1000);
                const etaElement = document.getElementById('collectionProgressETA');
                if (etaElement) {
                    etaElement.textContent = `ETA: ${etaMinutes}m ${etaSeconds}s`;
                }
            }
        }

        // Complete collection operation
        function completeCollectionOperation(success, message, results = {}) {
            document.getElementById('collectionSpinner').style.display = 'none';
            
            // Update collection source text to show completion
            const sourceTextElement = document.getElementById('collectionSourceText');
            if (sourceTextElement) {
                sourceTextElement.textContent = success ? 'Completed' : 'Error';
                console.log(`[COMPLETION FIX] Updated collectionSourceText to: "${success ? 'Completed' : 'Error'}"`);
            }
            
            // Disable cancel button when collection is complete - ensure visual feedback
            const cancelButton = document.getElementById('cancelOperation');
            cancelButton.disabled = true;
            cancelButton.classList.add('disabled');
            
            document.getElementById('closeCollectionDrawer').disabled = false;
            
            const progressBadge = document.getElementById('progressBadge');
            
            if (success) {
                updateCollectionProgress(100, 'Collection completed successfully', 'Completed');
                addCollectionLog(` ${message}`, 'success');
                
                // Update final counts
                Object.keys(results).forEach(source => {
                    if (source !== 'total') {
                        document.getElementById(`${source}Count`).textContent = results[source] || 0;
                        document.getElementById(`${source}Progress`).style.width = '100%';
                    }
                });
                
                // Update badge to show completion
                progressBadge.textContent = 'Complete';
                progressBadge.className = 'fluent-badge fluent-badge-success ms-auto';
            } else {
                addCollectionLog(` ${message}`, 'danger');
                // Update badge to show error
                progressBadge.textContent = 'Error';
                progressBadge.className = 'fluent-badge fluent-badge-error ms-auto';
            }
            
            // Save progress state
            saveProgressState();
        }

        // Close collection drawer
        function closeCollectionDrawer() {
            if (collectionProgressDrawer) {
                collectionProgressDrawer.hide();
            }
        }

        // Cancel current operation (collection or Fabric write)
        function cancelOperation() {
            const currentSource = document.getElementById('collectionSourceText').textContent;
            
            if (currentSource.includes('Fabric') || currentSource.includes('Writing')) {
                addCollectionLog(' Fabric write cancellation requested...', 'warning');
                // TODO: Implement actual Fabric write cancellation via API
            } else {
                addCollectionLog(' Collection cancellation requested...', 'warning');
                // TODO: Implement actual collection cancellation
            }
            
            document.getElementById('cancelOperation').disabled = true;
        }

        // Clear collection log
        function clearCollectionLog() {
            document.getElementById('collectionLog').innerHTML = '';
        }

        let collectionInProgress = false;

        function collectFeedback() {
            // Use the new enhanced collection manager
            if (window.enhancedCollectionManager) {
                window.enhancedCollectionManager.startCollection();
            } else {
                // Fallback to legacy implementation
                const resultsDiv = document.getElementById('results');
                const adoWorkItemId = document.getElementById('adoWorkItemId')?.value?.trim();
                resultsDiv.innerHTML = '<div class="alert alert-info">Starting feedback collection...</div>';

                // Mark collection as in progress
                collectionInProgress = true;
                collectionStartTime = Date.now();
                localStorage.setItem('collectionInProgress', 'true');
                localStorage.setItem('collectionStartTime', collectionStartTime.toString());

                // Show progress button and initialize drawer
                showCollectionProgressDrawer();
                
                const requestBody = {};
                if (adoWorkItemId) {
                    requestBody.ado_work_item_id = adoWorkItemId;
                }
                
                // Start actual collection process
                addCollectionLog(' Starting feedback collection process...', 'info');
                addCollectionLog(' Preparing collection request...', 'info');
                updateCollectionProgress(5, 'Sending request to server...', 'Initializing collection...');
                
                // Start progress simulation that's resilient to navigation
                startCollectionProgressSimulation();
                
                fetch('/api/collect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                })
                .then(response => response.json())
                .then(data => {
                    // Mark collection as complete
                    collectionInProgress = false;
                    localStorage.removeItem('collectionInProgress');
                    localStorage.removeItem('collectionStartTime');
                    
                    // Update progress with final results
                    updateCollectionProgress(100, 'Collection completed successfully', 'Completed', {
                        reddit: data.reddit,
                        fabric: data.fabric,
                        github: data.github,
                        ado: data.ado
                    });
                    
                    addCollectionLog(` Collection completed! Total: ${data.total} items`, 'success');
                    addCollectionLog(` Reddit: ${data.reddit}, Fabric: ${data.fabric}, GitHub: ${data.github}, ADO: ${data.ado}`, 'info');
                    
                    resultsDiv.innerHTML = `
                        <div class="alert alert-success">
                            <h5> Collection Complete!</h5>
                            <ul>
                                <li>Reddit: ${data.reddit} items</li>
                                <li>Fabric Community: ${data.fabric} items</li>
                                <li>GitHub Discussions: ${data.github} items</li>
                                <li>ADO Child Tasks: ${data.ado} items</li>
                                <li><strong>Total: ${data.total} items</strong></li>
                            </ul>
                            <small class="text-muted">Click "Collection Progress" to see detailed logs.</small>
                        </div>
                    `;
                    lastCollectionHadData = data.total > 0;
                    
                    completeCollectionOperation(true, `Successfully collected ${data.total} feedback items`, data);
                })
                .catch(error => {
                    console.error('Collection error:', error);
                    collectionInProgress = false;
                    localStorage.removeItem('collectionInProgress');
                    localStorage.removeItem('collectionStartTime');
                    updateCollectionProgress(0, 'Collection failed', 'Error: ' + error.message);
                    
                    resultsDiv.innerHTML = '<div class="alert alert-danger"> Error collecting feedback</div>';
                    lastCollectionHadData = false;
                    
                    addCollectionLog(` Collection failed: ${error.message}`, 'danger');
                    completeCollectionOperation(false, `Collection failed: ${error.message}`);
                });
            }
        }

        // Progress simulation that continues even after navigation
        function startCollectionProgressSimulation() {
            const progressSteps = [
                { time: 500, progress: 15, message: ' Starting Reddit collection...', status: 'Collecting from Reddit...', source: 'Searching Reddit posts...' },
                { time: 2000, progress: 35, message: ' Starting Fabric Community collection...', status: 'Collecting from Fabric Community...', source: 'Scraping community forums...' },
                { time: 4000, progress: 55, message: ' Starting GitHub Discussions collection...', status: 'Collecting from GitHub...', source: 'Fetching GitHub discussions...' },
                { time: 6000, progress: 75, message: ' Starting Azure DevOps collection...', status: 'Collecting from Azure DevOps...', source: 'Querying ADO work items...' }
            ];

            progressSteps.forEach(step => {
                setTimeout(() => {
                    // Only continue if collection is still in progress
                    if (collectionInProgress || localStorage.getItem('collectionInProgress') === 'true') {
                        addCollectionLog(step.message, 'info');
                        updateCollectionProgress(step.progress, step.status, step.source);
                    }
                }, step.time);
            });
        }

        function showHelp() {
            const helpModal = document.createElement('div');
            helpModal.className = 'modal fade';
            helpModal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-question-circle"></i>
                                Feedback Collector Help
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <h6>How to Use</h6>
                            <ol>
                                <li><strong>Configure Data Sources:</strong> Enable/disable sources and customize their settings</li>
                                <li><strong>Adjust Collection Settings:</strong> Set time ranges, limits, and filters</li>
                                <li><strong>Manage Keywords:</strong> Add or remove keywords to filter relevant feedback</li>
                                <li><strong>Collect Feedback:</strong> Click the main button to start collection</li>
                                <li><strong>View Results:</strong> Use the navigation to view collected feedback and insights</li>
                            </ol>
                            
                            <h6>Data Sources</h6>
                            <ul>
                                <li><strong>Reddit:</strong> Collects from specified subreddits</li>
                                <li><strong>GitHub:</strong> Collects from repository discussions and issues</li>
                                <li><strong>Fabric Community:</strong> Collects from Microsoft Fabric forums</li>
                                <li><strong>Azure DevOps:</strong> Collects from work items</li>
                            </ul>
                            
                            <h6>Storage Options</h6>
                            <ul>
                                <li><strong>CSV Export:</strong> Always enabled - creates local CSV files</li>
                                <li><strong>Fabric Lakehouse:</strong> Optional - requires authentication</li>
                            </ul>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(helpModal);
            const modal = new bootstrap.Modal(helpModal);
            modal.show();
            
            // Remove modal from DOM when closed
            helpModal.addEventListener('hidden.bs.modal', () => {
                helpModal.remove();
            });
        }

        // Resume collection progress if returning to page during collection
        function resumeCollectionProgress() {
            const inProgress = localStorage.getItem('collectionInProgress') === 'true';
            const startTime = localStorage.getItem('collectionStartTime');
            
            if (inProgress && startTime) {
                collectionInProgress = true;
                collectionStartTime = parseInt(startTime);
                
                const elapsed = Date.now() - collectionStartTime;
                
                // Show progress button
                // document.getElementById('collectionProgressBtn').style.display = 'inline-block';
                
                // Check if collection might have completed by polling the server
                checkCollectionStatus(elapsed);
            }
        }
        
        // Check actual collection status from server
        function checkCollectionStatus(elapsed) {
            // First, update UI based on elapsed time
            let currentProgress = 5;
            let currentStatus = 'Checking collection status...';
            let currentSource = 'Verifying operation state...';
            
            if (elapsed > 500) currentProgress = 15;
            if (elapsed > 2000) currentProgress = 35;
            if (elapsed > 4000) currentProgress = 55;
            if (elapsed > 6000) currentProgress = 75;
            if (elapsed > 8000) currentProgress = 90; // Most collections should be done by now
            
            updateCollectionProgress(currentProgress, currentStatus, currentSource);
            addCollectionLog(' Resuming collection progress tracking...', 'info');
            addCollectionLog(' Checking if collection completed while away...', 'info');
            
            // Try to fetch recent collection data to see if it's done
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    if (data.completed) {
                        // Collection is actually done, update to completion
                        addCollectionLog(' Collection was completed while you were away!', 'success');
                        completeCollectionOperation(true, `Collection completed with ${data.total || 'unknown'} items`, data);
                    } else {
                        // Collection still in progress, continue simulation
                        addCollectionLog(' Collection still in progress, continuing monitoring...', 'info');
                        startCollectionProgressSimulation();
                    }
                })
                .catch(error => {
                    // If we can't check status, assume it's still running and continue simulation
                    addCollectionLog(' Could not verify collection status, assuming still in progress...', 'warning');
                    startCollectionProgressSimulation();
                });
        }

        // Poll for operation completion and show final result
        function pollForCompletion(operationId, resultDiv) {
            const pollInterval = setInterval(() => {
                fetch(`/api/fabric_progress/${operationId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.completed) {
                            clearInterval(pollInterval);
                            
                            if (data.success) {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-success">
                                        <strong> Fabric Write Completed Successfully!</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            } else {
                                resultDiv.innerHTML = `
                                    <div class="alert alert-danger">
                                        <strong> Fabric Write Failed</strong><br>
                                        <small>${data.message}</small>
                                    </div>
                                `;
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error polling progress:', error);
                        clearInterval(pollInterval);
                    });
            }, 2000); // Poll every 2 seconds
            
            // Stop polling after 10 minutes to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 600000);
        }

        // Toggle token visibility
        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('fabricAuthToken');
            const icon = document.querySelector('#toggleTokenVisibility i');
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                icon.className = 'bi bi-eye-slash';
            } else {
                tokenInput.type = 'password';
                icon.className = 'bi bi-eye';
            }
        }
    </script>
    
    <!-- Load Bootstrap JavaScript after DOM content -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Ensure Bootstrap is loaded before initializing any components
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, Bootstrap available:', typeof bootstrap !== 'undefined');
            if (typeof bootstrap !== 'undefined') {
                console.log('Bootstrap Offcanvas available:', typeof bootstrap.Offcanvas !== 'undefined');
            }
            
            // Load saved token from localStorage
            const savedToken = localStorage.getItem('fabricToken');
            if (savedToken) {
                const fabricTokenElement = document.getElementById('fabricAuthToken');
                if (fabricTokenElement) {
                    fabricTokenElement.value = savedToken;
                    console.log('Loaded saved token from localStorage');
                } else {
                    // console.warn('fabricAuthToken element not found - token not restored');
                }
            }
            
            // Restore progress state from localStorage
            restoreProgressState();
            
            // Start persistent collection status polling (works across all views)
            startCollectionStatusPolling();
        });
        
        // ==================== Persistent Collection Status Polling ====================
        let collectionStatusPollInterval = null;
        let lastKnownCollectionStatus = 'ready';
        
        function startCollectionStatusPolling() {
            // Poll immediately on start
            pollCollectionStatus();
            
            // Then poll every 2 seconds
            if (collectionStatusPollInterval) clearInterval(collectionStatusPollInterval);
            collectionStatusPollInterval = setInterval(pollCollectionStatus, 2000);
        }
        
        function pollCollectionStatus() {
            fetch('/api/collection_status')
                .then(response => response.json())
                .then(data => {
                    const prevStatus = lastKnownCollectionStatus;
                    lastKnownCollectionStatus = data.status;
                    
                    // Update progress badge
                    const progressBadge = document.getElementById('progressBadge');
                    if (!progressBadge) return;
                    
                    if (data.status === 'running') {
                        const progress = Math.round(data.progress || 0);
                        progressBadge.textContent = `${progress}%`;
                        progressBadge.className = 'fluent-badge fluent-badge-primary ms-auto';
                        
                        // Update progress drawer UI with real server data
                        updateCollectionProgress(
                            progress, 
                            data.message || 'Collecting...', 
                            data.current_source || 'Processing...',
                            data.source_counts || {}
                        );
                        
                        // Show spinner
                        const spinner = document.getElementById('collectionSpinner');
                        if (spinner) spinner.style.display = 'inline-block';
                        const currentSourceDiv = document.getElementById('currentCollectionSource');
                        if (currentSourceDiv) currentSourceDiv.className = 'alert alert-info d-flex align-items-center';
                        
                        // If we just detected a running collection (e.g. after page load), log it
                        if (prevStatus !== 'running') {
                            addCollectionLog(' Collection in progress...', 'info');
                            collectionInProgress = true;
                            collectionStartTime = data.start_time ? new Date(data.start_time).getTime() : Date.now();
                        }
                        
                    } else if (data.status === 'completed') {
                        progressBadge.textContent = 'Complete';
                        progressBadge.className = 'fluent-badge fluent-badge-success ms-auto';
                        
                        // If transitioning from running to completed, finalize the UI
                        if (prevStatus === 'running') {
                            collectionInProgress = false;
                            localStorage.removeItem('collectionInProgress');
                            localStorage.removeItem('collectionStartTime');
                            
                            completeCollectionOperation(
                                true, 
                                `Collection completed with ${data.total_items || 0} items`,
                                data.source_counts || {}
                            );
                            addCollectionLog(` Collection completed! Total: ${data.total_items || 0} items`, 'success');
                            
                            // Log source counts
                            if (data.source_counts) {
                                const counts = Object.entries(data.source_counts)
                                    .map(([k, v]) => `${k}: ${v}`)
                                    .join(', ');
                                addCollectionLog(` ${counts}`, 'info');
                            }
                        }
                        
                    } else if (data.status === 'error') {
                        progressBadge.textContent = 'Error';
                        progressBadge.className = 'fluent-badge fluent-badge-error ms-auto';
                        
                        if (prevStatus === 'running') {
                            collectionInProgress = false;
                            localStorage.removeItem('collectionInProgress');
                            localStorage.removeItem('collectionStartTime');
                            completeCollectionOperation(false, data.error_message || 'Collection failed');
                            addCollectionLog(` ${data.error_message || 'Collection failed'}`, 'danger');
                        }
                        
                    } else {
                        // ready state  only update badge if not showing a recent completion
                        if (prevStatus === 'ready') {
                            progressBadge.textContent = 'Ready';
                            progressBadge.className = 'fluent-badge fluent-badge-secondary ms-auto';
                        }
                    }
                    
                    // Save progress state for restore
                    saveProgressState();
                })
                .catch(error => {
                    // Silent failure  don't spam errors on network issues
                    console.debug('Collection status poll failed:', error);
                });
        }
        
        // Save progress state to localStorage
        function saveProgressState() {
            const progressState = {
                badge: document.getElementById('progressBadge').textContent,
                badgeClass: document.getElementById('progressBadge').className,
                sourceText: document.getElementById('collectionSourceText').textContent,
                progressStatus: document.getElementById('collectionProgressStatus').textContent,
                progressBarWidth: document.getElementById('collectionProgressBar').style.width,
                progressPercentage: document.getElementById('collectionProgressPercentage').textContent,
                currentSourceClass: document.getElementById('currentCollectionSource').className,
                spinnerDisplay: document.getElementById('collectionSpinner').style.display,
                cancelButtonDisabled: document.getElementById('cancelOperation').disabled,
                // Save source counts
                redditCount: document.getElementById('redditCount').textContent,
                fabricCount: document.getElementById('fabricCount').textContent,
                githubCount: document.getElementById('githubCount').textContent,
                adoCount: document.getElementById('adoCount').textContent,
                // Save logs
                logs: document.getElementById('collectionLog').innerHTML,
                timestamp: Date.now()
            };
            localStorage.setItem('progressState', JSON.stringify(progressState));
        }
        
        // Restore progress state from localStorage
        function restoreProgressState() {
            const savedState = localStorage.getItem('progressState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Only restore if state is recent (within 1 hour)
                    if (Date.now() - state.timestamp < 3600000) {
                        // Restore badge
                        document.getElementById('progressBadge').textContent = state.badge;
                        document.getElementById('progressBadge').className = state.badgeClass;
                        
                        // Restore drawer content
                        document.getElementById('collectionSourceText').textContent = state.sourceText;
                        document.getElementById('collectionProgressStatus').textContent = state.progressStatus;
                        document.getElementById('collectionProgressBar').style.width = state.progressBarWidth || '0%';
                        document.getElementById('collectionProgressPercentage').textContent = state.progressPercentage || '0%';
                        document.getElementById('currentCollectionSource').className = state.currentSourceClass || 'alert alert-secondary d-flex align-items-center';
                        document.getElementById('collectionSpinner').style.display = state.spinnerDisplay || 'none';
                        document.getElementById('cancelOperation').disabled = state.cancelButtonDisabled || false;
                        
                        // Restore source counts
                        document.getElementById('redditCount').textContent = state.redditCount || '0';
                        document.getElementById('fabricCount').textContent = state.fabricCount || '0';
                        document.getElementById('githubCount').textContent = state.githubCount || '0';
                        document.getElementById('adoCount').textContent = state.adoCount || '0';
                        
                        // Restore logs
                        if (state.logs) {
                            document.getElementById('collectionLog').innerHTML = state.logs;
                        }
                        
                        console.log('Restored complete progress state:', state.badge);
                    } else {
                        // Clear expired state
                        localStorage.removeItem('progressState');
                        console.log('Cleared expired progress state');
                    }
                } catch (e) {
                    console.error('Error restoring progress state:', e);
                    localStorage.removeItem('progressState');
                }
            }
        }
    </script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Initialize application -->
    <script>
        // Source configuration is already initialized in source-configuration.js
        // No additional initialization needed here
    </script>

    <style>
        /* Category Tree Styles */
        .category-tree {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: #f9f9f9;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .category-node {
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: white;
            padding: 10px;
        }
        
        .category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        
        .category-header strong {
            flex: 1;
            font-size: 1.1em;
            color: #0078d4;
        }
        
        .category-actions {
            display: flex;
            gap: 5px;
        }
        
        .category-content {
            padding: 10px 10px 10px 30px;
        }
        
        .subcategories-container {
            margin-top: 10px;
        }
        
        .subcategory-node {
            margin-bottom: 10px;
            border-left: 3px solid #0078d4;
            padding-left: 10px;
        }
        
        .subcategory-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: #f9f9f9;
            border-radius: 3px;
        }
        
        .subcategory-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .subcategory-name {
            font-weight: 500;
            font-size: 1em;
        }
        
        .subcategory-meta {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 0.85em;
        }
        
        .keyword-count {
            color: #0078d4;
            font-size: 0.85em;
            cursor: help;
        }
        
        .subcategory-actions {
            display: flex;
            gap: 4px;
        }
        
        .subcategory-content {
            padding: 8px 8px 8px 25px;
        }
        
        .subcategory-details {
            font-size: 0.9em;
            color: #555;
        }
        
        .subcategory-details > div {
            margin-bottom: 5px;
        }
        
        .keywords-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .keyword-tag {
            background-color: #e1f5fe;
            color: #0277bd;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            border: 1px solid #b3e5fc;
        }
        
        .expand-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: transform 0.2s;
        }
        
        .expand-btn:hover {
            color: #0078d4;
        }
        
        .btn-icon {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            color: #666;
            transition: all 0.2s;
        }
        
        .btn-icon:hover {
            background-color: #e0e0e0;
            color: #0078d4;
        }
        
        .btn-icon.btn-danger {
            color: #d32f2f;
        }
        
        .btn-icon.btn-danger:hover {
            background-color: #ffebee;
            color: #b71c1c;
        }
        
        /* Impact Type Styles */
        .impact-type-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .impact-type-card {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            background-color: white;
            transition: box-shadow 0.2s;
        }
        
        .impact-type-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .impact-type-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .impact-type-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .impact-type-name {
            font-size: 1.1em;
        }
        
        .impact-type-priority {
            font-size: 0.75em;
            text-transform: uppercase;
        }
        
        .impact-type-actions {
            display: flex;
            gap: 5px;
        }
        
        .impact-type-details {
            font-size: 0.9em;
        }
        
        .impact-type-details p {
            margin-bottom: 8px;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #0078d4;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: #000;
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }
        
        /* Keyword Manager Styles */
        .keyword-manager {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            background-color: #f9f9f9;
        }
        
        .keyword-input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .keyword-input-row input {
            flex: 1;
        }
        
        .keyword-tag {
            background-color: #e1f5fe;
            color: #0277bd;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            border: 1px solid #b3e5fc;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .keyword-remove {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0277bd;
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .keyword-remove:hover {
            background-color: #0277bd;
            color: white;
        }
    </style>

</body>
</html>
